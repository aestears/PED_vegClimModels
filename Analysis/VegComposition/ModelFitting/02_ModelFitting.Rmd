---
title: "Models of vegetation composition based on climate predictors"
subtitle: "Based on code from Martin Holdrege's Sagebrush-Fire paper"
author: "Alice Stears"
date: "`r lubridate::today()`"
params: 
  test_run: FALSE
  save_figs: FALSE
  ecoregion: "shrubGrass" #shrubGrass #forest
  response: "TotalHerbaceousCover" #"CAMCover", "TotalHerbaceousCover", "BareGroundCover",                           "BroadleavedTreeCover_prop", "NeedleLeavedTreeCover_prop","C4Cover_prop", "C3Cover_prop", "ForbCover_prop", "ShrubCover"
  hmod: FALSE
  s: "TotalHerbaceousCover"
  #inter: !r c('afgAGB:MAP' = "afgAGB:MAP")
  sample_group: 1
  byRegion: TRUE
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
---
The data consists of vegetation % cover by functional group from across CONUS (from AIM, FIA, LANDFIRE, and RAP), 
as well as climate variables from DayMet, which have been aggregated into mean interannual conditions accross multiple temporal windows. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE,
                      message = FALSE)
```

# Dependencies 

User defined parameters

```{r}
print(params)
# set to true if want to run for a limited number of rows (i.e. for code testing)
test_run <- params$test_run
save_figs <- params$save_figs
hmod <- params$hmod # whether to include human modification in the model
# by changing the sample_group the model can be fit to a completely different set of rows
sample_group <- params$sample_group 
response <- params$response
# _ann defines this model as being built on annual data
s <- params$s # string to paste to file names e.g., that defines the interactions in the model
# such as (summer ppt * MAT) and annuals*temperature interactions
fit_sample <- TRUE # fit model to a sample of the data
n_train <- 5e4 # sample size of the training data
n_test <- 1e6 # sample size of the testing data (if this is too big the decile dotplot code throws memory errors)
byRegion <- params$byRegion
```


```{r warning=FALSE, message=FALSE}
# set option so resampled dataset created here reproduces earlier runs of this code with dplyr 1.0.10
source("../../../Functions/glmTransformsIterates.R")
source("../../../Functions/transformPreds.R")
source("../../../Functions/StepBeta_mine.R")
#source("src/fig_params.R")
#source("src/modeling_functions.R")

library(terra)
library(tidyterra)
library(sf)
library(caret)
library(betareg)
library(tidyverse)
library(GGally) # for ggpairs()
library(pdp) # for partial dependence plots
library(gridExtra)
library(knitr)
library(patchwork) # for figure insets etc. 
library(ggtext)
library(StepBeta)
theme_set(theme_classic())
library(here)
library(rsample)
```

# read in data

Data compiled in the `prepDataForModels.R` script

```{r}
here::i_am("Analysis/VegComposition/ModelFitting/01_PredictorVarSelection.Rmd")
modDat <- readRDS( here("Data_processed", "CoverData", "DataForModels_spatiallyAveraged_withSoils_noSf.rds"))
## there are some values of the annual wet degree days 5th percentile that have -Inf?? change to lowest value for now? 
modDat[is.infinite(modDat$annWetDegDays_5percentile_3yrAnom), "annWetDegDays_5percentile_3yrAnom"] <- -47.8
## same, but for annual water deficit 95th percentile 
modDat[is.infinite(modDat$annWaterDeficit_95percentile_3yrAnom), "annWaterDeficit_95percentile_3yrAnom"] <- -600

# # Convert total cover variables into proportions (for later use in beta regression models) ... proportions are already scaled from zero to 1
# modDat <- modDat %>% 
#   mutate(TotalTreeCover = TotalTreeCover/100,
#          CAMCover = CAMCover/100,
#          TotalHerbaceousCover = TotalHerbaceousCover/100,
#          BareGroundCover = BareGroundCover/100,
#          ShrubCover = ShrubCover/100
#          )
# # For all response variables, make sure there are no 0s add or subtract .0001 from each, since the Gamma model framework can't handle that
modDat[modDat$TotalTreeCover == 0 & !is.na(modDat$TotalTreeCover), "TotalTreeCover"] <- 0.0001
modDat[modDat$CAMCover == 0 & !is.na(modDat$CAMCover), "CAMCover"] <- 0.0001
modDat[modDat$TotalHerbaceousCover == 0  & !is.na(modDat$TotalHerbaceousCover), "TotalHerbaceousCover"] <- 0.0001
modDat[modDat$BareGroundCover == 0 & !is.na(modDat$BareGroundCover), "BareGroundCover"] <- 0.0001
modDat[modDat$ShrubCover == 0 & !is.na(modDat$ShrubCover), "ShrubCover"] <- 0.0001
modDat[modDat$BroadleavedTreeCover_prop == 0 & !is.na(modDat$BroadleavedTreeCover_prop), "BroadleavedTreeCover_prop"] <- 0.0001
modDat[modDat$NeedleLeavedTreeCover_prop == 0 & !is.na(modDat$NeedleLeavedTreeCover_prop), "NeedleLeavedTreeCover_prop"] <- 0.0001
modDat[modDat$C4Cover_prop == 0 & !is.na(modDat$C4Cover_prop), "C4Cover_prop"] <- 0.0001
modDat[modDat$C3Cover_prop == 0 & !is.na(modDat$C3Cover_prop), "C3Cover_prop"] <- 0.0001
modDat[modDat$ForbCover_prop == 0 & !is.na(modDat$ForbCover_prop), "ForbCover_prop"] <- 0.0001
# 
# modDat[modDat$TotalTreeCover ==1& !is.na(modDat$TotalTreeCover), "TotalTreeCover"] <- 0.999
# modDat[modDat$CAMCover ==1& !is.na(modDat$CAMCover), "CAMCover"] <- 0.999
# modDat[modDat$TotalHerbaceousCover ==1 & !is.na(modDat$TotalHerbaceousCover), "TotalHerbaceousCover"] <- 0.999
# modDat[modDat$BareGroundCover ==1& !is.na(modDat$BareGroundCover), "BareGroundCover"] <- 0.999
# modDat[modDat$ShrubCover ==1& !is.na(modDat$ShrubCover), "ShrubCover"] <- 0.999
# modDat[modDat$BroadleavedTreeCover_prop ==1& !is.na(modDat$BroadleavedTreeCover_prop), "BroadleavedTreeCover_prop"] <- 0.999
# modDat[modDat$NeedleLeavedTreeCover_prop ==1& !is.na(modDat$NeedleLeavedTreeCover_prop), "NeedleLeavedTreeCover_prop"] <- 0.999
# modDat[modDat$C4Cover_prop ==1& !is.na(modDat$C4Cover_prop), "C4Cover_prop"] <- 0.999
# modDat[modDat$C3Cover_prop ==1& !is.na(modDat$C3Cover_prop), "C3Cover_prop"] <- 0.999
# modDat[modDat$ForbCover_prop ==1& !is.na(modDat$ForbCover_prop), "ForbCover_prop"] <- 0.999

```


# Prep data

```{r}
set.seed(1234)
modDat_1 <- modDat %>% 
  select(-c(prcp_annTotal:annVPD_min)) %>% 
  # mutate(Lon = st_coordinates(.)[,1], 
  #        Lat = st_coordinates(.)[,2])  %>% 
  # st_drop_geometry() %>% 
  # filter(!is.na(newRegion))
  rename("tmin" = tmin_meanAnnAvg_CLIM, 
     "tmax" = tmax_meanAnnAvg_CLIM, #1
     "tmean" = tmean_meanAnnAvg_CLIM, 
     "prcp" = prcp_meanAnnTotal_CLIM, 
     "t_warm" = T_warmestMonth_meanAnnAvg_CLIM,
     "t_cold" = T_coldestMonth_meanAnnAvg_CLIM, 
     "prcp_wet" = precip_wettestMonth_meanAnnAvg_CLIM,
     "prcp_dry" = precip_driestMonth_meanAnnAvg_CLIM, 
     "prcp_seasonality" = precip_Seasonality_meanAnnAvg_CLIM, #2
     "prcpTempCorr" = PrecipTempCorr_meanAnnAvg_CLIM,  #3
     "abvFreezingMonth" = aboveFreezing_month_meanAnnAvg_CLIM, 
     "isothermality" = isothermality_meanAnnAvg_CLIM, #4
     "annWatDef" = annWaterDeficit_meanAnnAvg_CLIM, 
     "annWetDegDays" = annWetDegDays_meanAnnAvg_CLIM,
     "VPD_mean" = annVPD_mean_meanAnnAvg_CLIM, 
     "VPD_max" = annVPD_max_meanAnnAvg_CLIM, #5
     "VPD_min" = annVPD_min_meanAnnAvg_CLIM, #6
     "VPD_max_95" = annVPD_max_95percentile_CLIM, 
     "annWatDef_95" = annWaterDeficit_95percentile_CLIM, 
     "annWetDegDays_5" = annWetDegDays_5percentile_CLIM, 
     "frostFreeDays_5" = durationFrostFreeDays_5percentile_CLIM, 
     "frostFreeDays" = durationFrostFreeDays_meanAnnAvg_CLIM, 
     "soilDepth" = soilDepth, #7
     "clay" = surfaceClay_perc, 
     "sand" = avgSandPerc_acrossDepth, #8
     "coarse" = avgCoarsePerc_acrossDepth, #9
     "carbon" = avgOrganicCarbonPerc_0_3cm, #10
     "AWHC" = totalAvailableWaterHoldingCapacity,
     ## anomaly variables
     tmean_anom = tmean_meanAnnAvg_3yrAnom, #15
     tmin_anom = tmin_meanAnnAvg_3yrAnom, #16
     tmax_anom = tmax_meanAnnAvg_3yrAnom, #17
    prcp_anom = prcp_meanAnnTotal_3yrAnom, #18
      t_warm_anom = T_warmestMonth_meanAnnAvg_3yrAnom,  #19
     t_cold_anom = T_coldestMonth_meanAnnAvg_3yrAnom, #20
      prcp_wet_anom = precip_wettestMonth_meanAnnAvg_3yrAnom, #21
      precp_dry_anom = precip_driestMonth_meanAnnAvg_3yrAnom,  #22
    prcp_seasonality_anom = precip_Seasonality_meanAnnAvg_3yrAnom, #23 
     prcpTempCorr_anom = PrecipTempCorr_meanAnnAvg_3yrAnom, #24
      aboveFreezingMonth_anom = aboveFreezing_month_meanAnnAvg_3yrAnom, #25  
    isothermality_anom = isothermality_meanAnnAvg_3yrAnom, #26
       annWatDef_anom = annWaterDeficit_meanAnnAvg_3yrAnom, #27
     annWetDegDays_anom = annWetDegDays_meanAnnAvg_3yrAnom,  #28
      VPD_mean_anom = annVPD_mean_meanAnnAvg_3yrAnom, #29
      VPD_min_anom = annVPD_min_meanAnnAvg_3yrAnom,  #30
      VPD_max_anom = annVPD_max_meanAnnAvg_3yrAnom,  #31
     VPD_max_95_anom = annVPD_max_95percentile_3yrAnom, #32
      annWatDef_95_anom = annWaterDeficit_95percentile_3yrAnom, #33 
      annWetDegDays_5_anom = annWetDegDays_5percentile_3yrAnom ,  #34
    frostFreeDays_5_anom = durationFrostFreeDays_5percentile_3yrAnom, #35 
      frostFreeDays_anom = durationFrostFreeDays_meanAnnAvg_3yrAnom #36
  )

# small dataset for if testing the data
if(test_run) {
  modDat_1 <- slice_sample(modDat_1, n = 1e5)
}
```

Identify the ecoregion and response variable type to use in this model run 
```{r}
ecoregion <- params$ecoregion
response <- params$response
print(paste0("In this model run, the ecoregion is ", ecoregion," and the response variable is ",response))
```

Subset the data to only include data for the ecoregion of interest
```{r}

if (ecoregion == "shrubGrass") {
  # select data for the ecoregion of interest
  modDat_1 <- modDat_1 %>%
    filter(newRegion == "dryShrubGrass")
} else if (ecoregion == "forest") {
  # select data for the ecoregion of interest
  modDat_1 <- modDat_1 %>% 
    filter(newRegion %in% c("eastForest", "westForest"))
}

# remove the rows that have no observations for the response variable of interest
modDat_1 <- modDat_1[!is.na(modDat_1[,response]),]
```

## Visualize the response variable 
```{r}
hist(modDat_1[,response], main = paste0("Histogram of ",response," transformed to proportion scale"),
     xlab = paste0(response,"/100"))
```


## Visualize the predictor variables

The following are the candidate predictor variables for this ecoregion: 
```{r}
if (ecoregion == "shrubGrass") {
  # select potential predictor variables for the ecoregion of interest
        prednames <-
          c("tmin", "tmean", "prcp", 
            "prcp_seasonality", "prcpTempCorr", 
            "sand", "coarse", "AWHC", 
            "tmin_anom", "tmax_anom", 
             "t_warm_anom", "t_cold_anom",
            "prcp_wet_anom", "precp_dry_anom", 
"prcp_seasonality_anom", "prcpTempCorr_anom", 
"aboveFreezingMonth_anom", "isothermality_anom", 
"annWatDef_anom", "annWetDegDays_anom", 
"VPD_min_anom", "VPD_max_95_anom", 
"annWatDef_95_anom", "annWetDegDays_5_anom", 
"frostFreeDays_5_anom")
  
} else if (ecoregion == "forest") {
  # select potential predictor variables for the ecoregion of interest
  prednames <- 
    c(
      "tmin", "prcp", 
      "t_warm", "prcp_dry", 
      "prcpTempCorr", "isothermality", 
      "annWetDegDays", "sand", 
      "coarse", "carbon", 
      "AWHC",
      "tmin_anom", "tmax_anom", 
            "prcp_anom", "t_warm_anom", 
      "t_cold_anom", "prcp_wet_anom",
      "precp_dry_anom", "prcp_seasonality_anom", 
      "prcpTempCorr_anom", "aboveFreezingMonth_anom", "isothermality_anom",
"annWatDef_anom", "annWetDegDays_anom", 
"VPD_min_anom", "VPD_max_95_anom", 
"annWatDef_95_anom", "annWetDegDays_5_anom", 
"frostFreeDays_5_anom"
    )
}

# subset the data to only include these predictors, and remove any remaining NAs 
modDat_1 <- modDat_1 %>% 
  select(prednames, response, newRegion, Year.x, Long, Lat) %>% 
  drop_na()

names(prednames) <- prednames
df_pred <- modDat_1[, prednames]
# 
# # print the list of predictor variables
# knitr::kable(format = "html", data.frame("Possible_Predictors" = prednames)
# ) %>%
#   kable_styling(bootstrap_options = c("striped", "hover", "condensed")) 
```


```{r summary_table}
create_summary <- function(df) {
  df %>% 
    pivot_longer(cols = everything(),
                 names_to = 'variable') %>% 
    group_by(variable) %>% 
    summarise(across(value, .fns = list(mean = ~mean(.x, na.rm = TRUE), min = ~min(.x, na.rm = TRUE), 
                                        median = ~median(.x, na.rm = TRUE), max = ~max(.x, na.rm = TRUE)))) %>% 
    mutate(across(where(is.numeric), round, 4))
}

modDat_1[prednames] %>% 
  create_summary() %>% 
  knitr::kable(caption = 'summaries of possible predictor variables') %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed")) 


# response_summary <- modDat_1 %>% 
#     dplyr::select(#where(is.numeric), -all_of(pred_vars),
#       matches(response)) %>% 
#     create_summary()
# 
# 
# kable(response_summary, 
#       caption = 'summaries of response variables, calculated using paint') %>%
# kable_styling(bootstrap_options = c("striped", "hover", "condensed")) 

```

## Plot predictor vars against each other

```{r pred_v_pred, fig.width=10}
set.seed(12011993)
# function for colors
my_fn <- function(data, mapping, method="p", use="pairwise", ...){
  
  # grab data
  x <- eval_data_col(data, mapping$x)
  y <- eval_data_col(data, mapping$y)
  
  # calculate correlation
  corr <- cor(x, y, method=method, use=use)
  
  # calculate colour based on correlation value
  # Here I have set a correlation of minus one to blue, 
  # zero to white, and one to red 
  # Change this to suit: possibly extend to add as an argument of `my_fn`
  colFn <- colorRampPalette(c("red", "white", "blue"), interpolate ='spline')
  fill <- colFn(100)[findInterval(corr, seq(-1, 1, length=100))]
  
  ggally_cor(data = data, mapping = mapping, size = 2.5, stars = FALSE, 
             digits = 2, colour = I("black"),...) + 
    theme_void() +
    theme(panel.background = element_rect(fill=fill))
  
}
(corrPlot <- modDat_1 %>% 
  select(prednames) %>% 
  slice_sample(n = 5e4) %>% 
  #select(-matches("_")) %>% 
ggpairs( upper = list(continuous = my_fn, size = .1), lower = list(continuous = GGally::wrap("points", alpha = 0.1, size=0.1)), progress = FALSE))
```

## boxplots-- # predictor variables compared to binned response variables

```{r climVar_boxplots, fig.height=9, fig.width=8}
set.seed(12011993)
# vector of name of response variables
vars_response <- response

# longformat dataframes for making boxplots
df_sample_plots <-  modDat_1  %>% 
  slice_sample(n = 5e4) %>% 
   rename(response = all_of(response)) %>% 
  mutate(response = case_when(
    response <= .25 ~ ".25", 
    response > .25 & response <=.5 ~ ".5", 
    response > .5 & response <=.75 ~ ".75", 
    response >= .75  ~ "1", 
  )) %>% 
  select(c(response, prednames)) %>% 
  pivot_longer(cols = names(prednames), 
               names_to = "predictor", 
               values_to = "value") %>% 
  filter(!is.na(response) & !is.na(value)) 
 

  ggplot(df_sample_plots, aes_string(x= "response", y = 'value')) +
  geom_boxplot() +
  facet_wrap(~predictor , scales = 'free_y') + 
  ylab("Predictor Variable Values") 

```

## Fit a null model w/ no predictors 
With the full dataset (full response variables) -- using a glm with a Gamma link for now
```{r}
nullMod_1 <- glm(data = modDat_1, formula = modDat_1[,response] ~ 1, family = "Gamma"(link = "log"))

summary(nullMod_1)
#plot(nullMod_1)
# 
# test <- (modDat_1[,response]/100-.00000001)
# nullMod_4 <- betareg(formula = test ~ 1,
#                               link = c("logit"), link.phi = NULL,
#                                type = c("ML"))
```

## Find the outer level of cross-validation

```{r}
# - + define simulation settings ----

# - ++ hold-out strategy (outer loop) ----
h_all = c("environmentalblock")#,'lastyears',)
# - ++ cross-validation strategy (inner loop) ----
cv_all = c('environmentalblock')

start.time <- Sys.time()

# data to use are modDat_1 

## make data into spatial format
modDat_1_sf <- modDat_1 %>% 
  st_as_sf(coords = c("Long", "Lat"), crs = st_crs("PROJCRS[\"unnamed\",\n    BASEGEOGCRS[\"unknown\",\n        DATUM[\"unknown\",\n            ELLIPSOID[\"Spheroid\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1,\n                    ID[\"EPSG\",9001]]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]],\n    CONVERSION[\"Lambert Conic Conformal (2SP)\",\n        METHOD[\"Lambert Conic Conformal (2SP)\",\n            ID[\"EPSG\",9802]],\n        PARAMETER[\"Latitude of false origin\",42.5,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",-100,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",25,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",60,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"northing\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]"))
# covariate names are stored in prednames

# response name is stored in response

  nfolds = 10 ##AES may need to change, not sure how many 
  nrepeats = 1
  
  
  
  for(h_i in 1:length(h_all)){
    
    print(paste("Running",h_all[h_i],"hold-outs, starting at",hms::round_hms(Sys.time(), secs = 1, digits = NULL)))
    
    outer_split <- hold_out_data_rsample(df = modDat_1, holdout_method = h_all[h_i], n_folds = nfolds, n_repeats = nrepeats, lastnyears = 5)
    
    # add a repetition column even if there is only 1 repetition
    if('Fold01' %in% outer_split$id |  'Resample01' %in% outer_split$id | 'Fold1' %in% outer_split$id |  'Resample1' %in% outer_split$id ){
      outer_split$id2 = outer_split$id
      outer_split$id = 'Repeat1'
    }
    
    for(j_i in 1:length(cv_all)){
      
      print(paste("Running",h_all[h_i],"hold-outs with",cv_all[j_i],"cross-validation, starting at",hms::round_hms(Sys.time(), secs = 1, digits = NULL)))
      
      nested_split <- inner_split_cv(x = data_seedingOutcomes, outer_folds = outer_split, cv_method = cv_all[j_i], n_folds = nfolds, n_repeats = nrepeats)
      
      # add a repetition column even if there is only 1 repetition
      if('Fold01' %in% nested_split$inner_resamples[[1]]$id | 'Resample01' %in% nested_split$inner_resamples[[1]]$id | 'Fold1' %in% nested_split$inner_resamples[[1]]$id |  'Resample1' %in% nested_split$inner_resamples[[1]]$id){
        for(k in 1:length(nested_split$inner_resamples)){
          nested_split$inner_resamples[[k]]$id2 = nested_split$inner_resamples[[k]]$id
          nested_split$inner_resamples[[k]]$id = 'Repeat1'
        }
      }
      
      outputList[[cumulative.index]]<-replicateRuns(nested_splits = nested_split, hmethod=h_all[h_i], cvmethod=cv_all[j_i])
      
      # increment index
      cumulative.index <- cumulative.index + 1
      
    }
    
    holdOutList[[h_i]] <- nested_split
  }

  
  saveRDS(outputList,here::here("03_outputs","08_nestedCrossValidation",paste0(current.species,"-nestedCv-longtermclimate-",nfolds,"outerFolds-results.RDS")))
  saveRDS(holdOutList,here::here("03_outputs","06_modelData",paste0(current.species,"-nestedCv-longtermclimate-",nfolds,"outerFolds-data.RDS")))
  
end.time <- Sys.time()
run.time = end.time-start.time
run.time
```



Repeat the following process x # of times for cross validation [
1. Subset the data into training and test datasets 

2. Then, use cross-validation within the training dataset to identify the appropriate regularization parameter

3. Then, fit the model to the entire training dataset (including climate vars, soils vars, weather vars, and interactions  )]


Break the data into three groups for model fitting based on lumped ecoregions


Training data

```{r}
if (byRegion == TRUE) {
  ## for western forests
  wf_sample <- if(fit_sample & !test_run) {
  reordered <- slice_sample(modDat_westForest, prop = 1)
  
  low <- (sample_group - 1)*n_train + 1 # first row (of reordered data) to get
  high <- low + n_train - 1 # last row
  if(high > nrow(modDat_westForest)) {
    warning(paste0("n_train size due to low sample size (i.e. < ", n_train,")"))
    n_train <- n_train*.8
     low <- (sample_group - 1)*n_train + 1 # first row (of reordered data) to get
  high <- low + n_train - 1 # last row
   #stop('trying to sample from rows that dont exist')
  }
  reordered[low:high, ]
} else {
    modDat_westForest
}

wf_test <- if(fit_sample & !test_run & 
              # antijoin only works if there are enough rows that meet 
              # that criterion, i.e. if wf_sample contains most of the data i
              # doesnt' work
              (nrow(modDat_westForest) - nrow(wf_sample) > n_test)) {
  modDat_westForest %>% 
    anti_join(wf_sample, by = c("cell_num", "year")) %>% 
    slice_sample(n = n_test)
} else {
  modDat_westForest %>% 
    slice_sample(n = n_test)
}

# small sample for certain plots
wf_small <- slice_sample(modDat_westForest, n = 1e5)

# for eastern forests
ef_sample <- if(fit_sample & !test_run) {
  reordered <- slice_sample(modDat_eastForest, prop = 1)
  
  low <- (sample_group - 1)*n_train + 1 # first row (of reordered data) to get
  high <- low + n_train - 1 # last row
  if(high > nrow(modDat_eastForest)) {
    warning(paste0("n_train size due to low sample size (i.e. < ", n_train,")"))
    n_train <- n_train*.8
     low <- (sample_group - 1)*n_train + 1 # first row (of reordered data) to get
  high <- low + n_train - 1 # last row
   #stop('trying to sample from rows that dont exist')
  }
  reordered[low:high, ]
} else {
    modDat_eastForest
}

ef_test <- if(fit_sample & !test_run & 
              # antijoin only works if there are enough rows that meet 
              # that criterion, i.e. if ef_sample contains most of the data i
              # doesnt' work
              (nrow(modDat_eastForest) - nrow(ef_sample) > n_test)) {
  modDat_eastForest %>% 
    anti_join(ef_sample, by = c("cell_num", "year")) %>% 
    slice_sample(n = n_test)
} else {
  modDat_eastForest %>% 
    slice_sample(n = n_test)
}

# small sample for certain plots
ef_small <- slice_sample(modDat_eastForest, n = 1e5)

## for grass/shrubs
g_sample <- if(fit_sample & !test_run) {
  reordered <- slice_sample(modDat_shrubGrass, prop = 1)
  
  low <- (sample_group - 1)*n_train + 1 # first row (of reordered data) to get
  high <- low + n_train - 1 # last row
  if(high > nrow(modDat_shrubGrass)) {
    warning(paste0("n_train size due to low sample size (i.e. < ", n_train,")"))
    n_train <- n_train*.8
     low <- (sample_group - 1)*n_train + 1 # first row (of reordered data) to get
  high <- low + n_train - 1 # last row
   #stop('trying to sample from rows that dont exist')
  }
  reordered[low:high, ]
} else {
    modDat_shrubGrass
}

g_test <- if(fit_sample & !test_run & 
              # antijoin only works if there are enough rows that meet 
              # that criterion, i.e. if g_sample contains most of the data i
              # doesnt' work
              (nrow(modDat_shrubGrass) - nrow(g_sample) > n_test)) {
  modDat_shrubGrass %>% 
    anti_join(g_sample, by = c("cell_num", "year")) %>% 
    slice_sample(n = n_test)
} else {
  modDat_shrubGrass %>% 
    slice_sample(n = n_test)
}

# small sample for certain plots
g_small <- slice_sample(modDat_shrubGrass, n = 1e5)

## do full dataset as well 
df_sample <- if(fit_sample & !test_run) {
  reordered <- slice_sample(modDat_1, prop = 1)
  
  low <- (sample_group - 1)*n_train + 1 # first row (of reordered data) to get
  high <- low + n_train - 1 # last row
  if(high > nrow(modDat_1)) {
    warning(paste0("n_train size due to low sample size (i.e. < ", n_train,")"))
    n_train <- n_train*.8
     low <- (sample_group - 1)*n_train + 1 # first row (of reordered data) to get
  high <- low + n_train - 1 # last row
   #stop('trying to sample from rows that dont exist')
  }
  reordered[low:high, ]
} else {
    modDat_1
}

df_test <- if(fit_sample & !test_run & 
              # antijoin only works if there are enough rows that meet 
              # that criterion, i.e. if df_sample contains most of the data i
              # doesnt' work
              (nrow(modDat_1) - nrow(df_sample) > n_test)) {
  modDat_1 %>% 
    anti_join(df_sample, by = c("cell_num", "year")) %>% 
    slice_sample(n = n_test)
} else {
  modDat_1 %>% 
    slice_sample(n = n_test)
}

# small sample for certain plots
df_small <- slice_sample(modDat_1, n = 1e5)

} else  if (byRegion == FALSE) {
  
  df_sample <- if(fit_sample & !test_run) {
  reordered <- slice_sample(modDat_1, prop = 1)
  
  low <- (sample_group - 1)*n_train + 1 # first row (of reordered data) to get
  high <- low + n_train - 1 # last row
  if(high > nrow(modDat_1)) {
    warning(paste0("n_train size due to low sample size (i.e. < ", n_train,")"))
    n_train <- n_train*.8
     low <- (sample_group - 1)*n_train + 1 # first row (of reordered data) to get
  high <- low + n_train - 1 # last row
   #stop('trying to sample from rows that dont exist')
  }
  reordered[low:high, ]
} else {
    modDat_1
}

df_test <- if(fit_sample & !test_run & 
              # antijoin only works if there are enough rows that meet 
              # that criterion, i.e. if df_sample contains most of the data i
              # doesnt' work
              (nrow(modDat_1) - nrow(df_sample) > n_test)) {
  modDat_1 %>% 
    anti_join(df_sample, by = c("cell_num", "year")) %>% 
    slice_sample(n = n_test)
} else {
  modDat_1 %>% 
    slice_sample(n = n_test)
}

# small sample for certain plots
df_small <- slice_sample(modDat_1, n = 1e5)
}
```




# GLMs 

## fitting models

### fitting various transforms

Creating formulas where each variable on its own is transformed numerous ways
(including formula to fit spline), all other variables are left alone,
that repeated for each variable. So have models with 1 variable transformed,
2 transformed, etc. 

see documentation for glms_iterate_transforms, in the modelling_functions.R
script

```{r iterate_transform, warning = FALSE}
set.seed(1234)

# parentheses around interaction
# term are included so that glms_iterate_transforms doesn't transform
# the interaction term. 
#pred_vars_inter <- c(pred_vars, params$inter)


# pred_vars_inter <- pred_vars
mods_glm_transf_temp <- glmTransformsIterates(
  preds = pred_vars, 
  df = df_sample,
  response_var = response, 
  delta_aic = 10)

# not including the last element of the list which is final_formula
mods_glm_transf <- mods_glm_transf_temp[-length(mods_glm_transf_temp)]

map_dfc(mods_glm_transf, ~ names(.$aic[1:5])) %>% 
  kable(caption = "5 best transformations at each step")
best_aic_by_step <- map_dbl(mods_glm_transf, ~.$aic[1])

best_aic_by_step <- c(step0 = mods_glm_transf_temp$step1$aic[['convert_none']], 
                      best_aic_by_step)
# AIC improvement by step
diff(best_aic_by_step)
plot(y = best_aic_by_step, 
     x = 1:length(best_aic_by_step) - 1,
     ylab = "AIC",
     xlab = "Number of variables transformed")

if (byRegion == TRUE) {
  ## for western forests
  mods_glm_transf_WF_temp <- glmTransformsIterates(
  preds = pred_vars, 
  df = wf_sample,
  response_var = response, 
  delta_aic = 10)

# not including the last element of the list which is final_formula
mods_glm_transf_WF <- mods_glm_transf_WF_temp[-length(mods_glm_transf_WF_temp)]

map_dfc(mods_glm_transf_WF, ~ names(.$aic[1:5])) %>% 
  kable(caption = "5 best transformations at each step")
best_aic_by_step_WF <- map_dbl(mods_glm_transf_WF, ~.$aic[1])

best_aic_by_step_WF <- c(step0 = mods_glm_transf_WF_temp$step1$aic[['convert_none']], 
                      best_aic_by_step_WF)
# AIC improvement by step
diff(best_aic_by_step_WF)
plot(y = best_aic_by_step_WF, 
     x = 1:length(best_aic_by_step_WF) - 1,
     ylab = "AIC",
     xlab = "Number of variables transformed")

## for eastern forests
  mods_glm_transf_EF_temp <- glmTransformsIterates(
  preds = pred_vars, 
  df = ef_sample,
  response_var = response, 
  delta_aic = 10)

# not including the last element of the list which is final_formula
mods_glm_transf_EF <- mods_glm_transf_EF_temp[-length(mods_glm_transf_EF_temp)]

map_dfc(mods_glm_transf_EF, ~ names(.$aic[1:5])) %>% 
  kable(caption = "5 best transformations at each step")
best_aic_by_step_EF <- map_dbl(mods_glm_transf_EF, ~.$aic[1])

best_aic_by_step_EF <- c(step0 = mods_glm_transf_EF_temp$step1$aic[['convert_none']], 
                      best_aic_by_step_EF)
# AIC improvement by step
diff(best_aic_by_step_EF)
plot(y = best_aic_by_step_EF, 
     x = 1:length(best_aic_by_step_EF) - 1,
     ylab = "AIC",
     xlab = "Number of variables transformed")

## for grasslands/shrubs
  mods_glm_transf_G_temp <- glmTransformsIterates(
  preds = pred_vars, 
  df = g_sample,
  response_var = response, 
  delta_aic = 10)

# not including the last element of the list which is final_formula
mods_glm_transf_G <- mods_glm_transf_G_temp[-length(mods_glm_transf_G_temp)]

map_dfc(mods_glm_transf_G, ~ names(.$aic[1:5])) %>% 
  kable(caption = "5 best transformations at each step")
best_aic_by_step_G <- map_dbl(mods_glm_transf_G, ~.$aic[1])

best_aic_by_step_G <- c(step0 = mods_glm_transf_G_temp$step1$aic[['convert_none']], 
                      best_aic_by_step_G)
# AIC improvement by step
diff(best_aic_by_step_G)
plot(y = best_aic_by_step_G, 
     x = 1:length(best_aic_by_step_G) - 1,
     ylab = "AIC",
     xlab = "Number of variables transformed")
}


```

Best transformation each step.

```{r}
bestTransformed <- mods_glm_transf_temp$final_formula
if (byRegion == TRUE) {
  # for western forests
  #var_transformed_WF <- map(mods_glm_transf_WF, function(x) x$var_transformed)
bestTransformed_WF <- mods_glm_transf_WF_temp$final_formula

# for eastern forests
#var_transformed_EF <- map(mods_glm_transf_EF, function(x) x$var_transformed)
bestTransformed_EF <- mods_glm_transf_EF_temp$final_formula

# for grass/shrub
#var_transformed_G <- map(mods_glm_transf_G, function(x) x$var_transformed)
bestTransformed_G <- mods_glm_transf_G_temp$final_formula
}

```

### adding interaction terms 
Plot potential interaction terms using raw data

across values of swe
```{r}
# calculate quantiles
swe_quants <- quantile(df_sample$swe_meanAnnAvg_30yr, na.rm = TRUE)
# longformat dataframe for making boxplots
df_sample_swe <-  df_sample %>% 
  select(c(response, pred_vars)) %>% 
  # transform the predictors according to above process
  mutate(isotherm = as.numeric(stats::poly(isothermality_meanAnnAvg_30yr,2,raw=TRUE)[,1]),
        
          wetDegDays= as.numeric(stats::poly(annWetDegDays_meanAnnAvg_30yr,2,raw=TRUE)[,1]),
         swe_log = as.numeric(stats::poly(I(log10(I(swe_meanAnnAvg_30yr+1))),2,raw=TRUE)[,1]),
        #swe_log_squared = as.numeric(stats::poly(I(log10(I(swe_meanAnnAvg_30yr+1))),2,raw=TRUE)[,2]),
         tmean_log =            as.numeric(stats::poly(I(log10(I(tmean_meanAnnAvg_30yr+1))),2,raw=TRUE)[,1] ),
         #tmean_log_squared =    as.numeric(stats::poly(I(log10(I(tmean_meanAnnAvg_30yr+1))),2,raw=TRUE)[,2] ),
         prcp_log =             as.numeric(stats::poly(I(log10(I(prcp_meanAnnTotal_30yr+1))),2,raw=TRUE)[,1]),
        # prcp_log_squared =     as.numeric(stats::poly(I(log10(I(prcp_meanAnnTotal_30yr+1))),2,raw=TRUE)[,2]),
         prcpTempCorr = as.numeric(stats::poly(PrecipTempCorr_meanAnnAvg_30yr,2,raw=TRUE)[,1])
         ) %>% 
  rename(response = all_of(response)) %>% 
  # mutate(response = case_when(
  #   response <= .25 ~ ".25", 
  #   response > .25 & response <=.5 ~ ".5", 
  #   response > .5 & response <=.75 ~ ".75", 
  #   response >= .75  ~ "1", 
  # )) %>% 
  # pivot_longer(cols = 2:16, 
  #              names_to = "predictor", 
  #              values_to = "value") %>% 
  # filter(!is.na(response) & !is.na(value))
  mutate(swe_meanAnnAvg_30yr_quants = case_when(
    swe_meanAnnAvg_30yr <= swe_quants[2] ~ swe_quants[2], 
    swe_meanAnnAvg_30yr > swe_quants[2]  & swe_meanAnnAvg_30yr <= swe_quants[3]  ~ swe_quants[3], 
    swe_meanAnnAvg_30yr > swe_quants[3]  & swe_meanAnnAvg_30yr <= swe_quants[4]  ~ swe_quants[4], 
    swe_meanAnnAvg_30yr >= swe_quants[4]  ~ swe_quants[5], 
  )) %>% 
  pivot_longer(cols = 2:13, 
               names_to = "predictor", 
               values_to = "value") %>% 
  filter(!is.na(response) & !is.na(value))

# plot relationships amongst variables according to different levels of SWE 
ggplot(data = df_sample_swe[!(df_sample_swe$predictor %in% c("swe_log","swe_meanAnnAvg_30yr")),]) + 
  #geom_point(aes(y = response, x = value, col = as.factor(swe_meanAnnAvg_30yr_quants)), alpha = .5) +
  geom_smooth(aes(y = response, x = value,  col = as.factor(swe_meanAnnAvg_30yr_quants)), method = "gam") + 
  facet_wrap(~predictor, scales = "free_x")
```

Mean Annual Temperature
```{r}
tmean_quants <- quantile(df_sample$tmean_meanAnnAvg_30yr, na.rm = TRUE)

# longformat dataframe for making boxplots
df_sample_tmean <-  df_sample %>% 
  select(c(response, pred_vars)) %>% 
  # transform the predictors according to above process
  mutate(isotherm = as.numeric(stats::poly(isothermality_meanAnnAvg_30yr,2,raw=TRUE)[,1]),
        
          wetDegDays= as.numeric(stats::poly(annWetDegDays_meanAnnAvg_30yr,2,raw=TRUE)[,1]),
         swe_log = as.numeric(stats::poly(I(log10(I(swe_meanAnnAvg_30yr+1))),2,raw=TRUE)[,1]),
        #swe_log_squared = as.numeric(stats::poly(I(log10(I(swe_meanAnnAvg_30yr+1))),2,raw=TRUE)[,2]),
         tmean_log =            as.numeric(stats::poly(I(log10(I(tmean_meanAnnAvg_30yr+1))),2,raw=TRUE)[,1] ),
         #tmean_log_squared =    as.numeric(stats::poly(I(log10(I(tmean_meanAnnAvg_30yr+1))),2,raw=TRUE)[,2] ),
         prcp_log =             as.numeric(stats::poly(I(log10(I(prcp_meanAnnTotal_30yr+1))),2,raw=TRUE)[,1]),
        # prcp_log_squared =     as.numeric(stats::poly(I(log10(I(prcp_meanAnnTotal_30yr+1))),2,raw=TRUE)[,2]),
         prcpTempCorr = as.numeric(stats::poly(PrecipTempCorr_meanAnnAvg_30yr,2,raw=TRUE)[,1])
         ) %>% 
  rename(response = all_of(response)) %>% 
  # mutate(response = case_when(
  #   response <= .25 ~ ".25", 
  #   response > .25 & response <=.5 ~ ".5", 
  #   response > .5 & response <=.75 ~ ".75", 
  #   response >= .75  ~ "1", 
  # )) %>% 
  # pivot_longer(cols = 2:16, 
  #              names_to = "predictor", 
  #              values_to = "value") %>% 
  # filter(!is.na(response) & !is.na(value))
  mutate(tmean_meanAnnAvg_30yr_quants = case_when(
    tmean_meanAnnAvg_30yr <= tmean_quants[2] ~ tmean_quants[2], 
    tmean_meanAnnAvg_30yr > tmean_quants[2]  & tmean_meanAnnAvg_30yr <= tmean_quants[3]  ~ tmean_quants[3], 
    tmean_meanAnnAvg_30yr > tmean_quants[3]  & tmean_meanAnnAvg_30yr <= tmean_quants[4]  ~ tmean_quants[4], 
    tmean_meanAnnAvg_30yr >= tmean_quants[4]  ~ tmean_quants[5], 
  )) %>% 
  pivot_longer(cols = 2:13, 
               names_to = "predictor", 
               values_to = "value") %>% 
  filter(!is.na(response) & !is.na(value))

# plot relationships amongst variables according to different levels of tmean 
ggplot(data = df_sample_tmean[!(df_sample_tmean$predictor %in% c("tmean_log", "tmean_meanAnnAvg_30yr")),]) + 
  #geom_point(aes(y = response, x = value, col = as.factor(tmean_meanAnnAvg_30yr_quants)), alpha = .3) +
  geom_smooth(aes(y = response, x = value,  col = as.factor(tmean_meanAnnAvg_30yr_quants)), method = "gam") + 
  facet_wrap(~predictor, scales = "free_x")

```

Mean annual precipitation
```{r}
prcp_quants <- quantile(df_sample$prcp_meanAnnTotal_30yr, na.rm = TRUE)

# longformat dataframe for making boxplots
df_sample_prcp <-  df_sample %>% 
  select(c(response, pred_vars)) %>% 
  # transform the predictors according to above process
  mutate(isotherm = as.numeric(stats::poly(isothermality_meanAnnAvg_30yr,2,raw=TRUE)[,1]),
        
          wetDegDays= as.numeric(stats::poly(annWetDegDays_meanAnnAvg_30yr,2,raw=TRUE)[,1]),
         swe_log = as.numeric(stats::poly(I(log10(I(swe_meanAnnAvg_30yr+1))),2,raw=TRUE)[,1]),
        #swe_log_squared = as.numeric(stats::poly(I(log10(I(swe_meanAnnAvg_30yr+1))),2,raw=TRUE)[,2]),
         tmean_log =            as.numeric(stats::poly(I(log10(I(tmean_meanAnnAvg_30yr+1))),2,raw=TRUE)[,1] ),
         #tmean_log_squared =    as.numeric(stats::poly(I(log10(I(tmean_meanAnnAvg_30yr+1))),2,raw=TRUE)[,2] ),
         prcp_log =             as.numeric(stats::poly(I(log10(I(prcp_meanAnnTotal_30yr+1))),2,raw=TRUE)[,1]),
        # prcp_log_squared =     as.numeric(stats::poly(I(log10(I(prcp_meanAnnTotal_30yr+1))),2,raw=TRUE)[,2]),
         prcpTempCorr = as.numeric(stats::poly(PrecipTempCorr_meanAnnAvg_30yr,2,raw=TRUE)[,1])
         ) %>% 
  rename(response = all_of(response)) %>% 
  # mutate(response = case_when(
  #   response <= .25 ~ ".25", 
  #   response > .25 & response <=.5 ~ ".5", 
  #   response > .5 & response <=.75 ~ ".75", 
  #   response >= .75  ~ "1", 
  # )) %>% 
  # pivot_longer(cols = 2:16, 
  #              names_to = "predictor", 
  #              values_to = "value") %>% 
  # filter(!is.na(response) & !is.na(value))
  mutate(prcp_meanAnnTotal_30yr_quants = case_when(
    prcp_meanAnnTotal_30yr <= prcp_quants[2] ~ prcp_quants[2], 
    prcp_meanAnnTotal_30yr > prcp_quants[2]  & prcp_meanAnnTotal_30yr <= prcp_quants[3]  ~ prcp_quants[3], 
    prcp_meanAnnTotal_30yr > prcp_quants[3]  & prcp_meanAnnTotal_30yr <= prcp_quants[4]  ~ prcp_quants[4], 
    prcp_meanAnnTotal_30yr >= prcp_quants[4]  ~ prcp_quants[5], 
  )) %>% 
  pivot_longer(cols = 2:13, 
               names_to = "predictor", 
               values_to = "value") %>% 
  filter(!is.na(response) & !is.na(value))

# plot relationships amongst variables according to different levels of tmean 
ggplot(data = df_sample_prcp[!(df_sample_prcp$predictor %in% c("prcp_log", "prcp_meanAnnTotal_30yr")),]) + 
  #geom_point(aes(y = response, x = value, col = as.factor(prcp_meanAnnTotal_30yr_quants)), alpha = .3) +
  geom_smooth(aes(y = response, x = value,  col = as.factor(prcp_meanAnnTotal_30yr_quants)), method = "gam") + 
  facet_wrap(~predictor, scales = "free_x")

```


#### we'll try running the model w/ all possible interactions

```{r}


  ## make table of possible interactions
# make list of transformed variables into a data.frame
var_transformed_df <- as.data.frame(str_remove(bestTransformed, paste0(response, " ~ ")) %>% 
  str_split(pattern = fixed(" + "), simplify = TRUE))#purrr::flatten_dfr(var_transformed_WF) #%>%


# if has a "stats::poly( to start, remove that part
temp <- apply(var_transformed_df, MARGIN = 2, FUN = function(x) {
if(str_detect(x, pattern = fixed("stats::poly("))) {
  x_new <- str_remove(x, pattern = fixed("stats::poly(")) %>%
    str_remove_all(pattern = " ") %>% 
  str_remove(pattern = fixed(",2,raw=TRUE)")) 
} else {
  x_new <- x
}
})
  
# combine into the 32 possible interactions
combos <- data.frame(gtools::permutations(n = length(temp),
r = 2,
v = temp))

combos$interactions <- paste0(combos$X1, ":", combos$X2)
# make text string of interactions
int_string <-str_flatten(combos$interactions, collapse = " + ")
# formula w/ interactions included
modWithInteractions <- paste(bestTransformed, "+",int_string) %>% 
str_remove_all(fixed("stats::"))
# refitting the glm with the best formula
mod_glm1 <- betareg(as.formula(modWithInteractions), data = df_sample, link = c("logit"), link.phi = NULL,
 type = c("ML"))                   
 

if (byRegion == TRUE) {
  # western forests
   ## make table of possible interactions
# make list of transformed variables into a data.frame
var_transformed_df_WF <- as.data.frame(str_remove(bestTransformed_WF, paste0(response, " ~ ")) %>% 
  str_split(pattern = fixed(" + "), simplify = TRUE))#purrr::flatten_dfr(var_transformed_WF) #%>%

# if has a "stats::poly( to start, remove that part
temp_WF <- apply(var_transformed_df_WF, MARGIN = 2, FUN = function(x) {
if(str_detect(x, pattern = fixed("stats::poly("))) {
  x_new <- str_remove(x, pattern = fixed("stats::poly(")) %>%
    str_remove_all(" ") %>% 
  str_remove(pattern = fixed(",2,raw=TRUE)"))
} else {
  x_new <- x
}
})
  
# combine into the 32 possible interactions
combos_WF <- data.frame(gtools::permutations(n = length(temp_WF),
r = 2,
v = temp_WF))

combos_WF$interactions <- paste0(combos_WF$X1, ":", combos_WF$X2)
# make text string of interactions
int_string_WF <-str_flatten(combos_WF$interactions, collapse = " + ")
# formula w/ interactions included
modWithInteractions_WF <- paste(bestTransformed_WF, "+", int_string_WF) %>% str_remove_all(fixed("stats::"))
# refitting the glm with the best formula
mod_glm1_WF <- betareg(as.formula(modWithInteractions_WF), data = wf_sample, link = c("logit"), link.phi = NULL,
 type = c("ML"))    

  # eastern forests
    ## make table of possible interactions
# make list of transformed variables into a data.frame
var_transformed_df_EF <- as.data.frame(str_remove(bestTransformed_EF, paste0(response, " ~ ")) %>% 
  str_split(pattern = fixed(" + "), simplify = TRUE))#purrr::flatten_dfr(var_transformed_EF) #%>%

# if has a "stats::poly( to start, remove that part
temp_EF <- apply(var_transformed_df_EF, MARGIN = 2, FUN = function(x) {
if(str_detect(x, pattern = fixed("stats::poly("))) {
  x_new <- str_remove(x, pattern = fixed("stats::poly(")) %>%
    str_remove_all(" ") %>% 
  str_remove(pattern = fixed(",2,raw=TRUE)"))
} else {
  x_new <- x
}
})
  
# combine into the 30 possible interactions
combos_EF <- data.frame(gtools::permutations(n = length(temp_EF),
r = 2,
v = temp_EF))

combos_EF$interactions <- paste0(combos_EF$X1, ":", combos_EF$X2)
# make text string of interactions
int_string_EF <-str_flatten(combos_EF$interactions, collapse = " + ")
# formula w/ interactions included
modWithInteractions_EF <- paste(bestTransformed_EF, "+", int_string_EF) %>% str_remove_all(fixed("stats::"))
# refitting the glm with the best formula
mod_glm1_EF <- betareg(as.formula(modWithInteractions_EF), data = ef_sample, link = c("logit"), link.phi = NULL,
 type = c("ML"))    

  ## grassland/shrubs
    ## make table of possible interactions
# make list of transformed variables into a data.frame
var_transformed_df_G <- as.data.frame(str_remove(bestTransformed_G, paste0(response, " ~ ")) %>% 
  str_split(pattern = fixed(" + "), simplify = TRUE))#purrr::flatten_dfr(var_transformed_G) #%>%

# if has a "stats::poly( to start, remove that part
temp_G <- apply(var_transformed_df_G, MARGIN = 2, FUN = function(x) {
if(str_detect(x, pattern = fixed("stats::poly("))) {
  x_new <- str_remove(x, pattern = fixed("stats::poly(")) %>%
    str_remove_all(" ") %>% 
  str_remove(pattern = fixed(",2,raw=TRUE)"))
} else {
  x_new <- x
}
})
  
# combine into the 30 possible interactions
combos_G <- data.frame(gtools::permutations(n = length(temp_G),
r = 2,
v = temp_G))

combos_G$interactions <- paste0(combos_G$X1, ":", combos_G$X2)
# make text string of interactions
int_string_G <-str_flatten(combos_G$interactions, collapse = " + ")
# formula w/ interactions included
modWithInteractions_G <- paste(bestTransformed_G, "+", int_string_G) %>% str_remove_all(fixed("stats::"))
# rGitting the glm with the best formula
mod_glm1_G <- betareg(as.formula(modWithInteractions_G), data = g_sample, link = c("logit"), link.phi = NULL,
 type = c("ML"))  

}

```

### performing backwards AIC-based model selection 
Using the "StepBeta" function from the StepBeta R package
```{r}

modSelection <- StepBeta_mine(mod_glm1, data = df_sample)
if (byRegion == TRUE) {
  modSelection_WF <- StepBeta_mine(mod_glm1_WF, data = wf_sample)
  modSelection_EF <- StepBeta_mine(mod_glm1_EF, data = ef_sample)
  modSelection_G <- StepBeta_mine(mod_glm1_G, data = g_sample)
}
```

### same model for all response variables

Response variables are the proportion of years in which fires occurred.
Using best model formula selected in the previous step

```{r fit_glm1}

 best_form <- modSelection$formula
print(best_form)

# refitting the glm with the best formula
mod_glmFinal <- betareg(as.formula(best_form), data = df_sample, link = c("logit"), link.phi = NULL,
                              type = c("ML"))

# should be the same AIC (i.e. refitting the same model)
AIC(mod_glmFinal)

if (byRegion == TRUE) {
  ## western forests 
  best_form_WF <- modSelection_WF$formula
print(best_form_WF)

# refitting the glm with the best formula
mod_glmFinal_WF <- betareg(as.formula(best_form_WF), data = wf_sample, link = c("logit"), link.phi = NULL,
                              type = c("ML"))
# should be the same AIC (i.e. refitting the same model)
AIC(mod_glmFinal_WF)

 ## eastern forests 
  best_form_EF <- modSelection_EF$formula
print(best_form_EF)

# refitting the glm with the best formula
mod_glmFinal_EF <- betareg(as.formula(best_form_EF), data = ef_sample, link = c("logit"), link.phi = NULL,
                              type = c("ML"))
# should be the same AIC (i.e. refitting the same model)
AIC(mod_glmFinal_EF)

 ## grass/shrub
  best_form_G <- modSelection_G$formula
print(best_form_G)

# refitting the glm with the best formula
mod_glmFinal_G <- betareg(as.formula(best_form_G), data = g_sample, link = c("logit"), link.phi = NULL,
                              type = c("ML"))
# should be the same AIC (i.e. refitting the same model)
AIC(mod_glmFinal_G)
}


```

## partial dependence & VIP

PDP plot trend made using a small sample of the data

```{r pdp_glm, warning = FALSE, fig.width = 8, fig.height=8}
#vip::vip(mod_glmFinal, num_features = 15)

#pdp_all_vars(mod_glmFinal, mod_vars = pred_vars, ylab = 'probability',train = df_small)

#caret::varImp(mod_glmFinal)
```


## observed vs. predicted

Predicting on the data

```{r}

  # create prediction for each each model
# (i.e. for each fire proporation variable)
predict_by_response <- function(mod, df) {
  df_out <- df

  response_name <- paste0(response, "_pred")
  df_out[[response_name]] <- predict(mod, df, type = 'response')
  df_out
}

pred_glm1 <- predict_by_response(mod_glmFinal, df_test)


if (byRegion == TRUE) {
  ## western forests
  # create prediction 
  pred_glm1_WF <- predict_by_response(mod_glmFinal_WF, wf_test)
  
  ## eastern forests
  # create prediction 
  pred_glm1_EF <- predict_by_response(mod_glmFinal_EF, ef_test)
  
  ## grass/shrub
  # create prediction 
  pred_glm1_G <- predict_by_response(mod_glmFinal_G, g_test)
  
  ## add predictions together for later figures
  pred_glm1_ALL <- rbind(pred_glm1_WF, pred_glm1_EF, pred_glm1_G)
}

```

### Maps of Residuals
For CONUS-wide model
```{r ResidMap_CONUS, fig.height = 7, fig.width = 8, }

pred_glm1 <- pred_glm1 %>% 
  mutate(resid = .[[response]] - .[[paste0(response,"_pred")]]) 

# rasterize
# get reference raster
test_rast <-  rast("../../../data/dayMet/rawMonthlyData/orders/70e0da02b9d2d6e8faa8c97d211f3546/Daymet_Monthly_V4R1/data/daymet_v4_prcp_monttl_na_1980.tif") %>% 
  terra::aggregate(fact = 32, fun = "mean")

# rasterize data
plotResid_rast <- pred_glm1 %>% 
         drop_na(resid) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Lon", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "resid", 
                   fun = mean) %>% 
  terra::crop(ext(-2000000, 2500000, -2000000, 1200000))
# plot
ggplot() + 
  geom_spatraster(data = plotResid_rast) + 
  ggtitle(paste0("Resids. from Best CONUS wide model of ",s)) + 
  scale_fill_viridis_c(option = "turbo", limits = c(-.55, .91), na.value = "white")

# terra::plot(plotResid_rast, main = paste0("Resids. from Best CONUS wide model of ",s), clip = TRUE, 
#             plg = list(title = "resid."), 
#             col = map.pal("curvature"))
```

If applicable, residual plots of region-level models
```{r, ResidMap_allRegions, fig.height = 7, fig.width = 8, }
if (byRegion == TRUE){
pred_glm1_ALL <- pred_glm1_ALL %>% 
  mutate(resid = .[[response]] - .[[paste0(response,"_pred")]]) 

# rasterize

# rasterize data
plotResid_rast_ALL <- pred_glm1_ALL %>% 
         drop_na(resid) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Lon", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "resid", 
                   fun = mean) %>% 
  terra::crop(ext(-2000000, 2500000, -2000000, 1200000))
# plot
ggplot() + 
  geom_spatraster(data = plotResid_rast_ALL) + 
  ggtitle(paste0("Resids. from regional models of ",s)) + 
  scale_fill_viridis_c(option = "turbo", limits = c(-.55, .91), na.value = "white")
}

```

```{r residMap_byRegion, fig.height = 15, fig.width = 8, }
if (byRegion == TRUE){
## for western forests
  pred_glm1_WF <- pred_glm1_WF %>% 
  mutate(resid = .[[response]] - .[[paste0(response,"_pred")]]) 

# rasterize

# rasterize data
plotResid_rast_WF <- pred_glm1_WF %>% 
         drop_na(resid) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Lon", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "resid", 
                   fun = mean) %>% 
  terra::crop(ext(-2000000, 0, -1500000, 1200000))
westForestRast <- ggplot() + 
  geom_spatraster(data = plotResid_rast_WF) + 
  ggtitle(paste0("Resids. from western forest-wide model of ",s)) + 
  scale_fill_viridis_c(option = "turbo", limits = c(-.55, .91), na.value = "white") 

## for eastern forests
  pred_glm1_EF <- pred_glm1_EF %>% 
  mutate(resid = .[[response]] - .[[paste0(response,"_pred")]]) 

# rasterize data
plotResid_rast_EF <- pred_glm1_EF %>% 
         drop_na(resid) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Lon", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "resid", 
                   fun = mean) %>% 
  terra::crop(ext(0, 2500000, -1700000, 1200000))

EastForestRast <- ggplot() + 
  geom_spatraster(data = plotResid_rast_EF) + 
  ggtitle(paste0("Resids. from eastern forest-wide model of ",s)) + 
  scale_fill_viridis_c(option = "turbo", limits = c(-.55, .91), na.value = "white") 

## for shrub/grassland
  pred_glm1_G <- pred_glm1_G %>% 
  mutate(resid = .[[response]] - .[[paste0(response,"_pred")]]) 

# rasterize data
plotResid_rast_G <- pred_glm1_G %>% 
         drop_na(resid) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Lon", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "resid", 
                   fun = mean) %>% 
  terra::crop(ext(-2000000, 900000, -1900000, 1000000))
grassRast <- ggplot() + 
  geom_spatraster(data = plotResid_rast_G) + 
  ggtitle(paste0("Resids. from eastern grass/shrubland-wide model of ",s)) + 
  scale_fill_viridis_c(option = "turbo", limits = c(-.55, .91), na.value = "white") 

westForestRast / EastForestRast / grassRast
}

```

### Deciles

Binning predictor variables into deciles (actually percentiles) and looking at the mean
predicted probability for each percentile. The use of the word deciles
is just a legacy thing (they started out being actual deciles)

Then predicting on an identical dataset but with warming

```{r}
var_prop_pred <- paste0(response, "_pred")
response_vars <- c(response, var_prop_pred)

pred_glm1_deciles <- predvars2deciles(pred_glm1,
                                      response_vars = response_vars,
                                      pred_vars = pred_vars)

if (byRegion == TRUE) {
  ## western forests
  pred_glm1_deciles_WF <- predvars2deciles(pred_glm1_WF,
                                      response_vars = response_vars,
                                      pred_vars = pred_vars) %>% 
    mutate(newRegion = "westernForest")
  
    ## eastern forests
  pred_glm1_deciles_EF <- predvars2deciles(pred_glm1_EF,
                                      response_vars = response_vars,
                                      pred_vars = pred_vars) %>% 
    mutate(newRegion = "easternForest")
  
    ## grass/shrub
  pred_glm1_deciles_G <- predvars2deciles(pred_glm1_G,
                                      response_vars = response_vars,
                                      pred_vars = pred_vars) %>% 
    mutate(newRegion = "grassShrub")
  
  ## put together for later figures 
  pred_glm1_deciles_ALL <- predvars2deciles(pred_glm1_ALL,
                                      response_vars = response_vars,
                                      pred_vars = pred_vars)
}


```



Publication quality quantile plot

```{r decile_plot, fig.height= 10}

# publication quality version
g3 <- decile_dotplot_pq(pred_glm1_deciles, response = response) + ggtitle("Decile Plot for CONUS-wide model")

if(!hmod) {
# obs/pred inset
g4 <- add_dotplot_inset(g3, pred_glm1_deciles)
} else {
  g4 <- g3
}
if (byRegion == FALSE){
  g4
}

  
if(save_figs) {
  png(paste0("figures/quantile_plots/quantile_plot_v5_CONUS_wideModel_", s,  ".png"), 
     units = "in", res = 600, width = 5.5, height = 3.5 )
    print(g2)
  dev.off()
}
if (byRegion == TRUE) {

  # publication quality version
g <- decile_dotplot_pq(pred_glm1_deciles_ALL, response = response) + ggtitle("Decile Plot for ecoregion-level model")

if(!hmod) {
# obs/pred inset
g2 <- add_dotplot_inset(g, pred_glm1_deciles_ALL)
} else {
  g2 <- g
}

if(save_figs) {
  png(paste0("figures/quantile_plots/quantile_plot_v5_regionLevelModel", s,  ".png"), 
     units = "in", res = 600, width = 5.5, height = 3.5 )
    print(g2)
  dev.off()
}


g4/g2
}

```

### Deciles Filtered 

20th and 80th percentiles for each climate variable

```{r}
df <- pred_glm1[, pred_vars] #%>% 
  #mutate(MAT = MAT - 273.15) # k to c
map(df, quantile, probs = c(0.2, 0.8), na.rm = TRUE)
```


Filtered 'Decile' plots of data. These plots show each vegetation variable,
but only based on data that falls into the upper and lower two deciles of
each climate variable. 


```{r glm_deciles_filtered, fig.height = 10, fig.width = 5, message = FALSE}
clim_vars <- c("swe_meanAnnAvg_30yr", "tmean_meanAnnAvg_30yr", "prcp_meanAnnTotal_30yr", "precip_Seasonality_meanAnnAvg_30yr", "isothermality_meanAnnAvg_30yr", "annWetDegDays_meanAnnAvg_30yr")
pred_glm1_deciles_filt <- predvars2deciles( pred_glm1, 
                         response_vars = response_vars,
                         pred_vars = pred_vars,
                         filter_var = TRUE,
                         filter_vars = pred_vars) 

decile_dotplot_filtered_pq(pred_glm1_deciles_filt, xvars = clim_vars)
#decile_dotplot_filtered_pq(pred_glm1_deciles_filt)

```



Filtered quantile figure with middle 2 deciles also shown
(this is very memory intensive so no running at the moment)

```{r fig.height = 8, fig.width = 5, eval = TRUE}
pred_glm1_deciles_filt_mid <- predvars2deciles(pred_glm1, 
                         response_vars = response_vars,
                         pred_vars = pred_vars,
                         filter_vars = pred_vars,
                         filter_var = TRUE,
                         add_mid = TRUE)

g <- decile_dotplot_filtered_pq(df = pred_glm1_deciles_filt_mid, xvars = pred_vars)
g

if(save_figs) {x
jpeg(paste0("figures/quantile_plots/quantile_plot_filtered_mid_v1", s, ".jpeg"),
     units = "in", res = 600, width = 5.5, height = 6 )
  g 
dev.off()
}
```



# Save output

```{r save_output}
# glm models
mods2save <- butcher::butcher(mod_glmFinal) # removes some model components so the saved object isn't huge

mods2save$formula <- best_form
#mods2save$pred_vars_inter <- pred_vars_inter # so have interactions
n <- nrow(df_sample)
mods2save$data_rows <- n

if (byRegion == TRUE){
  mods2save_WF <- butcher::butcher(mod_glmFinal_WF) # removes some model components so the saved object isn't huge

mods2save_WF$formula <- best_form_WF
#mods2save$pred_vars_inter <- pred_vars_inter # so have interactions
mods2save_WF$data_rows <- nrow(wf_sample)

mods2save_EF <- butcher::butcher(mod_glmFinal_EF) # removes some model components so the saved object isn't huge

mods2save_EF$formula <- best_form_EF
#mods2save$pred_vars_inter <- pred_vars_inter # so have interactions
mods2save_EF$data_rows <- nrow(ef_sample)

  mods2save_G <- butcher::butcher(mod_glmFinal_G) # removes some model components so the saved object isn't huge

mods2save_G$formula <- best_form_G
#mods2save$pred_vars_inter <- pred_vars_inter # so have interactions
mods2save_G$data_rows <- nrow(g_sample)
}

if(!test_run) {
  saveRDS(mods2save, 
        paste0("./models/glm_beta_model_CONUSwide_", s, "_n", n, 
        #sample_group, 
        ".RDS"))
  if (byRegion == TRUE) {
    ## western forests
     saveRDS(mods2save_WF, 
        paste0("./models/glm_beta_model_WesternForests_", s, "_n", n, 
        #sample_group, 
        ".RDS"))
    ## eastern forests
     saveRDS(mods2save_EF, 
        paste0("./models/glm_beta_model_EasternForests_", s, "_n", n, 
        #sample_group, 
        ".RDS"))
     ## grass/shrub
     saveRDS(mods2save_G, 
        paste0("./models/glm_beta_model_GrassShrub_", s, "_n", n, 
        #sample_group, 
        ".RDS"))
  }
}


```

# session info

Hash of current commit (i.e. to ID the version of the code used)

```{r}
system("git rev-parse HEAD", intern=TRUE)
```

Packages etc.

```{r}
sessionInfo()

```