---
title: "Comparing model performance and predicting across CONUS"
author: "Alice Stears"
date: "`r lubridate::today()`"
output:
  html_document:
    toc: true
    toc_float: true
    df_print: paged
    code_folding: hide
params:
  readParams: TRUE
---

We've fit models to multiple different functional groups, and want to compare their performance across different iterations, 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE,
                      message = FALSE)
```
# Dependencies 

User defined parameters

```{r}
print(params)
# set to true if want to run for a limited number of rows (i.e. for code testing)
readParams <- params$readParams
```


```{r warning=FALSE, message=FALSE}
library(tidyverse)
library(sf)
library(terra)
library(kableExtra)
library(knitr)
library(USA.state.boundaries)
library(tidyterra)
library(ggpubr)
```

# Read in data
### use data from dayMet sampled on a grid across CONUS
```{r}
# Load Data ---------------------------------------------------------------
# data ready for modeling (that has been scaled)
modDat_1_s <- readRDS("./models/scaledModelInputData.rds")
  
# get the soil raster, which we'll use for rasterizing the imagery
soilRastTemp <- readRDS("../../../Data_processed/SoilsRaster.rds") %>% 
terra::unwrap()

# make a map of the predictions
test_rast <-  rast("../../../Data_raw/dayMet/rawMonthlyData/orders/70e0da02b9d2d6e8faa8c97d211f3546/Daymet_Monthly_V4R1/data/daymet_v4_prcp_monttl_na_1980.tif") %>% 
  terra::aggregate(fact = 12, fun = "mean")

# download map info for visualization
data(state_boundaries_wgs84) 

cropped_states <- suppressMessages(state_boundaries_wgs84 %>%
  dplyr::filter(NAME!="Hawaii") %>%
  dplyr::filter(NAME!="Alaska") %>%
  dplyr::filter(NAME!="Puerto Rico") %>%
  dplyr::filter(NAME!="American Samoa") %>%
  dplyr::filter(NAME!="Guam") %>%
  dplyr::filter(NAME!="Commonwealth of the Northern Mariana Islands") %>%
  dplyr::filter(NAME!="United States Virgin Islands") %>%
  sf::st_sf() %>%
  sf::st_transform(sf::st_crs(test_rast))) #%>%
  #sf::st_crop(sf::st_bbox(modDat_1_sf)+c(-1,-1,1,1))

## add ecoregion boundaries (for our ecoregion level model)
regions <- sf::st_read(dsn = "../../../Data_raw/Level2Ecoregions/", layer = "NA_CEC_Eco_Level2") 
regions <- regions %>% 
  st_transform(crs = st_crs(test_rast)) %>% 
  st_make_valid() 
ecoregionLU <- data.frame("NA_L1NAME" = sort(unique(regions$NA_L1NAME)), 
                        "newRegion" = c(NA, "Forest", "dryShrubGrass", 
                                        "dryShrubGrass", "Forest", "dryShrubGrass",
                                       "dryShrubGrass", "Forest", "Forest", 
                                       "dryShrubGrass", "Forest", "Forest", 
                                       "Forest", "Forest", "dryShrubGrass", 
                                       NA
                                        ))
goodRegions <- regions %>% 
  left_join(ecoregionLU)
mapRegions <- goodRegions %>% 
  filter(!is.na(newRegion)) %>% 
  group_by(newRegion) %>% 
  summarise(geometry = sf::st_union(geometry)) %>% 
  ungroup() %>% 
  st_simplify(dTolerance = 1000)

```

```{r functions}
## function to get model statements
getModelStatement <- function(coefficientTable, # name of the d.f that has model coefficients
                  modelName, # name of the column in the coefficient table that has the parameters of interest
                  responseVar # name of the response variable
                  ) {
  ##
  # coefficientTable <- grassShrub_totalHerb_trimAnoms
  # modelName <- "coefficientValue_bestLambda"
  # responseVar <- "TotalHerbaceousCover"
  ##
  temp <- coefficientTable[,c("coefficientName", modelName)] %>% 
    drop_na()
  rownames(temp) <- temp$coefficientName
  temp[,modelName] <- round(temp[,modelName], 3)
  
  # print out coefficients w/ coefficient names
tempNames <- paste0(
  apply(temp, MARGIN = 1, FUN = function(x) {
    if (x["coefficientName"] == "(Intercept)") {
      paste0(x[modelName])
    } else {  
      paste0(x[modelName], "*", x["coefficientName"])
    }
    }
  ),
  collapse = " + "
)

# print the unscaled model statement
  unscaledModelName <- paste0(responseVar, "~ exp(", tempNames, ") - 2")
  
  # now add in the scale parameters
tempNames <- str_replace_all(tempNames, pattern = "annWetDegDays_anom", 
                         replacement = paste0("((annWetDegDays_anom - ", 
                                              round(scaleParams$annWetDegDays_anom_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$annWetDegDays_anom_s$`scaled:scale`,4), ")"))

tempNames <- str_replace_all(tempNames, pattern = "prcpTempCorr_anom", 
                         replacement = paste0("((prcpTempCorr_anom - ", 
                                              round(scaleParams$prcpTempCorr_anom_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcpTempCorr_anom_s$`scaled:scale`,4), ")"))


tempNames <- str_replace_all(tempNames, pattern = "prcp_seasonality_anom", 
                         replacement = paste0("((prcp_seasonality_anom - ", 
                                              round(scaleParams$prcp_seasonality_anom_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcp_seasonality_anom_s$`scaled:scale`,4), ") "))

tempNames <- str_replace_all(tempNames, pattern = "annWatDef_anom", 
                         replacement = paste0("((annWatDef_anom - ", 
                                              round(scaleParams$annWatDef_anom_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$annWatDef_anom_s$`scaled:scale`,4), ") "))

tempNames <- str_replace_all(tempNames, pattern = "isothermality_anom", 
                         replacement = paste0("((isothermality_anom - ", 
                                              round(scaleParams$isothermality_anom_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$isothermality_anom_s$`scaled:scale`,4), ") "))

tempNames <- str_replace_all(tempNames, pattern = "prcp_anom", 
                         replacement = paste0("((prcp_anom - ", 
                                              round(scaleParams$prcp_anom_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcp_anom_s$`scaled:scale`,4), ") "))

tempNames <- str_replace_all(tempNames, pattern = "prcp ", 
                         replacement = paste0("((prcp - ", 
                                              round(scaleParams$prcp_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcp_s$`scaled:scale`,4), ") "))

tempNames <- str_replace_all(tempNames, pattern = "prcp\\^", 
                         replacement = paste0("((prcp - ", 
                                              round(scaleParams$prcp_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcp_s$`scaled:scale`,4), ")^"))

tempNames <- str_replace_all(tempNames, pattern = "prcp:", 
                         replacement = paste0("((prcp - ", 
                                              round(scaleParams$prcp_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcp_s$`scaled:scale`,4), "):"))

tempNames <- str_replace_all(tempNames, pattern = "prcpTempCorr ", 
                         replacement = paste0("((prcpTempCorr - ", 
                                              round(scaleParams$prcpTempCorr_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcpTempCorr_s$`scaled:scale`,4), ") "))

tempNames <- str_replace_all(tempNames, pattern = "prcpTempCorr\\^", 
                         replacement = paste0("((prcpTempCorr - ", 
                                              round(scaleParams$prcpTempCorr_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcpTempCorr_s$`scaled:scale`,4), ")^"))

tempNames <- str_replace_all(tempNames, pattern = "prcpTempCorr:", 
                         replacement = paste0("((prcpTempCorr - ", 
                                              round(scaleParams$prcpTempCorr_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcpTempCorr_s$`scaled:scale`,4), "):"))

tempNames <- str_replace_all(tempNames, pattern = "prcpTempCorr\\)", 
                         replacement = paste0("((prcpTempCorr - ", 
                                              round(scaleParams$prcpTempCorr_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcpTempCorr_s$`scaled:scale`,4), "))"))

tempNames <- str_replace_all(tempNames, pattern = "prcpTempCorr$", 
                         replacement = paste0("((prcpTempCorr - ", 
                                              round(scaleParams$prcpTempCorr_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcpTempCorr_s$`scaled:scale`,4), ")"))

tempNames <- str_replace_all(tempNames, pattern = "isothermality ", 
                         replacement = paste0("((isothermality - ", 
                                              round(scaleParams$isothermality_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$isothermality_s$`scaled:scale`,4), ") "))

tempNames <- str_replace_all(tempNames, pattern = "isothermality\\^", 
                         replacement = paste0("((isothermality - ", 
                                              round(scaleParams$isothermality_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$isothermality_s$`scaled:scale`,4), ")^"))

tempNames <- str_replace_all(tempNames, pattern = "isothermality:", 
                         replacement = paste0("((isothermality - ", 
                                              round(scaleParams$isothermality_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$isothermality_s$`scaled:scale`,4), "):"))

tempNames <- str_replace_all(tempNames, pattern = "sand", 
                         replacement = paste0("((sand - ", 
                                              round(scaleParams$sand_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$sand_s$`scaled:scale`,4), ")"))

tempNames <- str_replace_all(tempNames, pattern = "coarse", 
                         replacement = paste0("((coarse - ", 
                                              round(scaleParams$coarse_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$coarse_s$`scaled:scale`,4), ")"))

tempNames <- str_replace_all(tempNames, pattern = "AWHC", 
                         replacement = paste0("((AWHC - ", 
                                              round(scaleParams$AWHC_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$AWHC_s$`scaled:scale`,4), ")"))

tempNames <- str_replace_all(tempNames, pattern = "carbon", 
                         replacement = paste0("((carbon - ", 
                                              round(scaleParams$carbon_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$carbon_s$`scaled:scale`,4), ")"))

tempNames <- str_replace_all(tempNames, pattern = "clay", 
                         replacement = paste0("((clay - ", 
                                              round(scaleParams$clay_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$clay_s$`scaled:scale`,4), ")"))

tempNames <- str_replace_all(tempNames, pattern = "annWatDef ", 
                         replacement = paste0("((annWatDef - ", 
                                              round(scaleParams$annWatDef_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$annWatDef_s$`scaled:scale`,4), ") "))

tempNames <- str_replace_all(tempNames, pattern = "annWatDef:", 
                         replacement = paste0("((annWatDef - ", 
                                              round(scaleParams$annWatDef_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$annWatDef_s$`scaled:scale`,4), "):"))

tempNames <- str_replace_all(tempNames, pattern = "prcp_seasonality ", 
                         replacement = paste0("((prcp_seasonality - ", 
                                              round(scaleParams$prcp_seasonality_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcp_seasonality_s$`scaled:scale`,4), ") "))

tempNames <- str_replace_all(tempNames, pattern = "prcp_seasonality:", 
                         replacement = paste0("((prcp_seasonality - ", 
                                              round(scaleParams$prcp_seasonality_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcp_seasonality_s$`scaled:scale`,4), "):"))

tempNames <- str_replace_all(tempNames, pattern = "prcp_seasonality\\^", 
                         replacement = paste0("((prcp_seasonality - ", 
                                              round(scaleParams$prcp_seasonality_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcp_seasonality_s$`scaled:scale`,4), ")^"))

tempNames <- str_replace_all(tempNames, pattern = "tmean ", 
                         replacement = paste0("((tmean - ", 
                                              round(scaleParams$tmean_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$tmean_s$`scaled:scale`,4), ") "))

tempNames <- str_replace_all(tempNames, pattern = "tmean:", 
                         replacement = paste0("((tmean - ", 
                                              round(scaleParams$tmean_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$tmean_s$`scaled:scale`,4), "):"))

tempNames <- str_replace_all(tempNames, pattern = "tmean$", 
                         replacement = paste0("((tmean - ", 
                                              round(scaleParams$tmean_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$tmean_s$`scaled:scale`,4), ")"))

tempNames <- str_replace_all(tempNames, pattern = "tmean\\^", 
                         replacement = paste0("((tmean - ", 
                                              round(scaleParams$tmean_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$tmean_s$`scaled:scale`,4), ")^"))

tempNames <- str_replace_all(tempNames, pattern = "annWetDegDays ", 
                         replacement = paste0("((annWetDegDays - ", 
                                              round(scaleParams$annWetDegDays_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$annWetDegDays_s$`scaled:scale`,4), ") "))

tempNames <- str_replace_all(tempNames, pattern = "annWetDegDays:", 
                         replacement = paste0("((annWetDegDays - ", 
                                              round(scaleParams$annWetDegDays_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$annWetDegDays_s$`scaled:scale`,4), "):"))

tempNames <- str_replace_all(tempNames, pattern = "prcp_dry ", 
                         replacement = paste0("((prcp_dry - ", 
                                              round(scaleParams$prcp_dry_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcp_dry_s$`scaled:scale`,4), ") "))

tempNames <- str_replace_all(tempNames, pattern = "prcp_dry:", 
                         replacement = paste0("((prcp_dry - ", 
                                              round(scaleParams$prcp_dry_s$`scaled:center`,4), ") / ", 
                                              round(scaleParams$prcp_dry_s$`scaled:scale`,4), "):"))


## print scaled model statement

scaledModelName <- paste0(responseVar, "~ exp(", tempNames, ") - 2")
  
return(list("scaledInputVars_ModelStatement" = unscaledModelName, 
            "unscaledInputVars_scaledModelStatement" = scaledModelName))
}


 ### make predictions
makePredictions <- function(predictionDF, modelObject) {
  ##
  # predictionDF <- climDatPred
  # modelObject <- bestLambdaMod_grassShrub_totalHerb
  # ##
  
  # pretend to scale the input variables so the model object can predict accurately
  predictionDF <- predictionDF %>% 
  mutate(across(all_of(prednames), base::scale,scale = FALSE, center = FALSE)) 
  
  # modelPredictions
  modelPreds <- predict(object = modelObject, newdata = predictionDF, type = "response") - 2
  # add predictions back into the input data.frame
  predictionDF <- predictionDF %>% 
    cbind(modelPreds)
  
  # truncate all predictions to max out at 100 
  predictionDF[predictionDF$modelPreds>100 & !is.na(predictionDF$modelPreds),"modelPreds"] <- 100
predictionDF[predictionDF$modelPreds < 0 & !is.na(predictionDF$modelPreds),"modelPreds"] <- 0

  # print predicted data
 return(predictionDF)
}
```

# Compare model performance
- read in model specifications for each model 
```{r}
filePath <- c("")
# read in model specifications
# no reduction of anomalies 
grassShrub_totalHerb <- readRDS("./models/modelCoefficients_shrubGrass_TotalHerbaceousCover.rds")
grassShrub_totalTree <- readRDS("./models/modelCoefficients_shrubGrass_TotalTreeCover.rds")
#grassShrub_shrub <- readRDS("./models/modelCoefficients_shrubGrass_ShrubCover.rds")
#grassShrub_bareGround <- readRDS("./models/modelCoefficients_shrubGrass_BareGroundCover.rds")
forest_totalHerb <- readRDS("./models/modelCoefficients_forest_TotalHerbaceousCover.rds")
forest_totalTree <- readRDS("./models/modelCoefficients_forest_TotalTreeCover.rds")
#forest_shrub <- readRDS("./models/modelCoefficients_forest_ShrubCover.rds")
#forest_bareGround <- readRDS("./models/modelCoefficients_forest_BareGroundCover.rds")
CONUS_bareGround <- readRDS("./models/modelCoefficients_CONUS_BareGroundCover.rds")
CONUS_shrub <- readRDS("./models/modelCoefficients_CONUS_ShrubCover.rds")

# with reduction of anomalies 
grassShrub_totalHerb_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_shrubGrass_TotalHerbaceousCover.rds")
grassShrub_totalTree_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_shrubGrass_TotalTreeCover.rds")
#grassShrub_shrub_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_shrubGrass_ShrubCover.rds")
#grassShrub_bareGround_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_shrubGrass_BareGroundCover.rds")
forest_totalHerb_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_forest_TotalHerbaceousCover.rds")
forest_totalTree_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_forest_TotalTreeCover.rds")
#forest_shrub_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_forest_ShrubCover.rds")
#forest_bareGround_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_forest_BareGroundCover.rds")
CONUS_bareGround_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_CONUS_BareGroundCover.rds")
CONUS_shrub_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_CONUS_ShrubCover.rds")
CONUS_c3_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_CONUS_C3GramCover_prop.rds")
CONUS_c4_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_CONUS_C4GramCover_prop.rds")
CONUS_forb_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_CONUS_ForbCover_prop.rds")
CONUS_broadLeavedTree_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_CONUS_AngioTreeCover_prop.rds")
CONUS_needleLeavedTree_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_CONUS_ConifTreeCover_prop.rds")

forest_broadLeavedTree_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_forest_AngioTreeCover_prop.rds")
forest_needleLeavedTree_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_forest_ConifTreeCover_prop.rds")
grassShrub_broadLeavedTree_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_shrubGrass_AngioTreeCover_prop.rds")
grassShrub_needleLeavedTree_trimAnoms <- readRDS("./models/modelCoefficients_trimAnom_shrubGrass_ConifTreeCover_prop.rds")

# read in model metrics
# no reduction of anomalies 
modMetrics_grassShrub_totalHerb <- readRDS("./models/modelMetrics_shrubGrass_TotalHerbaceousCover.rds")
modMetrics_grassShrub_totalTree <- readRDS("./models/modelMetrics_shrubGrass_TotalTreeCover.rds")
#modMetrics_grassShrub_shrub <- readRDS("./models/modelMetrics_shrubGrass_ShrubCover.rds")
#modMetrics_grassShrub_bareGround <- readRDS("./models/modelMetrics_shrubGrass_BareGroundCover.rds")
modMetrics_forest_totalHerb <- readRDS("./models/modelMetrics_forest_TotalHerbaceousCover.rds")
modMetrics_forest_totalTree <- readRDS("./models/modelMetrics_forest_TotalTreeCover.rds")
#modMetrics_forest_shrub <- readRDS("./models/modelMetrics_forest_ShrubCover.rds")
#modMetrics_forest_bareGround <- readRDS("./models/modelMetrics_forest_BareGroundCover.rds")
modMetrics_CONUS_bareGround <- readRDS("./models/modelMetrics_CONUS_BareGroundCover.rds")
modMetrics_CONUS_shrub <- readRDS("./models/modelMetrics_CONUS_ShrubCover.rds")

# with reduction of anomalies 
modMetrics_grassShrub_totalHerb_trimAnom <- readRDS("./models/modelMetrics_trimAnom_shrubGrass_TotalHerbaceousCover.rds")
modMetrics_grassShrub_totalTree_trimAnom <- readRDS("./models/modelMetrics_trimAnom_shrubGrass_TotalTreeCover.rds")
#modMetrics_grassShrub_shrub_trimAnom <- readRDS("./models/modelMetrics_trimAnom_shrubGrass_ShrubCover.rds")
#modMetrics_grassShrub_bareGround_trimAnom <- readRDS("./models/modelMetrics_trimAnom_shrubGrass_BareGroundCover.rds")
modMetrics_forest_totalHerb_trimAnom <- readRDS("./models/modelMetrics_trimAnom_forest_TotalHerbaceousCover.rds")
modMetrics_forest_totalTree_trimAnom <- readRDS("./models/modelMetrics_trimAnom_forest_TotalTreeCover.rds")
#modMetrics_forest_shrub_trimAnom <- readRDS("./models/modelMetrics_trimAnom_forest_ShrubCover.rds")
#modMetrics_forest_bareGround_trimAnom <- readRDS("./models/modelMetrics_trimAnom_forest_BareGroundCover.rds")
modMetrics_CONUS_bareGround_trimAnom <- readRDS("./models/modelMetrics_trimAnom_CONUS_BareGroundCover.rds")
modMetrics_CONUS_shrub_trimAnom <- readRDS("./models/modelMetrics_trimAnom_CONUS_ShrubCover.rds")
modMetrics_CONUS_C3_trimAnom <- readRDS("./models/modelMetrics_trimAnom_CONUS_C3GramCover_prop.rds")
modMetrics_CONUS_C4_trimAnom <- readRDS("./models/modelMetrics_trimAnom_CONUS_C4GramCover_prop.rds")
modMetrics_CONUS_forb_trimAnom <- readRDS("./models/modelMetrics_trimAnom_CONUS_ForbCover_prop.rds")
modMetrics_CONUS_broadLeavedTree_trimAnom <- readRDS("./models/modelMetrics_trimAnom_CONUS_AngioTreeCover_prop.rds")
modMetrics_CONUS_needleLeavedTree_trimAnom <- readRDS("./models/modelMetrics_trimAnom_CONUS_ConifTreeCover_prop.rds")
modMetrics_forest_broadLeavedTree_trimAnom <- readRDS("./models/modelMetrics_trimAnom_forest_AngioTreeCover_prop.rds")
modMetrics_forest_needleLeavedTree_trimAnom <- readRDS("./models/modelMetrics_trimAnom_forest_ConifTreeCover_prop.rds")
modMetrics_grassShrub_broadLeavedTree_trimAnom <- readRDS("./models/modelMetrics_trimAnom_shrubGrass_AngioTreeCover_prop.rds")
modMetrics_grassShrub_needleLeavedTree_trimAnom <- readRDS("./models/modelMetrics_trimAnom_shrubGrass_ConifTreeCover_prop.rds")
```
  
Now, show the different model performance metrics for each group (for now, only showing models that remove anomalies whose corresponding weather variables aren't present in the LASSO model)
```{r}
# grass shrub
knitr::kable(format = "html", modMetrics_grassShrub_totalHerb_trimAnom,
             col.names = c("best Lambda model", "1/2 se lambda model", "1 se lambda model"),
              caption = "grass/shrub - Total Herbaceous Cover"
) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

knitr::kable(format = "html", modMetrics_grassShrub_totalTree_trimAnom,
             col.names = c("best Lambda model", "1/2 se lambda model", "1 se lambda model"),
              caption = "grass/shrub - Total Tree Cover"
) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

#forest
knitr::kable(format = "html", modMetrics_forest_totalHerb_trimAnom,
             col.names = c("best Lambda model", "1/2 se lambda model", "1 se lambda model"),
              caption = "forest - Total Herbaceous Cover"
) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

knitr::kable(format = "html", modMetrics_forest_totalTree_trimAnom,
             col.names = c("best Lambda model", "1/2 se lambda model", "1 se lambda model"),
              caption = "forest - Total Tree Cover"
) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

#CONUS

knitr::kable(format = "html", modMetrics_CONUS_shrub_trimAnom,
             col.names = c("best Lambda model", "1/2 se lambda model", "1 se lambda model"),
              caption = "CONUS - shrub cover"
) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

knitr::kable(format = "html", modMetrics_CONUS_bareGround_trimAnom,
             col.names = c("best Lambda model", "1/2 se lambda model", "1 se lambda model"),
              caption = "CONUS - bare ground"
) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))


knitr::kable(format = "html", modMetrics_CONUS_C3_trimAnom,
             col.names = c("best Lambda model", "1/2 se lambda model", "1 se lambda model"),
              caption = "CONUS - proportion of total herb. that is C3 "
) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

knitr::kable(format = "html", modMetrics_CONUS_C4_trimAnom,
             col.names = c("best Lambda model", "1/2 se lambda model", "1 se lambda model"),
              caption = "CONUS - proportion of total herb. that is C4 "
) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

knitr::kable(format = "html", modMetrics_CONUS_forb_trimAnom,
             col.names = c("best Lambda model", "1/2 se lambda model", "1 se lambda model"),
              caption = "CONUS - proportion of total herb. that is forb "
) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

knitr::kable(format = "html", modMetrics_CONUS_broadLeavedTree_trimAnom,
             col.names = c("best Lambda model", "1/2 se lambda model", "1 se lambda model"),
              caption = "CONUS - proportion of total tree that is broad-leaved"
) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

knitr::kable(format = "html", modMetrics_CONUS_needleLeavedTree_trimAnom,
             col.names = c("best Lambda model", "1/2 se lambda model", "1 se lambda model"),
              caption = "CONUS - proportion of total tree that is needle-leaved"
) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```
## First, get the contemporary climate and weather data that we'll use for predictions 
### Get climate data from dayMet for wall-to-wall predictions
```{r}
climDat <- readRDS("/Users/astears/Documents/Dropbox_static/Work/NAU_USGS_postdoc/PED_vegClimModels/Data_processed/EcoRegion_climSoilData.rds")
# rename
climDat <- climDat %>% 
  dplyr::select(tmin_meanAnnAvg_CLIM:durationFrostFreeDays_meanAnnAvg_3yrAnom, NA_L1CODE, 
         NA_L1NAME, NA_L1KEY, newRegion, x, y, soilDepth:totalAvailableWaterHoldingCapacity) %>% 
rename("tmin" = tmin_meanAnnAvg_CLIM, 
     "tmax" = tmax_meanAnnAvg_CLIM, #1 
     "tmean" = tmean_meanAnnAvg_CLIM, 
     "prcp" = prcp_meanAnnTotal_CLIM, 
     "t_warm" = T_warmestMonth_meanAnnAvg_CLIM,
     "t_cold" = T_coldestMonth_meanAnnAvg_CLIM, 
     "prcp_wet" = precip_wettestMonth_meanAnnAvg_CLIM,
     "prcp_dry" = precip_driestMonth_meanAnnAvg_CLIM, 
     "prcp_seasonality" = precip_Seasonality_meanAnnAvg_CLIM, #2
     "prcpTempCorr" = PrecipTempCorr_meanAnnAvg_CLIM,  #3
     "abvFreezingMonth" = aboveFreezing_month_meanAnnAvg_CLIM, 
     "isothermality" = isothermality_meanAnnAvg_CLIM, #4
     "annWatDef" = annWaterDeficit_meanAnnAvg_CLIM, 
     "annWetDegDays" = annWetDegDays_meanAnnAvg_CLIM,
     "VPD_mean" = annVPD_mean_meanAnnAvg_CLIM, 
     "VPD_max" = annVPD_max_meanAnnAvg_CLIM, #5
     "VPD_min" = annVPD_min_meanAnnAvg_CLIM, #6
     "VPD_max_95" = annVPD_max_95percentile_CLIM, 
     "annWatDef_95" = annWaterDeficit_95percentile_CLIM, 
     "annWetDegDays_5" = annWetDegDays_5percentile_CLIM, 
     "frostFreeDays_5" = durationFrostFreeDays_5percentile_CLIM, 
     "frostFreeDays" = durationFrostFreeDays_meanAnnAvg_CLIM, 
     "soilDepth" = soilDepth, #7
     "clay" = surfaceClay_perc, 
     "sand" = avgSandPerc_acrossDepth, #8
     "coarse" = avgCoarsePerc_acrossDepth, #9
     "carbon" = avgOrganicCarbonPerc_0_3cm, #10
     "AWHC" = totalAvailableWaterHoldingCapacity,
     ## anomaly variables
     tmean_anom = tmean_meanAnnAvg_3yrAnom, #15
     tmin_anom = tmin_meanAnnAvg_3yrAnom, #16
     tmax_anom = tmax_meanAnnAvg_3yrAnom, #17
    prcp_anom = prcp_meanAnnTotal_3yrAnom, #18
      t_warm_anom = T_warmestMonth_meanAnnAvg_3yrAnom,  #19
     t_cold_anom = T_coldestMonth_meanAnnAvg_3yrAnom, #20
      prcp_wet_anom = precip_wettestMonth_meanAnnAvg_3yrAnom, #21
      precp_dry_anom = precip_driestMonth_meanAnnAvg_3yrAnom,  #22
    prcp_seasonality_anom = precip_Seasonality_meanAnnAvg_3yrAnom, #23 
     prcpTempCorr_anom = PrecipTempCorr_meanAnnAvg_3yrAnom, #24
      aboveFreezingMonth_anom = aboveFreezing_month_meanAnnAvg_3yrAnom, #25  
    isothermality_anom = isothermality_meanAnnAvg_3yrAnom, #26
       annWatDef_anom = annWaterDeficit_meanAnnAvg_3yrAnom, #27
     annWetDegDays_anom = annWetDegDays_meanAnnAvg_3yrAnom,  #28
      VPD_mean_anom = annVPD_mean_meanAnnAvg_3yrAnom, #29
      VPD_min_anom = annVPD_min_meanAnnAvg_3yrAnom,  #30
      VPD_max_anom = annVPD_max_meanAnnAvg_3yrAnom,  #31
     VPD_max_95_anom = annVPD_max_95percentile_3yrAnom, #32
      annWatDef_95_anom = annWaterDeficit_95percentile_3yrAnom, #33 
      annWetDegDays_5_anom = annWetDegDays_5percentile_3yrAnom ,  #34
    frostFreeDays_5_anom = durationFrostFreeDays_5percentile_3yrAnom, #35 
      frostFreeDays_anom = durationFrostFreeDays_meanAnnAvg_3yrAnom #36
  ) %>% 
  dplyr::select(-c(tmin_meanAnnAvg_3yr:Start_3yr))

```

Get the scaling factors for the data used to fit the models (scaling is done to entire dataset, so only need to get once for all models), and apply those same scaling factors to the data we'll predict with 
```{r fig.width= 12, fig.height = 12}
# get the scaling factors 
scaleParams <- modDat_1_s %>% 
  dplyr::select(tmin_s:AWHC_s) %>% 
  reframe(across(all_of(names(.)), attributes)) 

# apply the scaling factors to the contemporary climate data 
namesToScale <- climDat %>% 
  dplyr::select(tmin:frostFreeDays, tmean_anom:frostFreeDays_anom, soilDepth:AWHC) %>% 
  names()

climDat_scaled <- map(namesToScale, .f = function(x) {
  x_new <- (climDat[,x] - scaleParams[,paste0(x, "_s")]$`scaled:center`)/scaleParams[,paste0(x, "_s")]$`scaled:scale`
  return(data.frame(x_new))
}) %>% 
  purrr::list_cbind()
names(climDat_scaled) <- paste0(namesToScale, "_s")

climDatPred <- climDat %>% 
  dplyr::select(NA_L1CODE:y) %>% 
  cbind(climDat_scaled)
names(climDatPred)[7:56] <- str_remove(names(climDatPred)[7:56], pattern = "_s$")

prednames_s <-  modDat_1_s %>%
  dplyr::select(tmin_s:AWHC_s) %>%
  names()
prednames <- str_replace(prednames_s, pattern = "_s$", replacement = "")


climDat_long <- climDatPred %>% 
  rename_with(.cols = any_of(c(prednames, "tmin", "tmax")), .fn = ~paste0(.x, "_s")) %>% 
  pivot_longer(cols = c(tmin_s:AWHC_s), names_to = "variableName", values_to = "values") %>% 
  mutate(source = "climDat") %>% 
  dplyr::select(x, y, variableName, values, source)
modDat_long <- modDat_1_s %>% 
  pivot_longer(cols = c(tmin_s:AWHC_s), names_to = "variableName", values_to = "values") %>% 
  mutate(source = "modDat") %>% 
  rename(x = x, y = y) %>% 
  dplyr::select(x, y, variableName, values, source)
allDat_long <- climDat_long %>% 
  rbind(modDat_long)

# ggplot(allDat_long)  +
#   facet_wrap(~variableName, scales = "free") +
#   geom_density(aes(values, col = source)) + 
#   ggtitle("A figure to double-check that the climate data used for contemporary predictions is consistent with the data used for fitting")

```

## Download modeled climate data from a given climate model 
### In this iteration, using data from the “BNU-ESM” model (what I call model #1) as the cool/wet(ish) option and the “IPSL-CM5A-MR (France)” (what I call model #1) model as the hot/dry option. For both models, we use data from the end of century w/ RCP 8.5

```{r, eval = FALSE}
# MACA data from:  BNU-ESM model (cool/wet-ish)
## read in tmin data 
tmin_1a <- rast("../../../Data_raw/macaClimateProjections/Data/macav2livneh_tasmin_BNU-ESM_r1i1p1_rcp85_2066_2085_CONUS_monthly.nc") %>% 
  terra::project(y = test_rast) # reproject to match the data used for model fitting
names(tmin_1a) <- terra::time(tmin_1a)

tmin_1b <- rast("../../../Data_raw/macaClimateProjections/Data/macav2livneh_tasmin_BNU-ESM_r1i1p1_rcp85_2086_2099_CONUS_monthly.nc") %>% 
  terra::project(y = test_rast) # reproject to match the data used for model fitting
names(tmin_1b) <- terra::time(tmin_1b)

tmin_1 <- c(tmin_1a, tmin_1b)

# get points to subsample
points <- terra::crds(tmin_1)
pointsSamp <- points[sample(x = 1:nrow(points), size = 50000, replace = FALSE),] %>% 
  terra::vect() %>% 
  terra::set.crs(crs(test_rast))

# subsample tmin_1 points to a data frame
tmin_1Points <- tmin_1 %>% 
  terra::extract(y = pointsSamp, xy = TRUE)
# get month and year data
tmin_1Points_temp <- tmin_1Points %>% 
  #slice_sample(n = 10) %>% 
  pivot_longer(cols = `2066-01-15`:`2099-12-15`, names_to = "date", values_to = "tmin_K") 

tmin_1Points_temp$Year <- as.numeric(str_split(tmin_1Points_temp$date, pattern = "-", simplify = TRUE)[,1])
tmin_1Points_temp$Month <- as.numeric(str_split(tmin_1Points_temp$date, pattern = "-", simplify = TRUE)[,2])

# convert temp in K to degrees C
tmin_1Points_temp$tmin_C <- tmin_1Points_temp$tmin_K - 273.15

# make into a wide format again
tmin_1Points <- tmin_1Points_temp %>% 
  pivot_wider(id_cols = c(x, y, Year), 
              names_from = Month, 
              values_from = tmin_C, 
              names_glue = "tmin_C_{Month}")

## read in tmax data 
tmax_1a <- rast("../../../Data_raw/macaClimateProjections/Data/macav2livneh_tasmax_BNU-ESM_r1i1p1_rcp85_2066_2085_CONUS_monthly.nc") %>% 
  terra::project(y = test_rast) # reproject to match the data used for model fitting
names(tmax_1a) <- terra::time(tmax_1a)

tmax_1b <- rast("../../../Data_raw/macaClimateProjections/Data/macav2livneh_tasmax_BNU-ESM_r1i1p1_rcp85_2086_2099_CONUS_monthly.nc") %>% 
  terra::project(y = test_rast) # reproject to match the data used for model fitting
names(tmax_1b) <- terra::time(tmax_1b)

tmax_1 <- c(tmax_1a, tmax_1b)

# subsample tmax points to a data frame
tmax_1Points <- tmax_1 %>% 
  terra::extract(y = pointsSamp, xy = TRUE)
# get month and year data
tmax_1Points_temp <- tmax_1Points %>% 
  #slice_sample(n = 10) %>% 
  pivot_longer(cols = `2066-01-15`:`2099-12-15`, names_to = "date", values_to = "tmax_K") 

tmax_1Points_temp$Year <- as.numeric(str_split(tmax_1Points_temp$date, pattern = "-", simplify = TRUE)[,1])
tmax_1Points_temp$Month <- as.numeric(str_split(tmax_1Points_temp$date, pattern = "-", simplify = TRUE)[,2])

# convert temp in K to degrees C
tmax_1Points_temp$tmax_C <- tmax_1Points_temp$tmax_K - 273.15

# make into a wide format again
tmax_1Points <- tmax_1Points_temp %>% 
  pivot_wider(id_cols = c(x, y, Year), 
              names_from = Month, 
              values_from = tmax_C, 
              names_glue = "tmax_C_{Month}")

## read in precip data 
prcp_1a <- rast("../../../Data_raw/macaClimateProjections/Data/macav2livneh_pr_BNU-ESM_r1i1p1_rcp85_2066_2085_CONUS_monthly.nc") %>%
  terra::project(y = test_rast) # reproject to match the data used for model fitting
names(prcp_1a) <- terra::time(prcp_1a)
prcp_1b <- rast("../../../Data_raw/macaClimateProjections/Data/macav2livneh_pr_BNU-ESM_r1i1p1_rcp85_2086_2099_CONUS_monthly.nc") %>%
  terra::project(y = test_rast) # reproject to match the data used for model fitting
names(prcp_1b) <- terra::time(prcp_1b)

prcp_1 <- c(prcp_1a, prcp_1b)

# subsample tmax points to a data frame
prcp_1Points <- prcp_1 %>% 
  terra::extract(y = pointsSamp, xy = TRUE)
# get month and year data
prcp_1Points_temp <- prcp_1Points %>% 
  #slice_sample(n = 10) %>% 
  pivot_longer(cols = `2066-01-15`:`2099-12-15`, names_to = "date", values_to = "prcp_mm") 

prcp_1Points_temp$Year <- as.numeric(str_split(prcp_1Points_temp$date, pattern = "-", simplify = TRUE)[,1])
prcp_1Points_temp$Month <- as.numeric(str_split(prcp_1Points_temp$date, pattern = "-", simplify = TRUE)[,2])

# make into a wide format again
prcp_1Points <- prcp_1Points_temp %>% 
  pivot_wider(id_cols = c(x, y, Year), 
              names_from = Month, 
              values_from = prcp_mm, 
              names_glue = "prcp_mm_{Month}")

## add all data frames together
climDat_monthly_1 <- tmin_1Points %>% 
  left_join(tmax_1Points, by = c("x", "y", "Year")) %>% 
  left_join(prcp_1Points, by = c("x", "y", "Year"))

# climDat_monthly_1 %>% 
#   slice_sample(n = 10000) %>% 
# ggplot() + 
#   geom_point(aes(x, y, col = prcp_mm_1))

#/////
# MACA data from:  IPSL-CM5A-MR (France) (warm/dry)
## read in tmin data 
tmin_2a <- rast("../../../Data_raw/macaClimateProjections/Data/macav2livneh_tasmin_IPSL-CM5A-MR_r1i1p1_rcp85_2066_2085_CONUS_monthly.nc") %>% 
  terra::project(y = test_rast) # reproject to match the data used for model fitting
names(tmin_2a) <- terra::time(tmin_2a)

tmin_2b <- rast("../../../Data_raw/macaClimateProjections/Data/macav2livneh_tasmin_IPSL-CM5A-MR_r1i1p1_rcp85_2086_2099_CONUS_monthly.nc") %>% 
  terra::project(y = test_rast) # reproject to match the data used for model fitting
names(tmin_2b) <- terra::time(tmin_2b)

tmin_2 <- c(tmin_2a, tmin_2b)

# get points to subsample
points <- terra::crds(tmin_2)
pointsSamp <- points[sample(x = 1:nrow(points), size = 50000, replace = FALSE),] %>% 
  terra::vect() %>% 
  terra::set.crs(crs(test_rast))

# subsample tmin_2 points to a data frame
tmin_2Points <- tmin_2 %>% 
  terra::extract(y = pointsSamp, xy = TRUE)
# get month and year data
tmin_2Points_temp <- tmin_2Points %>% 
  #slice_sample(n = 10) %>% 
  pivot_longer(cols = `2066-01-15`:`2099-12-15`, names_to = "date", values_to = "tmin_K") 

tmin_2Points_temp$Year <- as.numeric(str_split(tmin_2Points_temp$date, pattern = "-", simplify = TRUE)[,1])
tmin_2Points_temp$Month <- as.numeric(str_split(tmin_2Points_temp$date, pattern = "-", simplify = TRUE)[,2])

# convert temp in K to degrees C
tmin_2Points_temp$tmin_C <- tmin_2Points_temp$tmin_K - 273.15

# make into a wide format again
tmin_2Points <- tmin_2Points_temp %>% 
  pivot_wider(id_cols = c(x, y, Year), 
              names_from = Month, 
              values_from = tmin_C, 
              names_glue = "tmin_C_{Month}")

## read in tmax data 
tmax_2a <- rast("../../../Data_raw/macaClimateProjections/Data/macav2livneh_tasmax_IPSL-CM5A-MR_r1i1p1_rcp85_2066_2085_CONUS_monthly.nc") %>% 
  terra::project(y = test_rast) # reproject to match the data used for model fitting
names(tmax_2a) <- terra::time(tmax_2a)

tmax_2b <- rast("../../../Data_raw/macaClimateProjections/Data/macav2livneh_tasmax_IPSL-CM5A-MR_r1i1p1_rcp85_2086_2099_CONUS_monthly.nc") %>% 
  terra::project(y = test_rast) # reproject to match the data used for model fitting
names(tmax_2b) <- terra::time(tmax_2b)

tmax_2 <- c(tmax_2a, tmax_2b)

# subsample tmax points to a data frame
tmax_2Points <- tmax_2 %>% 
  terra::extract(y = pointsSamp, xy = TRUE)
# get month and year data
tmax_2Points_temp <- tmax_2Points %>% 
  #slice_sample(n = 10) %>% 
  pivot_longer(cols = `2066-01-15`:`2099-12-15`, names_to = "date", values_to = "tmax_K") 

tmax_2Points_temp$Year <- as.numeric(str_split(tmax_2Points_temp$date, pattern = "-", simplify = TRUE)[,1])
tmax_2Points_temp$Month <- as.numeric(str_split(tmax_2Points_temp$date, pattern = "-", simplify = TRUE)[,2])

# convert temp in K to degrees C
tmax_2Points_temp$tmax_C <- tmax_2Points_temp$tmax_K - 273.15

# make into a wide format again
tmax_2Points <- tmax_2Points_temp %>% 
  pivot_wider(id_cols = c(x, y, Year), 
              names_from = Month, 
              values_from = tmax_C, 
              names_glue = "tmax_C_{Month}")

## read in precip data 
prcp_2a <- rast("../../../Data_raw/macaClimateProjections/Data/macav2livneh_pr_IPSL-CM5A-MR_r1i1p1_rcp85_2066_2085_CONUS_monthly.nc") %>%
  terra::project(y = test_rast) # reproject to match the data used for model fitting
names(prcp_2a) <- terra::time(prcp_2a)
prcp_2b <- rast("../../../Data_raw/macaClimateProjections/Data/macav2livneh_pr_IPSL-CM5A-MR_r1i1p1_rcp85_2086_2099_CONUS_monthly.nc") %>%
  terra::project(y = test_rast) # reproject to match the data used for model fitting
names(prcp_2b) <- terra::time(prcp_2b)

prcp_2 <- c(prcp_2a, prcp_2b)

# subsample tmax points to a data frame
prcp_2Points <- prcp_2 %>% 
  terra::extract(y = pointsSamp, xy = TRUE)
# get month and year data
prcp_2Points_temp <- prcp_2Points %>% 
  #slice_sample(n = 10) %>% 
  pivot_longer(cols = `2066-01-15`:`2099-12-15`, names_to = "date", values_to = "prcp_mm") 

prcp_2Points_temp$Year <- as.numeric(str_split(prcp_2Points_temp$date, pattern = "-", simplify = TRUE)[,1])
prcp_2Points_temp$Month <- as.numeric(str_split(prcp_2Points_temp$date, pattern = "-", simplify = TRUE)[,2])

# make into a wide format again
prcp_2Points <- prcp_2Points_temp %>% 
  pivot_wider(id_cols = c(x, y, Year), 
              names_from = Month, 
              values_from = prcp_mm, 
              names_glue = "prcp_mm_{Month}")

## add all data frames together
climDat_monthly_2 <- tmin_2Points %>% 
  left_join(tmax_2Points, by = c("x", "y", "Year")) %>% 
  left_join(prcp_2Points, by = c("x", "y", "Year"))
```

 Calculate climate means and weather anomalies for the first set of climate model data 
```{r, eval = FALSE}
climVar_1 <- climDat_monthly_1 %>% 
  #slice(1:100) %>% 
  mutate(totalAnnPrecip = rowSums(.[c("prcp_mm_1", "prcp_mm_2", "prcp_mm_3", "prcp_mm_4", "prcp_mm_5", "prcp_mm_6", "prcp_mm_7", "prcp_mm_8", "prcp_mm_9", "prcp_mm_10" ,"prcp_mm_11", "prcp_mm_12")]), # total annual precipitation in mm
         T_warmestMonth = pmap_dbl(.[c("tmax_C_1", "tmax_C_2", "tmax_C_3", "tmax_C_4", "tmax_C_5", "tmax_C_6", "tmax_C_7", "tmax_C_8", "tmax_C_9", "tmax_C_10",  "tmax_C_11",  "tmax_C_12")], max), # temperature of warmest month
         T_coldestMonth = pmap_dbl(.[c("tmin_C_1", "tmin_C_2", "tmin_C_3", "tmin_C_4", "tmin_C_5", "tmin_C_6", "tmin_C_7", "tmin_C_8", "tmin_C_9", "tmin_C_10",  "tmin_C_11",  "tmin_C_12")], min), # temperature of coldest month
         Tmin_annAvgOfMonthly = rowSums(.[c("tmin_C_1", "tmin_C_2", "tmin_C_3", "tmin_C_4", "tmin_C_5", "tmin_C_6", "tmin_C_7", "tmin_C_8", "tmin_C_9", "tmin_C_10",  "tmin_C_11",  "tmin_C_12")])/12,
         Tmax_annAvgOfMonthly = rowSums(.[c("tmax_C_1", "tmax_C_2", "tmax_C_3", "tmax_C_4", "tmax_C_5", "tmax_C_6", "tmax_C_7", "tmax_C_8", "tmax_C_9", "tmax_C_10",  "tmax_C_11",  "tmax_C_12")])/12,
         #meanAnnVp = rowMeans(.[28:39]), # annual mean vapor pressure
         precip_wettestMonth = pmap_dbl(.[c("prcp_mm_1", "prcp_mm_2", "prcp_mm_3", "prcp_mm_4", "prcp_mm_5", "prcp_mm_6", "prcp_mm_7", "prcp_mm_8", "prcp_mm_9", "prcp_mm_10" ,"prcp_mm_11", "prcp_mm_12")],
                                        max), # precip of wettest month
         precip_driestMonth = pmap_dbl(.[c("prcp_mm_1", "prcp_mm_2", "prcp_mm_3", "prcp_mm_4", "prcp_mm_5", "prcp_mm_6", "prcp_mm_7", "prcp_mm_8", "prcp_mm_9", "prcp_mm_10" ,"prcp_mm_11", "prcp_mm_12")], 
                                       min), # precip of driest month
         precip_Seasonality = pmap_dbl(.[c("prcp_mm_1", "prcp_mm_2", "prcp_mm_3", "prcp_mm_4", "prcp_mm_5", "prcp_mm_6", "prcp_mm_7", "prcp_mm_8", "prcp_mm_9", "prcp_mm_10" ,"prcp_mm_11", "prcp_mm_12")],   # coefficient of variation (sd/mean) of precipitation
                                       .f = function(prcp_mm_1, prcp_mm_2, prcp_mm_3, prcp_mm_4, prcp_mm_5, prcp_mm_6, prcp_mm_7, prcp_mm_8, prcp_mm_9, prcp_mm_10 ,prcp_mm_11, prcp_mm_12, ...) 
                                       {temp <- c(prcp_mm_1, prcp_mm_2, prcp_mm_3, prcp_mm_4, prcp_mm_5, prcp_mm_6, prcp_mm_7, prcp_mm_8, prcp_mm_9, prcp_mm_10 ,prcp_mm_11, prcp_mm_12)
                                       sd(temp)/mean(temp)
                                       }
         ),
         PrecipTempCorr = pmap_dbl(.[c("tmax_C_1", "tmax_C_2", "tmax_C_3", "tmax_C_4", "tmax_C_5", "tmax_C_6", "tmax_C_7", "tmax_C_8", "tmax_C_9", "tmax_C_10",  "tmax_C_11",  "tmax_C_12",
                                       "prcp_mm_1", "prcp_mm_2", "prcp_mm_3", "prcp_mm_4", "prcp_mm_5", "prcp_mm_6", "prcp_mm_7", "prcp_mm_8", "prcp_mm_9", "prcp_mm_10" ,"prcp_mm_11", "prcp_mm_12")], #correlation of monthly temp and precip
                                   .f = function(tmax_C_1, tmax_C_2, tmax_C_3, tmax_C_4, tmax_C_5, tmax_C_6, tmax_C_7, tmax_C_8, tmax_C_9, tmax_C_10,  tmax_C_11,  tmax_C_12,
                                                 prcp_mm_1, prcp_mm_2, prcp_mm_3, prcp_mm_4, prcp_mm_5, prcp_mm_6, prcp_mm_7, prcp_mm_8, prcp_mm_9, prcp_mm_10 ,prcp_mm_11, prcp_mm_12, ...) {
                                     cor(y = c(tmax_C_1, tmax_C_2, tmax_C_3, tmax_C_4, tmax_C_5, tmax_C_6, tmax_C_7, tmax_C_8, tmax_C_9, tmax_C_10,  tmax_C_11,  tmax_C_12), 
                                         x = c(prcp_mm_1, prcp_mm_2, prcp_mm_3, prcp_mm_4, prcp_mm_5, prcp_mm_6, prcp_mm_7, prcp_mm_8, prcp_mm_9, prcp_mm_10 ,prcp_mm_11, prcp_mm_12))
                                   }),
         aboveFreezing_month = pmap_dbl(.[c("tmin_C_1", "tmin_C_2", "tmin_C_3", "tmin_C_4", "tmin_C_5", "tmin_C_6", "tmin_C_7", "tmin_C_8", "tmin_C_9", "tmin_C_10",  "tmin_C_11",  "tmin_C_12")], # month when temp gets above freezing (when tmin > 0 degrees C, so no freeze at night )
                                        .f = function(tmin_C_1, tmin_C_2, tmin_C_3, tmin_C_4, tmin_C_5, tmin_C_6, tmin_C_7, tmin_C_8, tmin_C_9, tmin_C_10,  tmin_C_11,  tmin_C_12) {
                                          temp <- c(tmin_C_1, tmin_C_2, tmin_C_3, tmin_C_4, tmin_C_5, tmin_C_6, tmin_C_7, tmin_C_8, tmin_C_9, tmin_C_10,  tmin_C_11,  tmin_C_12)
                                          which(temp > 0)[1] # in degrees C
                                        }),
         lastAboveFreezing_month = pmap_dbl(.[c("tmin_C_1", "tmin_C_2", "tmin_C_3", "tmin_C_4", "tmin_C_5", "tmin_C_6", "tmin_C_7", "tmin_C_8", "tmin_C_9", "tmin_C_10",  "tmin_C_11",  "tmin_C_12")], # month when temp gets above freezing (when tmin > 0 degrees C, so no freeze at night )
                                        .f = function(tmin_C_1, tmin_C_2, tmin_C_3, tmin_C_4, tmin_C_5, tmin_C_6, tmin_C_7, tmin_C_8, tmin_C_9, tmin_C_10,  tmin_C_11,  tmin_C_12) {
                                          temp <- c(tmin_C_1, tmin_C_2, tmin_C_3, tmin_C_4, tmin_C_5, tmin_C_6, tmin_C_7, tmin_C_8, tmin_C_9, tmin_C_10,  tmin_C_11,  tmin_C_12)
                                          temp2 <- which(temp > 0) # in degrees C
                                          if(length(temp2)>0) {
                                            return(max(temp2))
                                          } else {
                                              return(NA)
                                            }
                                        }),
         
         isothermality = pmap_dbl(.[c("tmax_C_1", "tmax_C_2", "tmax_C_3", "tmax_C_4", "tmax_C_5", "tmax_C_6", "tmax_C_7", "tmax_C_8", "tmax_C_9", "tmax_C_10",  "tmax_C_11",  "tmax_C_12",
                                      "tmin_C_1", "tmin_C_2", "tmin_C_3", "tmin_C_4", "tmin_C_5", "tmin_C_6", "tmin_C_7", "tmin_C_8", "tmin_C_9", "tmin_C_10",  "tmin_C_11",  "tmin_C_12")], # isothermality
                                  .f = function(tmax_C_1, tmax_C_2, tmax_C_3, tmax_C_4, tmax_C_5, tmax_C_6, tmax_C_7, tmax_C_8, tmax_C_9, tmax_C_10,  tmax_C_11,  tmax_C_12,
                                                tmin_C_1, tmin_C_2, tmin_C_3, tmin_C_4, tmin_C_5, tmin_C_6, tmin_C_7, tmin_C_8, tmin_C_9, tmin_C_10,  tmin_C_11,  tmin_C_12, ...) {
                                    tmins <- c(tmin_C_1, tmin_C_2, tmin_C_3, tmin_C_4, tmin_C_5, tmin_C_6, tmin_C_7, tmin_C_8, tmin_C_9, tmin_C_10,  tmin_C_11,  tmin_C_12)
                                    tmaxes <- c(tmax_C_1, tmax_C_2, tmax_C_3, tmax_C_4, tmax_C_5, tmax_C_6, tmax_C_7, tmax_C_8, tmax_C_9, tmax_C_10,  tmax_C_11,  tmax_C_12)
                                    tMaxMax <- max(c(tmax_C_1, tmax_C_2, tmax_C_3, tmax_C_4, tmax_C_5, tmax_C_6, tmax_C_7, tmax_C_8, tmax_C_9, tmax_C_10,  tmax_C_11,  tmax_C_12))
                                    tMinMin <- min(c(tmin_C_1, tmin_C_2, tmin_C_3, tmin_C_4, tmin_C_5, tmin_C_6, tmin_C_7, tmin_C_8, tmin_C_9, tmin_C_10,  tmin_C_11,  tmin_C_12))
                                    mean(tmaxes-tmins)/(tMaxMax-tMinMin) * 100
                                  }),
         
  ) %>% 
  mutate(
    # calculate the duration of frost-free days (in our case here, Frost-free
    # days = (doy of first day of the first month when tmin is >0) - (doy of
    # last day of the lost month when tmin >0))
    # first month when tmin is above freezing is "aboveFreezing_month" in the previous d.f.
    # last month when tmin is above freezing is "lastAboveFreezing_month" in the previous d.f.
    durationFrostFreeDays = 
      # DOY of last day of last frost-free month (just give the 30th, since it
      # probably isn't a bit deal if we use the 30th rather than the 31st in
      # months when there is a 31st)
      lubridate::yday(as.Date(paste0(lastAboveFreezing_month, "/30/2024"), 
                              format = "%m/%d/%Y")) - 
      # DOY of first day of first frost-free month
      lubridate::yday(as.Date(paste0("0",aboveFreezing_month, "/01/2024"), 
                                                    format = "%m/%d/%Y"))
    )

# constants for SVP calculation 
#calculate SVP according to Williams et al NatCC 2012 supplementary material -  units haPa
a0<-6.107799961
a1<-0.4436518521
a2<-0.01428945805
a3<-0.0002650648471
a4<-0.000003031240396
a5<-0.00000002034080948
a6<-0.00000000006136820929
## calculating vapor pressure deficit, annual water deficit, and wet degree days (based on code from Adam Noel)

climVar2_1 <- climDat_monthly_1 %>% 
  #slice(23507:23509) %>% 
  # approximation of mean temp (just avg. of max and min, which I realize is not totally accurate)
  mutate(tmean_Jan = (tmax_C_1 + tmin_C_1)/2,
         tmean_Feb = (tmax_C_2 + tmin_C_2)/2,
         tmean_March = (tmax_C_3 + tmin_C_3)/2,
         tmean_April = (tmax_C_4 + tmin_C_4)/2,
         tmean_May = (tmax_C_5 + tmin_C_5)/2,
         tmean_June = (tmax_C_6 + tmin_C_6)/2,
         tmean_July = (tmax_C_7 + tmin_C_7)/2,
         tmean_Aug = (tmax_C_8 + tmin_C_8)/2,
         tmean_Sept = (tmax_C_9 + tmin_C_9)/2,
         tmean_Oct = (tmax_C_10 + tmin_C_10)/2,
         tmean_Nov = (tmax_C_11 + tmin_C_11)/2,
         tmean_Dec = (tmax_C_12 + tmin_C_12)/2,
  ) %>% 
  mutate(
    # monthly water deficit 
    awd_Jan = tmean_Jan*2 - prcp_mm_1,
    awd_Feb = tmean_Feb*2 - prcp_mm_2,
    awd_March = tmean_March*2 - prcp_mm_3,
    awd_April = tmean_April*2 - prcp_mm_4,
    awd_May = tmean_May*2 - prcp_mm_5,
    awd_June = tmean_June*2 - prcp_mm_6, 
    awd_July = tmean_July*2 - prcp_mm_7,
    awd_Aug = tmean_Aug*2 - prcp_mm_8, 
    awd_Sept = tmean_Sept*2 - prcp_mm_9, 
    awd_Oct = tmean_Oct*2 - prcp_mm_10,   
    awd_Nov = tmean_Nov*2 - prcp_mm_11,   
    awd_Dec = tmean_Dec*2 - prcp_mm_12,   
    # monthly wet degree days
    ##aes 
    awdd_Jan =  ifelse(tmean_Jan*2 < prcp_mm_1, tmean_Jan*30, NA),
    awdd_Feb =  ifelse(tmean_Feb*2 < prcp_mm_2, tmean_Feb*30, NA),
    awdd_March =   ifelse(tmean_March*2 < prcp_mm_3, tmean_March*30, NA),
    awdd_April =  ifelse(tmean_April*2 < prcp_mm_4, tmean_April*30, NA),
    awdd_May = ifelse(tmean_May*2 < prcp_mm_5, tmean_May*30, NA),
    awdd_June = ifelse(tmean_June*2 < prcp_mm_6, tmean_June*30, NA),
    awdd_July = ifelse(tmean_July*2 < prcp_mm_7, tmean_July*30, NA), 
    awdd_Aug = ifelse(tmean_Aug*2 < prcp_mm_8, tmean_Aug*30, NA),
    awdd_Sept = ifelse(tmean_Sept*2 < prcp_mm_9, tmean_Sept*30, NA),
    awdd_Oct = ifelse(tmean_Oct*2 < prcp_mm_10, tmean_Oct*30, NA),
    awdd_Nov = ifelse(tmean_Nov*2 < prcp_mm_11, tmean_Nov*30, NA),
    awdd_Dec = ifelse(tmean_Dec*2 < prcp_mm_12, tmean_Dec*30, NA),
   
    # units are Pascals 
    VPD_Jan = ((( a0+ tmean_Jan*(a1+ tmean_Jan *(a2+ tmean_Jan *(a3+ tmean_Jan *(a4	+ tmean_Jan *(a5	+ tmean_Jan *a6)))))))*100 -  (tmean_Jan))/1000,
    VPD_Feb = ((( a0+ tmean_Feb*(a1+ tmean_Feb *(a2+ tmean_Feb *(a3+ tmean_Feb *(a4	+ tmean_Feb *(a5	+ tmean_Feb *a6)))))))*100 -  (tmean_Feb))/1000,
    VPD_March = ((( a0+ tmean_March*(a1+ tmean_March *(a2+ tmean_March *(a3+ tmean_March *(a4	+ tmean_March *(a5	+ tmean_March *a6)))))))*100 -  (tmean_March))/1000,
    VPD_April = ((( a0+ tmean_April*(a1+ tmean_April *(a2+ tmean_April *(a3+ tmean_April *(a4	+ tmean_April *(a5	+ tmean_April *a6)))))))*100 -  (tmean_April))/1000,
    VPD_May =   ((( a0+ tmean_May*(a1+ tmean_May *(a2+ tmean_May *(a3+ tmean_May *(a4	+ tmean_May *(a5	+ tmean_May *a6)))))))*100 -  (tmean_May))/1000,
    VPD_June =  ((( a0+ tmean_June*(a1+ tmean_June *(a2+ tmean_June *(a3+ tmean_June *(a4	+ tmean_June *(a5	+ tmean_June *a6)))))))*100 -  (tmean_June))/1000,
    VPD_July =  ((( a0+ tmean_July*(a1+ tmean_July *(a2+ tmean_July *(a3+ tmean_July *(a4	+ tmean_July *(a5	+ tmean_July *a6)))))))*100 -  (tmean_July))/1000,
    VPD_Aug =   ((( a0+ tmean_Aug*(a1+ tmean_Aug *(a2+ tmean_Aug *(a3+ tmean_Aug *(a4	+ tmean_Aug *(a5	+ tmean_Aug *a6)))))))*100 -  (tmean_Aug))/1000,
    VPD_Sept =  ((( a0+ tmean_Sept*(a1+ tmean_Sept *(a2+ tmean_Sept *(a3+ tmean_Sept *(a4	+ tmean_Sept *(a5	+ tmean_Sept *a6)))))))*100 -  (tmean_Sept))/1000,
    VPD_Oct =   ((( a0+ tmean_Oct*(a1+ tmean_Oct *(a2+ tmean_Oct *(a3+ tmean_Oct *(a4	+ tmean_Oct *(a5	+ tmean_Oct *a6)))))))*100 -  (tmean_Oct))/1000,
    VPD_Nov =   ((( a0+ tmean_Nov*(a1+ tmean_Nov *(a2+ tmean_Nov *(a3+ tmean_Nov *(a4	+ tmean_Nov *(a5	+ tmean_Nov *a6)))))))*100 -  (tmean_Nov))/1000,
    VPD_Dec =   ((( a0+ tmean_Dec*(a1+ tmean_Dec *(a2+ tmean_Dec *(a3+ tmean_Dec *(a4	+ tmean_Dec *(a5	+ tmean_Dec *a6)))))))*100 -  (tmean_Dec))/1000
    ) %>% 
  #calculate annual values
  transmute(#keep = c("year", "Long", "Lat"),
  #mutate(
    # annual water deficit (mm of water over degrees celsius)(sum across all months?)
    tmean = pmap_dbl(.[c("tmean_Jan", "tmean_Feb", "tmean_March", "tmean_April", "tmean_May", "tmean_June", "tmean_July", "tmean_Aug", "tmean_Sept", "tmean_Oct" ,"tmean_Nov", "tmean_Dec")],
                       .f = function(tmean_Jan, tmean_Feb, tmean_March, tmean_April, tmean_May, tmean_June, tmean_July, tmean_Aug, tmean_Sept, tmean_Oct ,tmean_Nov, tmean_Dec, ...) {
                         temp <- sum(tmean_Jan, tmean_Feb, tmean_March, tmean_April, tmean_May, tmean_June, tmean_July, tmean_Aug, tmean_Sept, tmean_Oct ,tmean_Nov, tmean_Dec)/12
                         return(temp)
                       }),
    
    # annual water deficit (mm of water over degrees celsius)(sum across all months?)
    annWaterDeficit = pmap_dbl(.[c("awd_Jan", "awd_Feb", "awd_March", "awd_April", "awd_May", "awd_June", "awd_July", "awd_Aug", "awd_Sept", "awd_Oct" ,"awd_Nov", "awd_Dec")], 
                               .f = function(awd_Jan, awd_Feb, awd_March, awd_April, awd_May, awd_June, awd_July, awd_Aug, awd_Sept, awd_Oct ,awd_Nov, awd_Dec, ...){
                                 temp <- c(awd_Jan, awd_Feb, awd_March, awd_April, awd_May, awd_June, awd_July, awd_Aug, awd_Sept, awd_Oct ,awd_Nov, awd_Dec)
                                 sum(temp[temp>0])
                               }
    ),
    # annual wet degree days (temp*days) (sum only positive values)
    annWetDegDays = pmap_dbl(.[c("awdd_Jan", "awdd_Feb", "awdd_March", "awdd_April", "awdd_May", "awdd_June", "awdd_July", "awdd_Aug", "awdd_Sept", "awdd_Oct" ,"awdd_Nov", "awdd_Dec")],
                             .f = function(awdd_Jan, awdd_Feb, awdd_March, awdd_April, awdd_May, awdd_June, awdd_July, awdd_Aug, awdd_Sept, awdd_Oct ,awdd_Nov, awdd_Dec, ...) 
                             {
                               temp <- c(awdd_Jan, awdd_Feb, awdd_March, awdd_April, awdd_May, awdd_June, awdd_July, awdd_Aug, awdd_Sept, awdd_Oct ,awdd_Nov, awdd_Dec)
                               sum(temp[temp>0], na.rm = TRUE)
                             }
    ),
    # annual average vapor pressure deficit (in milibars) ()
    annVPD_mean = pmap_dbl(.[c("VPD_Jan", "VPD_Feb", "VPD_March","VPD_April" ,"VPD_May","VPD_June", "VPD_July","VPD_Aug","VPD_Sept","VPD_Oct","VPD_Nov","VPD_Dec")], 
                           .f = function(VPD_Jan, VPD_Feb, VPD_March,VPD_April ,VPD_May,VPD_June, VPD_July,VPD_Aug,VPD_Sept,VPD_Oct,VPD_Nov,VPD_Dec) {
      mean(VPD_Jan, VPD_Feb, VPD_March,VPD_April ,VPD_May,VPD_June, VPD_July,VPD_Aug,VPD_Sept,VPD_Oct,VPD_Nov,VPD_Dec)
    }),
    # annual maximum vapor pressure deficit (in milibars) 
    annVPD_max = pmap_dbl(.[c("VPD_Jan", "VPD_Feb", "VPD_March","VPD_April" ,"VPD_May","VPD_June", "VPD_July","VPD_Aug","VPD_Sept","VPD_Oct","VPD_Nov","VPD_Dec")], max),
    # annual minimum vapor pressure deficit (in milibars) 
    annVPD_min = pmap_dbl(.[c("VPD_Jan", "VPD_Feb", "VPD_March","VPD_April" ,"VPD_May","VPD_June", "VPD_July","VPD_Aug","VPD_Sept","VPD_Oct","VPD_Nov","VPD_Dec")], min)
  )


# if duration of frost free days is NA, change to 0 (high elevation points where there aren't any days >0 degrees C)
climVar_1[is.na(climVar_1[,"durationFrostFreeDays"]),"durationFrostFreeDays"] <- 0
# if first month where tmin is above freezing is NA, change to 8 
climVar_1[is.na(climVar_1[,"aboveFreezing_month"]), "aboveFreezing_month"] <- 8

climVar_1 <- cbind(climVar_1, climVar2_1)

rm(climVar2_1)
gc()

## calculate MAP and MAT over past years (a sliding window?)
# function
slidingMetMeans <- function(inDat, start, end) {
  endActual <- end-1 # subtract one so that we're actually looking at the 30, 10, 5, etc. years previous to the "end" year
  outDat <- inDat %>% 
    filter(Year %in% c(start:endActual)) %>% 
    group_by(x, y) %>% 
    summarize(#sweMax_meanAnnAvg = mean(swe_annAvg),
              tmin_meanAnnAvg = mean(Tmin_annAvgOfMonthly),
              tmax_meanAnnAvg = mean(Tmax_annAvgOfMonthly),
              tmean_meanAnnAvg = mean(tmean),
              #vp_meanAnnAvg = mean(vp_annAvg),
              prcp_meanAnnTotal = mean(totalAnnPrecip),
              T_warmestMonth_meanAnnAvg = mean(T_warmestMonth), # temperature of warmest month
              T_coldestMonth_meanAnnAvg = mean(T_coldestMonth), # temperature of coldest month
              precip_wettestMonth_meanAnnAvg = mean(precip_wettestMonth), # precip of wettest month
              precip_driestMonth_meanAnnAvg = mean(precip_driestMonth), # precip of driest month
              precip_Seasonality_meanAnnAvg = mean(precip_Seasonality),
              PrecipTempCorr_meanAnnAvg = mean(PrecipTempCorr),
              aboveFreezing_month_meanAnnAvg = mean(aboveFreezing_month),
              isothermality_meanAnnAvg = mean(isothermality),
              annWaterDeficit_meanAnnAvg = mean(annWaterDeficit),
              annWetDegDays_meanAnnAvg = mean(annWetDegDays),
              annVPD_mean_meanAnnAvg = mean(annVPD_mean),
              annVPD_max_meanAnnAvg = mean(annVPD_max),
              annVPD_min_meanAnnAvg = mean(annVPD_min),
              annVPD_max_95percentile = unname(quantile(annVPD_max, probs = 0.95, na.rm = TRUE)),
              annWaterDeficit_95percentile = unname(quantile(annWaterDeficit, probs = 0.95, na.rm = TRUE)),
              annWetDegDays_5percentile = unname(quantile(annWetDegDays, probs = 0.05, na.rm = TRUE)),
              durationFrostFreeDays_5percentile = unname(quantile(durationFrostFreeDays, probs = 0.05, na.rm = TRUE)),
              durationFrostFreeDays_meanAnnAvg = unname(mean(durationFrostFreeDays))
    )
  return(outDat)
}


# climVar_1 %>% 
#   slice_sample(n = 100000) %>% 
#   ggplot() + 
#   geom_point(aes(x, y, col = totalAnnPrecip))

# for last 20-year window, which is fewer than the 30 we used in the model-fitting... but I'd have to download even more MACA data, which I don't want to do right now...
annMeans_30yrs <- slidingMetMeans(inDat = climVar_1,
                            start = as.numeric(2099-30), end = 2099)

names(annMeans_30yrs)[3:24] <- paste0(names(annMeans_30yrs)[3:24], "_CLIM")
annMeans_30yrs$End_CLIM <- 2099


# annMeans_30yrs %>%
#   #filter(precip_driestMonth_meanAnnAvg_CLIM < 50) %>% 
#   #slice_sample(n = 100000) %>%
#   ggplot() +
#   geom_point(aes(x, y, col = .data[[names(annMeans_30yrs)[12]]]))



# for last 3-year window
annMeans_3yrs <- slidingMetMeans(inDat = climVar_1,
                                 start = as.numeric(2099-3), end = 2099)

names(annMeans_3yrs)[3:24] <- paste0(names(annMeans_3yrs)[3:24], "_3yr")
annMeans_3yrs$End_3yr <- 2099
## add lagged data to the main climate value data.frame
test <- climVar_1 %>% 
  dplyr::select(-c(tmin_C_1:prcp_mm_12)) %>% 
  filter(Year == 2099) %>% 
  #filter(year == 2020) %>% 
  #slice(1:100) %>% 
  left_join(annMeans_30yrs, by = c("Year" = "End_CLIM", 
                                  "x" = "x", 
                                  "y" = "y")) %>% 
  left_join(annMeans_3yrs, by = c("Year" = "End_3yr", 
                                  "x" = "x", 
                                  "y" = "y")
  )

rm(annMeans_30yrs, annMeans_3yrs)
gc()

test$Start_CLIM <- 2099-30

# save intermediate data 
saveRDS(test, "../../../Data_processed/CoverData/IntermediateAnalysisFiles/ForecastedClimateDataForPredictions_BNU-ESM_rcp8_5.rds")
test <- readRDS("../../../Data_processed/CoverData/IntermediateAnalysisFiles/ForecastedClimateDataForPredictions_BNU-ESM_rcp8_5.rds")
rm(climVar_1)
gc()

#### calculate anomalies ####
# i.e. how do the 3 yr. lagged values compare to the 20yr lagged values?

anomDat_3yr <- test %>% 
  transmute(
    # compare 3 yr values to 20 yr values
    # tmean as absolute difference
    tmean_meanAnnAvg_3yrAnom = tmean_meanAnnAvg_CLIM - tmean_meanAnnAvg_3yr,
    # tmin as absolute difference
    tmin_meanAnnAvg_3yrAnom = tmin_meanAnnAvg_CLIM - tmin_meanAnnAvg_3yr,
    # tmax as absolute difference
    tmax_meanAnnAvg_3yrAnom = tmax_meanAnnAvg_CLIM - tmax_meanAnnAvg_3yr,
    # vp as % difference
    #vp_meanAnnAvg_3yrAnom = (vp_meanAnnAvg_CLIM - vp_meanAnnAvg_3yr)/vp_meanAnnAvg_CLIM,
    # prcp as % difference
    prcp_meanAnnTotal_3yrAnom = (prcp_meanAnnTotal_CLIM - prcp_meanAnnTotal_3yr)/prcp_meanAnnTotal_CLIM,
    # t warmest month as absolute difference
    T_warmestMonth_meanAnnAvg_3yrAnom = T_warmestMonth_meanAnnAvg_CLIM - T_warmestMonth_meanAnnAvg_3yr,
    # t coldest month as absolute difference
    T_coldestMonth_meanAnnAvg_3yrAnom = T_coldestMonth_meanAnnAvg_CLIM - T_coldestMonth_meanAnnAvg_3yr,
    # precip wettest month as % difference
    precip_wettestMonth_meanAnnAvg_3yrAnom = (precip_wettestMonth_meanAnnAvg_CLIM - precip_wettestMonth_meanAnnAvg_3yr)/precip_wettestMonth_meanAnnAvg_CLIM,
    # precip driest month as % difference
    precip_driestMonth_meanAnnAvg_3yrAnom = (precip_driestMonth_meanAnnAvg_CLIM - precip_driestMonth_meanAnnAvg_3yr)/precip_driestMonth_meanAnnAvg_CLIM,
    # precip seasonality as % difference
    precip_Seasonality_meanAnnAvg_3yrAnom = (precip_Seasonality_meanAnnAvg_CLIM - precip_Seasonality_meanAnnAvg_3yr)/precip_Seasonality_meanAnnAvg_CLIM,
    # precip tempCorr as absolute difference
    PrecipTempCorr_meanAnnAvg_3yrAnom = PrecipTempCorr_meanAnnAvg_CLIM - PrecipTempCorr_meanAnnAvg_3yr,
    # above Freezing month as absolute difference
    aboveFreezing_month_meanAnnAvg_3yrAnom = aboveFreezing_month_meanAnnAvg_CLIM - aboveFreezing_month_meanAnnAvg_3yr,
    # isothermailty as % difference
    isothermality_meanAnnAvg_3yrAnom = isothermality_meanAnnAvg_CLIM - isothermality_meanAnnAvg_3yr,    
    # annual water deficit as % difference
    annWaterDeficit_meanAnnAvg_3yrAnom = ((annWaterDeficit_meanAnnAvg_CLIM+.0001) - annWaterDeficit_meanAnnAvg_3yr)/(annWaterDeficit_meanAnnAvg_CLIM+.0001),
    # wet degree days as % difference
    annWetDegDays_meanAnnAvg_3yrAnom = (annWetDegDays_meanAnnAvg_CLIM - annWetDegDays_meanAnnAvg_3yr)/annWetDegDays_meanAnnAvg_CLIM,
    # mean VPD as absolute difference
    annVPD_mean_meanAnnAvg_3yrAnom = (annVPD_mean_meanAnnAvg_CLIM - annVPD_mean_meanAnnAvg_3yr),
    # min VPD as absolute difference
    annVPD_min_meanAnnAvg_3yrAnom = (annVPD_min_meanAnnAvg_CLIM - annVPD_min_meanAnnAvg_3yr),
    # max VPD as absolute difference
    annVPD_max_meanAnnAvg_3yrAnom = (annVPD_max_meanAnnAvg_CLIM - annVPD_max_meanAnnAvg_3yr),
    # 95th percentile of max VPD as absolute difference 
    annVPD_max_95percentile_3yrAnom = (annVPD_max_95percentile_CLIM - annVPD_max_95percentile_3yr),
    # 95th percentile of annual water deficit as % difference
    annWaterDeficit_95percentile_3yrAnom = ((annWaterDeficit_95percentile_CLIM + .0001) - annWaterDeficit_95percentile_3yr)/(annWaterDeficit_95percentile_CLIM + .0001),
    # 5th percentile of annual wet degree days as % difference 
    annWetDegDays_5percentile_3yrAnom = ((annWetDegDays_5percentile_CLIM + .0001) - annWetDegDays_5percentile_3yr)/(annWetDegDays_5percentile_CLIM + .0001),
    # 5th percentile of frost-free days as absolute difference 
    durationFrostFreeDays_5percentile_3yrAnom = (durationFrostFreeDays_5percentile_CLIM - durationFrostFreeDays_5percentile_3yr),
    # mean of frost free days as absolute difference
    durationFrostFreeDays_meanAnnAvg_3yrAnom = (durationFrostFreeDays_meanAnnAvg_CLIM - durationFrostFreeDays_meanAnnAvg_3yr)
  )

climDat <- cbind(test, 
                 anomDat_3yr
) 

## add soils information 
# this dataset is from Daniel Schlaepfer, who provided the following information:
# They are based on SOLUS100 data by Travis Nauman et al.
# Data: https://agdatacommons.nal.usda.gov/articles/dataset/Data_from_Soil_Landscapes_of_the_United_States_100-meter_SOLUS100_soil_property_maps_project_repository/25033856
# Article: in revision
# 
# Attached files were calculated from the original 100-m at specific point depths with the following parameters:
#   * aggregation 100-m to 4-km grid: average
# * soil layers: 0-3, 10, 20, 30, 40, 60, 80, 100, 150, 201 cm
# * soil depth: resdept (i.e., bedrock)
# * deepest layer:
#   if (resdept >= 5 cm next shallow standard layer depth) then new layer
# * conversion point depths to soil layers: trapezoidal rule
# * extrapolation from 150-cm point depth to deeper layers: 150-cm values
# read in the file
  soilRast <- readRDS("../../../Data_processed/SoilsRaster.rds") 

  crs(soilRast) == crs(test_rast)
# sample soils data for veg. points ---------------------------------------
# sample raster to get values for the points in the cover dataset

soils_df <- soilRast %>% 
  terra::extract(y = pointsSamp #%>% dplyr::dplyr::select(-x,-y)
                 , xy = TRUE, bind = TRUE) %>% 
  as.data.frame()

# ggplot() + 
#   geom_point(data = climDat, aes(x,y)) + 
#   geom_point(data = soils_df, aes(x, y))
# calculate soils variables w/ cover data ---------------------------------
  soils_new <- 
    soils_df %>% 
    dplyr::mutate(
      # Soil depth 
      soilDepth = pmap_dbl(.[c("horizonThickness_cm_2cm" , "horizonThickness_cm_7cm" , "horizonThickness_cm_15cm" , 
                               "horizonThickness_cm_25cm" , "horizonThickness_cm_35cm" , "horizonThickness_cm_50cm" , 
                               "horizonThickness_cm_70cm" , "horizonThickness_cm_90cm" , "horizonThickness_cm_125cm" , 
                               "horizonThickness_cm_176cm")], sum, na.rm = TRUE),
      #Surface clay (influences how much moisture can get into the profile)
      surfaceClay_perc = clayPerc_2cm) %>% 
    mutate(soilDepth = replace(soilDepth, is.na(horizonThickness_cm_2cm), values = NA)) %>% 
    mutate( 
      # Sand average across depths (avg. weighted by width of layer)
      avgSandPerc_acrossDepth = pmap_dbl(.[c("horizonThickness_cm_2cm" , "horizonThickness_cm_7cm" ,
                                             "horizonThickness_cm_15cm" , "horizonThickness_cm_25cm" ,
                                             "horizonThickness_cm_35cm" , "horizonThickness_cm_50cm" , 
                                             "horizonThickness_cm_70cm" , "horizonThickness_cm_90cm" ,
                                             "horizonThickness_cm_125cm" , "horizonThickness_cm_176cm", 
                                             "sandPerc_2cm", "sandPerc_7cm" , "sandPerc_15cm",
                                             "sandPerc_25cm" , "sandPerc_35cm", "sandPerc_50cm" , 
                                             "sandPerc_70cm", "sandPerc_90cm" ,
                                             "sandPerc_125cm", "sandPerc_176cm", "soilDepth")], 
                                         function(horizonThickness_cm_2cm , horizonThickness_cm_7cm ,
                                                  horizonThickness_cm_15cm ,  horizonThickness_cm_25cm ,
                                                  horizonThickness_cm_35cm , horizonThickness_cm_50cm , 
                                                  horizonThickness_cm_70cm , horizonThickness_cm_90cm ,
                                                  horizonThickness_cm_125cm ,  horizonThickness_cm_176cm, 
                                                  sandPerc_2cm, sandPerc_7cm , sandPerc_15cm,
                                                  sandPerc_25cm , sandPerc_35cm, sandPerc_50cm , 
                                                  sandPerc_70cm, sandPerc_90cm ,
                                                  sandPerc_125cm,sandPerc_176cm, soilDepth) {
                                           y <- sum(c(sandPerc_2cm *  horizonThickness_cm_2cm/soilDepth, 
                                                      sandPerc_7cm *    horizonThickness_cm_7cm/soilDepth, 
                                                      sandPerc_15cm *   horizonThickness_cm_15cm/soilDepth, 
                                                      sandPerc_25cm *   horizonThickness_cm_25cm/soilDepth, 
                                                      sandPerc_35cm *   horizonThickness_cm_35cm/soilDepth, 
                                                      sandPerc_50cm *   horizonThickness_cm_50cm/soilDepth, 
                                                      sandPerc_70cm *   horizonThickness_cm_70cm/soilDepth, 
                                                      sandPerc_90cm *   horizonThickness_cm_90cm/soilDepth, 
                                                      sandPerc_125cm *  horizonThickness_cm_125cm/soilDepth, 
                                                      sandPerc_176cm *  horizonThickness_cm_176cm/soilDepth), 
                                                    na.rm = TRUE)/1 
                                           # following weighted average formula here: weighted average = sum(x * weight)/sum(weights)
                                           return(y)
                                         }
      ),
      # Coarse fragments average across depths (avg. weighted by width of layer)
      avgCoarsePerc_acrossDepth = pmap_dbl(.[c("horizonThickness_cm_2cm" , "horizonThickness_cm_7cm" ,
                                               "horizonThickness_cm_15cm" ,   "horizonThickness_cm_25cm" ,
                                               "horizonThickness_cm_35cm" , "horizonThickness_cm_50cm" , 
                                               "horizonThickness_cm_70cm" , "horizonThickness_cm_90cm" ,
                                               "horizonThickness_cm_125cm" ,  "horizonThickness_cm_176cm", 
                                               "coarsePerc_2cm", "coarsePerc_7cm" , "coarsePerc_15cm",
                                               "coarsePerc_25cm" , "coarsePerc_35cm", "coarsePerc_50cm" ,
                                               "coarsePerc_70cm", "coarsePerc_90cm" ,
                                               "coarsePerc_125cm","coarsePerc_176cm", "soilDepth")], 
                                           function(horizonThickness_cm_2cm , horizonThickness_cm_7cm ,
                                                    horizonThickness_cm_15cm , horizonThickness_cm_25cm ,
                                                    horizonThickness_cm_35cm , horizonThickness_cm_50cm , 
                                                    horizonThickness_cm_70cm , horizonThickness_cm_90cm ,
                                                    horizonThickness_cm_125cm , horizonThickness_cm_176cm,
                                                    coarsePerc_2cm, coarsePerc_7cm , coarsePerc_15cm,
                                                    coarsePerc_25cm , coarsePerc_35cm, coarsePerc_50cm ,
                                                    coarsePerc_70cm, coarsePerc_90cm ,
                                                    coarsePerc_125cm,coarsePerc_176cm, soilDepth) {
                                             y <- sum(c(coarsePerc_2cm *  horizonThickness_cm_2cm/soilDepth, 
                                                        coarsePerc_7cm *    horizonThickness_cm_7cm/soilDepth, 
                                                        coarsePerc_15cm *   horizonThickness_cm_15cm/soilDepth, 
                                                        coarsePerc_25cm *   horizonThickness_cm_25cm/soilDepth, 
                                                        coarsePerc_35cm *   horizonThickness_cm_35cm/soilDepth, 
                                                        coarsePerc_50cm *   horizonThickness_cm_50cm/soilDepth, 
                                                        coarsePerc_70cm *   horizonThickness_cm_70cm/soilDepth, 
                                                        coarsePerc_90cm *   horizonThickness_cm_90cm/soilDepth, 
                                                        coarsePerc_125cm *  horizonThickness_cm_125cm/soilDepth, 
                                                        coarsePerc_176cm *  horizonThickness_cm_176cm/soilDepth), 
                                                      na.rm = TRUE)/1 
                                             # following weighted average formula here: weighted average = sum(x * weight)/sum(weights)
                                             return(y)
                                           }
      ), 
      # soil organic carbon in first 3 cm 
      avgOrganicCarbonPerc_0_3cm = organicCarbonPerc_2cm
    )
  
  
  # # total profile available water-holding capacity
  temp <- soils_new %>% 
    mutate(clayPerc_2cm = clayPerc_2cm/100,
           clayPerc_7cm = clayPerc_7cm/100,
           clayPerc_15cm = clayPerc_15cm/100,
           clayPerc_25cm = clayPerc_25cm/100,
           clayPerc_35cm = clayPerc_35cm/100,
           clayPerc_50cm = clayPerc_50cm/100,
           clayPerc_70cm = clayPerc_70cm/100,
           clayPerc_90cm = clayPerc_90cm/100,
           clayPerc_125cm = clayPerc_125cm/100,
           clayPerc_176cm = clayPerc_176cm/100,
           sandPerc_2cm = sandPerc_2cm/100,
           sandPerc_7cm = sandPerc_7cm/100,
           sandPerc_15cm = sandPerc_15cm/100,
           sandPerc_25cm = sandPerc_25cm/100,
           sandPerc_35cm = sandPerc_35cm/100,
           sandPerc_50cm = sandPerc_50cm/100,
           sandPerc_70cm = sandPerc_70cm/100,
           sandPerc_90cm = sandPerc_90cm/100,
           sandPerc_125cm = sandPerc_125cm/100,
           sandPerc_176cm = sandPerc_176cm/100,
           coarsePerc_2cm = coarsePerc_2cm/100,
           coarsePerc_7cm = coarsePerc_7cm/100,
           coarsePerc_15cm = coarsePerc_15cm/100,
           coarsePerc_25cm = coarsePerc_25cm/100,
           coarsePerc_35cm = coarsePerc_35cm/100,
           coarsePerc_50cm = coarsePerc_50cm/100,
           coarsePerc_70cm = coarsePerc_70cm/100,
           coarsePerc_90cm = coarsePerc_90cm/100,
           coarsePerc_125cm = coarsePerc_125cm/100,
           coarsePerc_176cm = coarsePerc_176cm/100) #%>% 
  #slice(1:3) 
  # calculate # # intermediate value 'p' 
  vegSoil_p <- pmap(.l = temp[,c("sandPerc_2cm", "sandPerc_7cm", "sandPerc_15cm", 
                                 "sandPerc_25cm", "sandPerc_35cm", "sandPerc_50cm", 
                                 "sandPerc_70cm", "sandPerc_90cm" ,"sandPerc_125cm", 
                                 "sandPerc_176cm",
                                 "clayPerc_2cm", "clayPerc_7cm" , "clayPerc_15cm", 
                                 "clayPerc_25cm", "clayPerc_35cm", "clayPerc_50cm", 
                                 "clayPerc_70cm", "clayPerc_90cm" ,"clayPerc_125cm", 
                                 "clayPerc_176cm",
                                 "coarsePerc_2cm", "coarsePerc_7cm" , "coarsePerc_15cm", 
                                 "coarsePerc_25cm", "coarsePerc_35cm", "coarsePerc_50cm", 
                                 "coarsePerc_70cm", "coarsePerc_90cm" ,"coarsePerc_125cm", 
                                 "coarsePerc_176cm")], 
                    function (sandPerc_2cm, sandPerc_7cm, sandPerc_15cm, 
                              sandPerc_25cm, sandPerc_35cm, sandPerc_50cm, 
                              sandPerc_70cm, sandPerc_90cm ,sandPerc_125cm, 
                              sandPerc_176cm,
                              clayPerc_2cm, clayPerc_7cm , clayPerc_15cm, 
                              clayPerc_25cm, clayPerc_35cm, clayPerc_50cm, 
                              clayPerc_70cm, clayPerc_90cm ,clayPerc_125cm, 
                              clayPerc_176cm,
                              coarsePerc_2cm, coarsePerc_7cm , coarsePerc_15cm, 
                              coarsePerc_25cm, coarsePerc_35cm, coarsePerc_50cm, 
                              coarsePerc_70cm, coarsePerc_90cm ,coarsePerc_125cm, 
                              coarsePerc_176cm) {
                      p <- rSOILWAT2::ptf_estimate(
                        sand = c(sandPerc_2cm,sandPerc_7cm , sandPerc_15cm,
                                 sandPerc_25cm , sandPerc_35cm, sandPerc_50cm , 
                                 sandPerc_70cm, sandPerc_90cm ,
                                 sandPerc_125cm,sandPerc_176cm),
                        clay = c(clayPerc_2cm,clayPerc_7cm , clayPerc_15cm,
                                 clayPerc_25cm , clayPerc_35cm, clayPerc_50cm , 
                                 clayPerc_70cm, clayPerc_90cm ,
                                 clayPerc_125cm,clayPerc_176cm),
                        fcoarse = c(coarsePerc_2cm, coarsePerc_7cm , coarsePerc_15cm,
                                    coarsePerc_25cm , coarsePerc_35cm, coarsePerc_50cm , 
                                    coarsePerc_70cm, coarsePerc_90cm ,
                                    coarsePerc_125cm,coarsePerc_176cm),
                        swrc_name = "Campbell1974",
                        ptf_name = "Cosby1984"
                      )
                    }
  )
  
# calculate intermediate value 'tmp'
  # reference "temp" data frame (which has the raw soil variables), as well as vegSoil_p, a list which has matrices for p calculated above
  vegSoil_tmp <- map(.x = c(1:nrow(temp)), 
                    function (n) {
                      tmp <- rSOILWAT2::swrc_swp_to_vwc(
                        c(-1.5, -0.033), ##AES should I change this? not totally clear what these values indicate 
                        fcoarse = unlist(as.vector(temp[n,c("coarsePerc_2cm" ,                           
                                           "coarsePerc_7cm" ,  "coarsePerc_15cm",                        
                                           "coarsePerc_25cm",  "coarsePerc_35cm",                        
                                           "coarsePerc_50cm",  "coarsePerc_70cm",                        
                                           "coarsePerc_90cm",  "coarsePerc_125cm",                        
                                           "coarsePerc_176cm")])),
                        swrc = list(name = "Campbell1974", swrcp = vegSoil_p[[n]])
                      )
                    }
  )
  
  
#   # calculate final value 'awc' 
  vegSoil_awc <- map(.x = c(1:nrow(temp)), 
                     function (n) {
                      awc <- temp[n,c("horizonThickness_cm_2cm"  ,                 
                                     "horizonThickness_cm_7cm"  ,                  "horizonThickness_cm_15cm"    ,              
                                     "horizonThickness_cm_25cm" ,                  "horizonThickness_cm_35cm"    ,              
                                     "horizonThickness_cm_50cm" ,                  "horizonThickness_cm_70cm"    ,              
                                     "horizonThickness_cm_90cm" ,                  "horizonThickness_cm_125cm"   ,              
                                     "horizonThickness_cm_176cm")] * as.vector(diff(vegSoil_tmp[[n]])
                                                                               )
                      #AES I assume that I sum these values across the entire profile to get "total profile awc"??
                      totAWC <- sum(awc, na.rm = TRUE)
                     }
  )
  
  soils_new$totalAvailableWaterHoldingCapacity <- unlist(vegSoil_awc)


# remove unnecessary soils variables 
  soils_final <- soils_new %>% 
    dplyr::select(-c(clayPerc_2cm:organicCarbonPerc_176cm)) %>% 
    filter(!is.nan(x))
  
  # ggplot() +
  #   #geom_sf(data = cropped_states) +
  #   #geom_point(data = climDat[1:100,], aes(x, y)) +
  #   geom_point(data = soils_final, aes(x, y, col = avgSandPerc_acrossDepth))
  # 
  # 
# add soils to climate data
  climDat_test <- 
    climDat %>% 
    st_as_sf(coords = c("x", "y"), crs = st_crs(test_rast))
  soils_final_test <- soils_final %>% 
    st_as_sf(coords = c("x", "y"), crs = st_crs(test_rast))
  # ggplot() + 
  #   geom_sf(data = climDat_test, aes(col = "red")) + 
  #   geom_sf(data = soils_final_test, aes(col = "blue")) + 
  #   xlim(c(13000,305500)) + 
  #   ylim(c(-1513500, -1013500))

forecastClimSoilsDat_1 <- climDat_test %>% 
  st_join(st_buffer(soils_final_test, 8000))
# 
#   ggplot() +
#     #geom_sf(data = cropped_states) +
#     #geom_point(data = climDat[1:100,], aes(x, y)) +
#     geom_sf(data = forecastClimSoilsDat_1, aes( col = avgOrganicCarbonPerc_0_3cm))

## save the data
saveRDS(forecastClimSoilsDat_1, "../../../Data_processed/CoverData/IntermediateAnalysisFiles/Final_ForecastedClimateDataAndSoilsDataForPredictions_BNU-ESM_rcp8_5.rds")
```

 Calculate climate means and weather anomalies for the second set of climate model data 
```{r, eval = FALSE}
climVar_2 <- climDat_monthly_2 %>% 
  #slice(1:100) %>% 
  mutate(totalAnnPrecip = rowSums(.[c("prcp_mm_1", "prcp_mm_2", "prcp_mm_3", "prcp_mm_4", "prcp_mm_5", "prcp_mm_6", "prcp_mm_7", "prcp_mm_8", "prcp_mm_9", "prcp_mm_10" ,"prcp_mm_11", "prcp_mm_12")]), # total annual precipitation in mm
         T_warmestMonth = pmap_dbl(.[c("tmax_C_1", "tmax_C_2", "tmax_C_3", "tmax_C_4", "tmax_C_5", "tmax_C_6", "tmax_C_7", "tmax_C_8", "tmax_C_9", "tmax_C_10",  "tmax_C_11",  "tmax_C_12")], max), # temperature of warmest month
         T_coldestMonth = pmap_dbl(.[c("tmin_C_1", "tmin_C_2", "tmin_C_3", "tmin_C_4", "tmin_C_5", "tmin_C_6", "tmin_C_7", "tmin_C_8", "tmin_C_9", "tmin_C_10",  "tmin_C_11",  "tmin_C_12")], min), # temperature of coldest month
         Tmin_annAvgOfMonthly = rowSums(.[c("tmin_C_1", "tmin_C_2", "tmin_C_3", "tmin_C_4", "tmin_C_5", "tmin_C_6", "tmin_C_7", "tmin_C_8", "tmin_C_9", "tmin_C_10",  "tmin_C_11",  "tmin_C_12")])/12,
         Tmax_annAvgOfMonthly = rowSums(.[c("tmax_C_1", "tmax_C_2", "tmax_C_3", "tmax_C_4", "tmax_C_5", "tmax_C_6", "tmax_C_7", "tmax_C_8", "tmax_C_9", "tmax_C_10",  "tmax_C_11",  "tmax_C_12")])/12,
         #meanAnnVp = rowMeans(.[28:39]), # annual mean vapor pressure
         precip_wettestMonth = pmap_dbl(.[c("prcp_mm_1", "prcp_mm_2", "prcp_mm_3", "prcp_mm_4", "prcp_mm_5", "prcp_mm_6", "prcp_mm_7", "prcp_mm_8", "prcp_mm_9", "prcp_mm_10" ,"prcp_mm_11", "prcp_mm_12")],
                                        max), # precip of wettest month
         precip_driestMonth = pmap_dbl(.[c("prcp_mm_1", "prcp_mm_2", "prcp_mm_3", "prcp_mm_4", "prcp_mm_5", "prcp_mm_6", "prcp_mm_7", "prcp_mm_8", "prcp_mm_9", "prcp_mm_10" ,"prcp_mm_11", "prcp_mm_12")], 
                                       min), # precip of driest month
         precip_Seasonality = pmap_dbl(.[c("prcp_mm_1", "prcp_mm_2", "prcp_mm_3", "prcp_mm_4", "prcp_mm_5", "prcp_mm_6", "prcp_mm_7", "prcp_mm_8", "prcp_mm_9", "prcp_mm_10" ,"prcp_mm_11", "prcp_mm_12")],   # coefficient of variation (sd/mean) of precipitation
                                       .f = function(prcp_mm_1, prcp_mm_2, prcp_mm_3, prcp_mm_4, prcp_mm_5, prcp_mm_6, prcp_mm_7, prcp_mm_8, prcp_mm_9, prcp_mm_10 ,prcp_mm_11, prcp_mm_12, ...) 
                                       {temp <- c(prcp_mm_1, prcp_mm_2, prcp_mm_3, prcp_mm_4, prcp_mm_5, prcp_mm_6, prcp_mm_7, prcp_mm_8, prcp_mm_9, prcp_mm_10 ,prcp_mm_11, prcp_mm_12)
                                       sd(temp)/mean(temp)
                                       }
         ),
         PrecipTempCorr = pmap_dbl(.[c("tmax_C_1", "tmax_C_2", "tmax_C_3", "tmax_C_4", "tmax_C_5", "tmax_C_6", "tmax_C_7", "tmax_C_8", "tmax_C_9", "tmax_C_10",  "tmax_C_11",  "tmax_C_12",
                                       "prcp_mm_1", "prcp_mm_2", "prcp_mm_3", "prcp_mm_4", "prcp_mm_5", "prcp_mm_6", "prcp_mm_7", "prcp_mm_8", "prcp_mm_9", "prcp_mm_10" ,"prcp_mm_11", "prcp_mm_12")], #correlation of monthly temp and precip
                                   .f = function(tmax_C_1, tmax_C_2, tmax_C_3, tmax_C_4, tmax_C_5, tmax_C_6, tmax_C_7, tmax_C_8, tmax_C_9, tmax_C_10,  tmax_C_11,  tmax_C_12,
                                                 prcp_mm_1, prcp_mm_2, prcp_mm_3, prcp_mm_4, prcp_mm_5, prcp_mm_6, prcp_mm_7, prcp_mm_8, prcp_mm_9, prcp_mm_10 ,prcp_mm_11, prcp_mm_12, ...) {
                                     cor(y = c(tmax_C_1, tmax_C_2, tmax_C_3, tmax_C_4, tmax_C_5, tmax_C_6, tmax_C_7, tmax_C_8, tmax_C_9, tmax_C_10,  tmax_C_11,  tmax_C_12), 
                                         x = c(prcp_mm_1, prcp_mm_2, prcp_mm_3, prcp_mm_4, prcp_mm_5, prcp_mm_6, prcp_mm_7, prcp_mm_8, prcp_mm_9, prcp_mm_10 ,prcp_mm_11, prcp_mm_12))
                                   }),
         aboveFreezing_month = pmap_dbl(.[c("tmin_C_1", "tmin_C_2", "tmin_C_3", "tmin_C_4", "tmin_C_5", "tmin_C_6", "tmin_C_7", "tmin_C_8", "tmin_C_9", "tmin_C_10",  "tmin_C_11",  "tmin_C_12")], # month when temp gets above freezing (when tmin > 0 degrees C, so no freeze at night )
                                        .f = function(tmin_C_1, tmin_C_2, tmin_C_3, tmin_C_4, tmin_C_5, tmin_C_6, tmin_C_7, tmin_C_8, tmin_C_9, tmin_C_10,  tmin_C_11,  tmin_C_12) {
                                          temp <- c(tmin_C_1, tmin_C_2, tmin_C_3, tmin_C_4, tmin_C_5, tmin_C_6, tmin_C_7, tmin_C_8, tmin_C_9, tmin_C_10,  tmin_C_11,  tmin_C_12)
                                          which(temp > 0)[1] # in degrees C
                                        }),
         lastAboveFreezing_month = pmap_dbl(.[c("tmin_C_1", "tmin_C_2", "tmin_C_3", "tmin_C_4", "tmin_C_5", "tmin_C_6", "tmin_C_7", "tmin_C_8", "tmin_C_9", "tmin_C_10",  "tmin_C_11",  "tmin_C_12")], # month when temp gets above freezing (when tmin > 0 degrees C, so no freeze at night )
                                        .f = function(tmin_C_1, tmin_C_2, tmin_C_3, tmin_C_4, tmin_C_5, tmin_C_6, tmin_C_7, tmin_C_8, tmin_C_9, tmin_C_10,  tmin_C_11,  tmin_C_12) {
                                          temp <- c(tmin_C_1, tmin_C_2, tmin_C_3, tmin_C_4, tmin_C_5, tmin_C_6, tmin_C_7, tmin_C_8, tmin_C_9, tmin_C_10,  tmin_C_11,  tmin_C_12)
                                          temp2 <- which(temp > 0) # in degrees C
                                          if(length(temp2)>0) {
                                            return(max(temp2))
                                          } else {
                                              return(NA)
                                            }
                                        }),
         
         isothermality = pmap_dbl(.[c("tmax_C_1", "tmax_C_2", "tmax_C_3", "tmax_C_4", "tmax_C_5", "tmax_C_6", "tmax_C_7", "tmax_C_8", "tmax_C_9", "tmax_C_10",  "tmax_C_11",  "tmax_C_12",
                                      "tmin_C_1", "tmin_C_2", "tmin_C_3", "tmin_C_4", "tmin_C_5", "tmin_C_6", "tmin_C_7", "tmin_C_8", "tmin_C_9", "tmin_C_10",  "tmin_C_11",  "tmin_C_12")], # isothermality
                                  .f = function(tmax_C_1, tmax_C_2, tmax_C_3, tmax_C_4, tmax_C_5, tmax_C_6, tmax_C_7, tmax_C_8, tmax_C_9, tmax_C_10,  tmax_C_11,  tmax_C_12,
                                                tmin_C_1, tmin_C_2, tmin_C_3, tmin_C_4, tmin_C_5, tmin_C_6, tmin_C_7, tmin_C_8, tmin_C_9, tmin_C_10,  tmin_C_11,  tmin_C_12, ...) {
                                    tmins <- c(tmin_C_1, tmin_C_2, tmin_C_3, tmin_C_4, tmin_C_5, tmin_C_6, tmin_C_7, tmin_C_8, tmin_C_9, tmin_C_10,  tmin_C_11,  tmin_C_12)
                                    tmaxes <- c(tmax_C_1, tmax_C_2, tmax_C_3, tmax_C_4, tmax_C_5, tmax_C_6, tmax_C_7, tmax_C_8, tmax_C_9, tmax_C_10,  tmax_C_11,  tmax_C_12)
                                    tMaxMax <- max(c(tmax_C_1, tmax_C_2, tmax_C_3, tmax_C_4, tmax_C_5, tmax_C_6, tmax_C_7, tmax_C_8, tmax_C_9, tmax_C_10,  tmax_C_11,  tmax_C_12))
                                    tMinMin <- min(c(tmin_C_1, tmin_C_2, tmin_C_3, tmin_C_4, tmin_C_5, tmin_C_6, tmin_C_7, tmin_C_8, tmin_C_9, tmin_C_10,  tmin_C_11,  tmin_C_12))
                                    mean(tmaxes-tmins)/(tMaxMax-tMinMin) * 100
                                  }),
         
  ) %>% 
  mutate(
    # calculate the duration of frost-free days (in our case here, Frost-free
    # days = (doy of first day of the first month when tmin is >0) - (doy of
    # last day of the lost month when tmin >0))
    # first month when tmin is above freezing is "aboveFreezing_month" in the previous d.f.
    # last month when tmin is above freezing is "lastAboveFreezing_month" in the previous d.f.
    durationFrostFreeDays = 
      # DOY of last day of last frost-free month (just give the 30th, since it
      # probably isn't a bit deal if we use the 30th rather than the 31st in
      # months when there is a 31st)
      lubridate::yday(as.Date(paste0(lastAboveFreezing_month, "/30/2024"), 
                              format = "%m/%d/%Y")) - 
      # DOY of first day of first frost-free month
      lubridate::yday(as.Date(paste0("0",aboveFreezing_month, "/01/2024"), 
                                                    format = "%m/%d/%Y"))
    )

# constants for SVP calculation 
#calculate SVP according to Williams et al NatCC 2012 supplementary material -  units haPa
a0<-6.107799961
a1<-0.4436518521
a2<-0.01428945805
a3<-0.0002650648471
a4<-0.000003031240396
a5<-0.00000002034080948
a6<-0.00000000006136820929
## calculating vapor pressure deficit, annual water deficit, and wet degree days (based on code from Adam Noel)

climVar2_2<- climDat_monthly_2%>% 
  #slice(23507:23509) %>% 
  # approximation of mean temp (just avg. of max and min, which I realize is not totally accurate)
  mutate(tmean_Jan = (tmax_C_1 + tmin_C_1)/2,
         tmean_Feb = (tmax_C_2 + tmin_C_2)/2,
         tmean_March = (tmax_C_3 + tmin_C_3)/2,
         tmean_April = (tmax_C_4 + tmin_C_4)/2,
         tmean_May = (tmax_C_5 + tmin_C_5)/2,
         tmean_June = (tmax_C_6 + tmin_C_6)/2,
         tmean_July = (tmax_C_7 + tmin_C_7)/2,
         tmean_Aug = (tmax_C_8 + tmin_C_8)/2,
         tmean_Sept = (tmax_C_9 + tmin_C_9)/2,
         tmean_Oct = (tmax_C_10 + tmin_C_10)/2,
         tmean_Nov = (tmax_C_11 + tmin_C_11)/2,
         tmean_Dec = (tmax_C_12 + tmin_C_12)/2,
  ) %>% 
  mutate(
    # monthly water deficit 
    awd_Jan = tmean_Jan*2 - prcp_mm_1,
    awd_Feb = tmean_Feb*2 - prcp_mm_2,
    awd_March = tmean_March*2 - prcp_mm_3,
    awd_April = tmean_April*2 - prcp_mm_4,
    awd_May = tmean_May*2 - prcp_mm_5,
    awd_June = tmean_June*2 - prcp_mm_6, 
    awd_July = tmean_July*2 - prcp_mm_7,
    awd_Aug = tmean_Aug*2 - prcp_mm_8, 
    awd_Sept = tmean_Sept*2 - prcp_mm_9, 
    awd_Oct = tmean_Oct*2 - prcp_mm_10,   
    awd_Nov = tmean_Nov*2 - prcp_mm_11,   
    awd_Dec = tmean_Dec*2 - prcp_mm_12,   
    # monthly wet degree days
    ##aes 
    awdd_Jan =  ifelse(tmean_Jan*2 < prcp_mm_1, tmean_Jan*30, NA),
    awdd_Feb =  ifelse(tmean_Feb*2 < prcp_mm_2, tmean_Feb*30, NA),
    awdd_March =   ifelse(tmean_March*2 < prcp_mm_3, tmean_March*30, NA),
    awdd_April =  ifelse(tmean_April*2 < prcp_mm_4, tmean_April*30, NA),
    awdd_May = ifelse(tmean_May*2 < prcp_mm_5, tmean_May*30, NA),
    awdd_June = ifelse(tmean_June*2 < prcp_mm_6, tmean_June*30, NA),
    awdd_July = ifelse(tmean_July*2 < prcp_mm_7, tmean_July*30, NA), 
    awdd_Aug = ifelse(tmean_Aug*2 < prcp_mm_8, tmean_Aug*30, NA),
    awdd_Sept = ifelse(tmean_Sept*2 < prcp_mm_9, tmean_Sept*30, NA),
    awdd_Oct = ifelse(tmean_Oct*2 < prcp_mm_10, tmean_Oct*30, NA),
    awdd_Nov = ifelse(tmean_Nov*2 < prcp_mm_11, tmean_Nov*30, NA),
    awdd_Dec = ifelse(tmean_Dec*2 < prcp_mm_12, tmean_Dec*30, NA),
   
    # units are Pascals 
    VPD_Jan = ((( a0+ tmean_Jan*(a1+ tmean_Jan *(a2+ tmean_Jan *(a3+ tmean_Jan *(a4	+ tmean_Jan *(a5	+ tmean_Jan *a6)))))))*100 -  (tmean_Jan))/1000,
    VPD_Feb = ((( a0+ tmean_Feb*(a1+ tmean_Feb *(a2+ tmean_Feb *(a3+ tmean_Feb *(a4	+ tmean_Feb *(a5	+ tmean_Feb *a6)))))))*100 -  (tmean_Feb))/1000,
    VPD_March = ((( a0+ tmean_March*(a1+ tmean_March *(a2+ tmean_March *(a3+ tmean_March *(a4	+ tmean_March *(a5	+ tmean_March *a6)))))))*100 -  (tmean_March))/1000,
    VPD_April = ((( a0+ tmean_April*(a1+ tmean_April *(a2+ tmean_April *(a3+ tmean_April *(a4	+ tmean_April *(a5	+ tmean_April *a6)))))))*100 -  (tmean_April))/1000,
    VPD_May =   ((( a0+ tmean_May*(a1+ tmean_May *(a2+ tmean_May *(a3+ tmean_May *(a4	+ tmean_May *(a5	+ tmean_May *a6)))))))*100 -  (tmean_May))/1000,
    VPD_June =  ((( a0+ tmean_June*(a1+ tmean_June *(a2+ tmean_June *(a3+ tmean_June *(a4	+ tmean_June *(a5	+ tmean_June *a6)))))))*100 -  (tmean_June))/1000,
    VPD_July =  ((( a0+ tmean_July*(a1+ tmean_July *(a2+ tmean_July *(a3+ tmean_July *(a4	+ tmean_July *(a5	+ tmean_July *a6)))))))*100 -  (tmean_July))/1000,
    VPD_Aug =   ((( a0+ tmean_Aug*(a1+ tmean_Aug *(a2+ tmean_Aug *(a3+ tmean_Aug *(a4	+ tmean_Aug *(a5	+ tmean_Aug *a6)))))))*100 -  (tmean_Aug))/1000,
    VPD_Sept =  ((( a0+ tmean_Sept*(a1+ tmean_Sept *(a2+ tmean_Sept *(a3+ tmean_Sept *(a4	+ tmean_Sept *(a5	+ tmean_Sept *a6)))))))*100 -  (tmean_Sept))/1000,
    VPD_Oct =   ((( a0+ tmean_Oct*(a1+ tmean_Oct *(a2+ tmean_Oct *(a3+ tmean_Oct *(a4	+ tmean_Oct *(a5	+ tmean_Oct *a6)))))))*100 -  (tmean_Oct))/1000,
    VPD_Nov =   ((( a0+ tmean_Nov*(a1+ tmean_Nov *(a2+ tmean_Nov *(a3+ tmean_Nov *(a4	+ tmean_Nov *(a5	+ tmean_Nov *a6)))))))*100 -  (tmean_Nov))/1000,
    VPD_Dec =   ((( a0+ tmean_Dec*(a1+ tmean_Dec *(a2+ tmean_Dec *(a3+ tmean_Dec *(a4	+ tmean_Dec *(a5	+ tmean_Dec *a6)))))))*100 -  (tmean_Dec))/1000
    ) %>% 
  #calculate annual values
  transmute(#keep = c("year", "Long", "Lat"),
  #mutate(
    # annual water deficit (mm of water over degrees celsius)(sum across all months?)
    tmean = pmap_dbl(.[c("tmean_Jan", "tmean_Feb", "tmean_March", "tmean_April", "tmean_May", "tmean_June", "tmean_July", "tmean_Aug", "tmean_Sept", "tmean_Oct" ,"tmean_Nov", "tmean_Dec")],
                       .f = function(tmean_Jan, tmean_Feb, tmean_March, tmean_April, tmean_May, tmean_June, tmean_July, tmean_Aug, tmean_Sept, tmean_Oct ,tmean_Nov, tmean_Dec, ...) {
                         temp <- sum(tmean_Jan, tmean_Feb, tmean_March, tmean_April, tmean_May, tmean_June, tmean_July, tmean_Aug, tmean_Sept, tmean_Oct ,tmean_Nov, tmean_Dec)/12
                         return(temp)
                       }),
    
    # annual water deficit (mm of water over degrees celsius)(sum across all months?)
    annWaterDeficit = pmap_dbl(.[c("awd_Jan", "awd_Feb", "awd_March", "awd_April", "awd_May", "awd_June", "awd_July", "awd_Aug", "awd_Sept", "awd_Oct" ,"awd_Nov", "awd_Dec")], 
                               .f = function(awd_Jan, awd_Feb, awd_March, awd_April, awd_May, awd_June, awd_July, awd_Aug, awd_Sept, awd_Oct ,awd_Nov, awd_Dec, ...){
                                 temp <- c(awd_Jan, awd_Feb, awd_March, awd_April, awd_May, awd_June, awd_July, awd_Aug, awd_Sept, awd_Oct ,awd_Nov, awd_Dec)
                                 sum(temp[temp>0])
                               }
    ),
    # annual wet degree days (temp*days) (sum only positive values)
    annWetDegDays = pmap_dbl(.[c("awdd_Jan", "awdd_Feb", "awdd_March", "awdd_April", "awdd_May", "awdd_June", "awdd_July", "awdd_Aug", "awdd_Sept", "awdd_Oct" ,"awdd_Nov", "awdd_Dec")],
                             .f = function(awdd_Jan, awdd_Feb, awdd_March, awdd_April, awdd_May, awdd_June, awdd_July, awdd_Aug, awdd_Sept, awdd_Oct ,awdd_Nov, awdd_Dec, ...) 
                             {
                               temp <- c(awdd_Jan, awdd_Feb, awdd_March, awdd_April, awdd_May, awdd_June, awdd_July, awdd_Aug, awdd_Sept, awdd_Oct ,awdd_Nov, awdd_Dec)
                               sum(temp[temp>0], na.rm = TRUE)
                             }
    ),
    # annual average vapor pressure deficit (in milibars) ()
    annVPD_mean = pmap_dbl(.[c("VPD_Jan", "VPD_Feb", "VPD_March","VPD_April" ,"VPD_May","VPD_June", "VPD_July","VPD_Aug","VPD_Sept","VPD_Oct","VPD_Nov","VPD_Dec")], 
                           .f = function(VPD_Jan, VPD_Feb, VPD_March,VPD_April ,VPD_May,VPD_June, VPD_July,VPD_Aug,VPD_Sept,VPD_Oct,VPD_Nov,VPD_Dec) {
      mean(VPD_Jan, VPD_Feb, VPD_March,VPD_April ,VPD_May,VPD_June, VPD_July,VPD_Aug,VPD_Sept,VPD_Oct,VPD_Nov,VPD_Dec)
    }),
    # annual maximum vapor pressure deficit (in milibars) 
    annVPD_max = pmap_dbl(.[c("VPD_Jan", "VPD_Feb", "VPD_March","VPD_April" ,"VPD_May","VPD_June", "VPD_July","VPD_Aug","VPD_Sept","VPD_Oct","VPD_Nov","VPD_Dec")], max),
    # annual minimum vapor pressure deficit (in milibars) 
    annVPD_min = pmap_dbl(.[c("VPD_Jan", "VPD_Feb", "VPD_March","VPD_April" ,"VPD_May","VPD_June", "VPD_July","VPD_Aug","VPD_Sept","VPD_Oct","VPD_Nov","VPD_Dec")], min)
  )


# if duration of frost free days is NA, change to 0 (high elevation points where there aren't any days >0 degrees C)
climVar_2[is.na(climVar_2[,"durationFrostFreeDays"]),"durationFrostFreeDays"] <- 0
# if first month where tmin is above freezing is NA, change to 8 
climVar_2[is.na(climVar_2[,"aboveFreezing_month"]), "aboveFreezing_month"] <- 8

climVar_2 <- cbind(climVar_2, climVar2_2)

rm(climVar2_2)
gc()

## calculate MAP and MAT over past years (a sliding window?)

# for last 20-year window, which is fewer than the 30 we used in the model-fitting... but I'd have to download even more MACA data, which I don't want to do right now...
%>% <- slidingMetMeans(inDat = climVar_2,
                            start = as.numeric(2099-30), end = 2099)

names(annMeans_30yrs)[3:24] <- paste0(names(annMeans_30yrs)[3:24], "_CLIM")
annMeans_30yrs$End_CLIM <- 2099
# for last 3-year window
annMeans_3yrs <- slidingMetMeans(inDat = climVar_2,
                                 start = as.numeric(2099-3), end = 2099)

names(annMeans_3yrs)[3:24] <- paste0(names(annMeans_3yrs)[3:24], "_3yr")
annMeans_3yrs$End_3yr <- 2099
## add lagged data to the main climate value data.frame
test <- climVar_2 %>% 
  dplyr::select(-c(tmin_C_1:prcp_mm_12)) %>% 
  filter(Year == 2099) %>% 
  #filter(year == 2020) %>% 
  #slice(1:100) %>% 
  left_join(annMeans_30yrs, by = c("Year" = "End_CLIM", 
                                  "x" = "x", 
                                  "y" = "y")) %>% 
  left_join(annMeans_3yrs, by = c("Year" = "End_3yr", 
                                  "x" = "x", 
                                  "y" = "y")
  )

rm(annMeans_30yrs, annMeans_3yrs)
gc()

test$Start_CLIM <- 2099-30

# save intermediate data 
saveRDS(test, "../../../Data_processed/CoverData/IntermediateAnalysisFiles/ForecastedClimateDataForPredictions_IPSL-CM5A-MR_rcp8_5.rds")
test <- readRDS("../../../Data_processed/CoverData/IntermediateAnalysisFiles/ForecastedClimateDataForPredictions_IPSL-CM5A-MR_rcp8_5.rds")
rm(climVar_2)
gc()

#### calculate anomalies ####
# i.e. how do the 3 yr. lagged values compare to the 20yr lagged values?

anomDat_3yr <- test %>% 
  transmute(
    # compare 3 yr values to 20 yr values
    # tmean as absolute difference
    tmean_meanAnnAvg_3yrAnom = tmean_meanAnnAvg_CLIM - tmean_meanAnnAvg_3yr,
    # tmin as absolute difference
    tmin_meanAnnAvg_3yrAnom = tmin_meanAnnAvg_CLIM - tmin_meanAnnAvg_3yr,
    # tmax as absolute difference
    tmax_meanAnnAvg_3yrAnom = tmax_meanAnnAvg_CLIM - tmax_meanAnnAvg_3yr,
    # vp as % difference
    #vp_meanAnnAvg_3yrAnom = (vp_meanAnnAvg_CLIM - vp_meanAnnAvg_3yr)/vp_meanAnnAvg_CLIM,
    # prcp as % difference
    prcp_meanAnnTotal_3yrAnom = (prcp_meanAnnTotal_CLIM - prcp_meanAnnTotal_3yr)/prcp_meanAnnTotal_CLIM,
    # t warmest month as absolute difference
    T_warmestMonth_meanAnnAvg_3yrAnom = T_warmestMonth_meanAnnAvg_CLIM - T_warmestMonth_meanAnnAvg_3yr,
    # t coldest month as absolute difference
    T_coldestMonth_meanAnnAvg_3yrAnom = T_coldestMonth_meanAnnAvg_CLIM - T_coldestMonth_meanAnnAvg_3yr,
    # precip wettest month as % difference
    precip_wettestMonth_meanAnnAvg_3yrAnom = (precip_wettestMonth_meanAnnAvg_CLIM - precip_wettestMonth_meanAnnAvg_3yr)/precip_wettestMonth_meanAnnAvg_CLIM,
    # precip driest month as % difference
    precip_driestMonth_meanAnnAvg_3yrAnom = (precip_driestMonth_meanAnnAvg_CLIM - precip_driestMonth_meanAnnAvg_3yr)/precip_driestMonth_meanAnnAvg_CLIM,
    # precip seasonality as % difference
    precip_Seasonality_meanAnnAvg_3yrAnom = (precip_Seasonality_meanAnnAvg_CLIM - precip_Seasonality_meanAnnAvg_3yr)/precip_Seasonality_meanAnnAvg_CLIM,
    # precip tempCorr as absolute difference
    PrecipTempCorr_meanAnnAvg_3yrAnom = PrecipTempCorr_meanAnnAvg_CLIM - PrecipTempCorr_meanAnnAvg_3yr,
    # above Freezing month as absolute difference
    aboveFreezing_month_meanAnnAvg_3yrAnom = aboveFreezing_month_meanAnnAvg_CLIM - aboveFreezing_month_meanAnnAvg_3yr,
    # isothermailty as % difference
    isothermality_meanAnnAvg_3yrAnom = isothermality_meanAnnAvg_CLIM - isothermality_meanAnnAvg_3yr,    
    # annual water deficit as % difference
    annWaterDeficit_meanAnnAvg_3yrAnom = ((annWaterDeficit_meanAnnAvg_CLIM+.0001) - annWaterDeficit_meanAnnAvg_3yr)/(annWaterDeficit_meanAnnAvg_CLIM+.0001),
    # wet degree days as % difference
    annWetDegDays_meanAnnAvg_3yrAnom = (annWetDegDays_meanAnnAvg_CLIM - annWetDegDays_meanAnnAvg_3yr)/annWetDegDays_meanAnnAvg_CLIM,
    # mean VPD as absolute difference
    annVPD_mean_meanAnnAvg_3yrAnom = (annVPD_mean_meanAnnAvg_CLIM - annVPD_mean_meanAnnAvg_3yr),
    # min VPD as absolute difference
    annVPD_min_meanAnnAvg_3yrAnom = (annVPD_min_meanAnnAvg_CLIM - annVPD_min_meanAnnAvg_3yr),
    # max VPD as absolute difference
    annVPD_max_meanAnnAvg_3yrAnom = (annVPD_max_meanAnnAvg_CLIM - annVPD_max_meanAnnAvg_3yr),
    # 95th percentile of max VPD as absolute difference 
    annVPD_max_95percentile_3yrAnom = (annVPD_max_95percentile_CLIM - annVPD_max_95percentile_3yr),
    # 95th percentile of annual water deficit as % difference
    annWaterDeficit_95percentile_3yrAnom = ((annWaterDeficit_95percentile_CLIM + .0001) - annWaterDeficit_95percentile_3yr)/(annWaterDeficit_95percentile_CLIM + .0001),
    # 5th percentile of annual wet degree days as % difference 
    annWetDegDays_5percentile_3yrAnom = ((annWetDegDays_5percentile_CLIM + .0001) - annWetDegDays_5percentile_3yr)/(annWetDegDays_5percentile_CLIM + .0001),
    # 5th percentile of frost-free days as absolute difference 
    durationFrostFreeDays_5percentile_3yrAnom = (durationFrostFreeDays_5percentile_CLIM - durationFrostFreeDays_5percentile_3yr),
    # mean of frost free days as absolute difference
    durationFrostFreeDays_meanAnnAvg_3yrAnom = (durationFrostFreeDays_meanAnnAvg_CLIM - durationFrostFreeDays_meanAnnAvg_3yr)
  )

climDat <- cbind(test, 
                 anomDat_3yr
) 

## add soils information 
  climDat_test <- 
    climDat %>% 
    st_as_sf(coords = c("x", "y"), crs = st_crs(test_rast))
  soils_final_test <- soils_final %>% 
    st_as_sf(coords = c("x", "y"), crs = st_crs(test_rast))
  # ggplot() + 
  #   geom_sf(data = climDat_test, aes(col = "red")) + 
  #   geom_sf(data = soils_final_test, aes(col = "blue")) + 
  #   xlim(c(13000,305500)) + 
  #   ylim(c(-1513500, -1013500))

forecastClimSoilsDat_2 <- climDat_test %>% 
  st_join(st_buffer(soils_final_test, 8000))
# 


## save the data
saveRDS(forecastClimSoilsDat_2, "../../../Data_processed/CoverData/IntermediateAnalysisFiles/Final_ForecastedClimateDataAndSoilsDataForPredictions_IPSL-CM5A-MR_rcp8_5.rds")
```

Prepare forecasted climate data for use in models 
```{r}
## Model # 1
forecastClimSoilsDat_1 <- readRDS("../../../Data_processed/CoverData/IntermediateAnalysisFiles/Final_ForecastedClimateDataAndSoilsDataForPredictions_BNU-ESM_rcp8_5.rds")
forecastClimSoilsDat_1$x <- st_coordinates(forecastClimSoilsDat_1)[,1]
forecastClimSoilsDat_1$y <- st_coordinates(forecastClimSoilsDat_1)[,2]
## add ecoregion data 
  forecastClimSoilsDat_1$newRegion <- NA
  forecastClimSoilsDat_1[st_covered_by(forecastClimSoilsDat_1, mapRegions[mapRegions$newRegion== "Forest",], sparse = FALSE), "newRegion"] <- "Forest"
  forecastClimSoilsDat_1[st_covered_by(forecastClimSoilsDat_1, mapRegions[mapRegions$newRegion== "dryShrubGrass",], sparse = FALSE), "newRegion"] <- "dryShrubGrass"

# rename
forecastClimSoilsDat_1 <- forecastClimSoilsDat_1 %>% 
  st_drop_geometry() %>% 
  dplyr::select(x, y, Year, tmin_meanAnnAvg_CLIM:durationFrostFreeDays_meanAnnAvg_CLIM, 
         tmean_meanAnnAvg_3yrAnom:durationFrostFreeDays_meanAnnAvg_3yrAnom,
          soilDepth:totalAvailableWaterHoldingCapacity, newRegion) %>% 
rename("tmin" = tmin_meanAnnAvg_CLIM, 
     "tmax" = tmax_meanAnnAvg_CLIM, #1 
     "tmean" = tmean_meanAnnAvg_CLIM, 
     "prcp" = prcp_meanAnnTotal_CLIM, 
     "t_warm" = T_warmestMonth_meanAnnAvg_CLIM,
     "t_cold" = T_coldestMonth_meanAnnAvg_CLIM, 
     "prcp_wet" = precip_wettestMonth_meanAnnAvg_CLIM,
     "prcp_dry" = precip_driestMonth_meanAnnAvg_CLIM, 
     "prcp_seasonality" = precip_Seasonality_meanAnnAvg_CLIM, #2
     "prcpTempCorr" = PrecipTempCorr_meanAnnAvg_CLIM,  #3
     "abvFreezingMonth" = aboveFreezing_month_meanAnnAvg_CLIM, 
     "isothermality" = isothermality_meanAnnAvg_CLIM, #4
     "annWatDef" = annWaterDeficit_meanAnnAvg_CLIM, 
     "annWetDegDays" = annWetDegDays_meanAnnAvg_CLIM,
     "VPD_mean" = annVPD_mean_meanAnnAvg_CLIM, 
     "VPD_max" = annVPD_max_meanAnnAvg_CLIM, #5
     "VPD_min" = annVPD_min_meanAnnAvg_CLIM, #6
     "VPD_max_95" = annVPD_max_95percentile_CLIM, 
     "annWatDef_95" = annWaterDeficit_95percentile_CLIM, 
     "annWetDegDays_5" = annWetDegDays_5percentile_CLIM, 
     "frostFreeDays_5" = durationFrostFreeDays_5percentile_CLIM, 
     "frostFreeDays" = durationFrostFreeDays_meanAnnAvg_CLIM, 
     "soilDepth" = soilDepth, #7
     "clay" = surfaceClay_perc, 
     "sand" = avgSandPerc_acrossDepth, #8
     "coarse" = avgCoarsePerc_acrossDepth, #9
     "carbon" = avgOrganicCarbonPerc_0_3cm, #10
     "AWHC" = totalAvailableWaterHoldingCapacity,
     ## anomaly variables
     tmean_anom = tmean_meanAnnAvg_3yrAnom, #15
     tmin_anom = tmin_meanAnnAvg_3yrAnom, #16
     tmax_anom = tmax_meanAnnAvg_3yrAnom, #17
    prcp_anom = prcp_meanAnnTotal_3yrAnom, #18
      t_warm_anom = T_warmestMonth_meanAnnAvg_3yrAnom,  #19
     t_cold_anom = T_coldestMonth_meanAnnAvg_3yrAnom, #20
      prcp_wet_anom = precip_wettestMonth_meanAnnAvg_3yrAnom, #21
      precp_dry_anom = precip_driestMonth_meanAnnAvg_3yrAnom,  #22
    prcp_seasonality_anom = precip_Seasonality_meanAnnAvg_3yrAnom, #23 
     prcpTempCorr_anom = PrecipTempCorr_meanAnnAvg_3yrAnom, #24
      aboveFreezingMonth_anom = aboveFreezing_month_meanAnnAvg_3yrAnom, #25  
    isothermality_anom = isothermality_meanAnnAvg_3yrAnom, #26
       annWatDef_anom = annWaterDeficit_meanAnnAvg_3yrAnom, #27
     annWetDegDays_anom = annWetDegDays_meanAnnAvg_3yrAnom,  #28
      VPD_mean_anom = annVPD_mean_meanAnnAvg_3yrAnom, #29
      VPD_min_anom = annVPD_min_meanAnnAvg_3yrAnom,  #30
      VPD_max_anom = annVPD_max_meanAnnAvg_3yrAnom,  #31
     VPD_max_95_anom = annVPD_max_95percentile_3yrAnom, #32
      annWatDef_95_anom = annWaterDeficit_95percentile_3yrAnom, #33 
      annWetDegDays_5_anom = annWetDegDays_5percentile_3yrAnom ,  #34
    frostFreeDays_5_anom = durationFrostFreeDays_5percentile_3yrAnom, #35 
      frostFreeDays_anom = durationFrostFreeDays_meanAnnAvg_3yrAnom #36
  ) 

## Model # 2
forecastClimSoilsDat_2 <- readRDS("../../../Data_processed/CoverData/IntermediateAnalysisFiles/Final_ForecastedClimateDataAndSoilsDataForPredictions_IPSL-CM5A-MR_rcp8_5.rds")
forecastClimSoilsDat_2$x <- st_coordinates(forecastClimSoilsDat_2)[,1]
forecastClimSoilsDat_2$y <- st_coordinates(forecastClimSoilsDat_2)[,2]
# get ecoregions
forecastClimSoilsDat_2$newRegion <- NA
  forecastClimSoilsDat_2[st_covered_by(forecastClimSoilsDat_2, mapRegions[mapRegions$newRegion== "Forest",], sparse = FALSE), "newRegion"] <- "Forest"
  forecastClimSoilsDat_2[st_covered_by(forecastClimSoilsDat_2, mapRegions[mapRegions$newRegion== "dryShrubGrass",], sparse = FALSE), "newRegion"] <- "dryShrubGrass"

# rename
forecastClimSoilsDat_2 <- forecastClimSoilsDat_2 %>% 
  st_drop_geometry() %>% 
  dplyr::select(x, y, Year, tmin_meanAnnAvg_CLIM:durationFrostFreeDays_meanAnnAvg_CLIM, 
         tmean_meanAnnAvg_3yrAnom:durationFrostFreeDays_meanAnnAvg_3yrAnom,
          soilDepth:totalAvailableWaterHoldingCapacity, newRegion) %>% 
rename("tmin" = tmin_meanAnnAvg_CLIM, 
     "tmax" = tmax_meanAnnAvg_CLIM, #1 
     "tmean" = tmean_meanAnnAvg_CLIM, 
     "prcp" = prcp_meanAnnTotal_CLIM, 
     "t_warm" = T_warmestMonth_meanAnnAvg_CLIM,
     "t_cold" = T_coldestMonth_meanAnnAvg_CLIM, 
     "prcp_wet" = precip_wettestMonth_meanAnnAvg_CLIM,
     "prcp_dry" = precip_driestMonth_meanAnnAvg_CLIM, 
     "prcp_seasonality" = precip_Seasonality_meanAnnAvg_CLIM, #2
     "prcpTempCorr" = PrecipTempCorr_meanAnnAvg_CLIM,  #3
     "abvFreezingMonth" = aboveFreezing_month_meanAnnAvg_CLIM, 
     "isothermality" = isothermality_meanAnnAvg_CLIM, #4
     "annWatDef" = annWaterDeficit_meanAnnAvg_CLIM, 
     "annWetDegDays" = annWetDegDays_meanAnnAvg_CLIM,
     "VPD_mean" = annVPD_mean_meanAnnAvg_CLIM, 
     "VPD_max" = annVPD_max_meanAnnAvg_CLIM, #5
     "VPD_min" = annVPD_min_meanAnnAvg_CLIM, #6
     "VPD_max_95" = annVPD_max_95percentile_CLIM, 
     "annWatDef_95" = annWaterDeficit_95percentile_CLIM, 
     "annWetDegDays_5" = annWetDegDays_5percentile_CLIM, 
     "frostFreeDays_5" = durationFrostFreeDays_5percentile_CLIM, 
     "frostFreeDays" = durationFrostFreeDays_meanAnnAvg_CLIM, 
     "soilDepth" = soilDepth, #7
     "clay" = surfaceClay_perc, 
     "sand" = avgSandPerc_acrossDepth, #8
     "coarse" = avgCoarsePerc_acrossDepth, #9
     "carbon" = avgOrganicCarbonPerc_0_3cm, #10
     "AWHC" = totalAvailableWaterHoldingCapacity,
     ## anomaly variables
     tmean_anom = tmean_meanAnnAvg_3yrAnom, #15
     tmin_anom = tmin_meanAnnAvg_3yrAnom, #16
     tmax_anom = tmax_meanAnnAvg_3yrAnom, #17
    prcp_anom = prcp_meanAnnTotal_3yrAnom, #18
      t_warm_anom = T_warmestMonth_meanAnnAvg_3yrAnom,  #19
     t_cold_anom = T_coldestMonth_meanAnnAvg_3yrAnom, #20
      prcp_wet_anom = precip_wettestMonth_meanAnnAvg_3yrAnom, #21
      precp_dry_anom = precip_driestMonth_meanAnnAvg_3yrAnom,  #22
    prcp_seasonality_anom = precip_Seasonality_meanAnnAvg_3yrAnom, #23 
     prcpTempCorr_anom = PrecipTempCorr_meanAnnAvg_3yrAnom, #24
      aboveFreezingMonth_anom = aboveFreezing_month_meanAnnAvg_3yrAnom, #25  
    isothermality_anom = isothermality_meanAnnAvg_3yrAnom, #26
       annWatDef_anom = annWaterDeficit_meanAnnAvg_3yrAnom, #27
     annWetDegDays_anom = annWetDegDays_meanAnnAvg_3yrAnom,  #28
      VPD_mean_anom = annVPD_mean_meanAnnAvg_3yrAnom, #29
      VPD_min_anom = annVPD_min_meanAnnAvg_3yrAnom,  #30
      VPD_max_anom = annVPD_max_meanAnnAvg_3yrAnom,  #31
     VPD_max_95_anom = annVPD_max_95percentile_3yrAnom, #32
      annWatDef_95_anom = annWaterDeficit_95percentile_3yrAnom, #33 
      annWetDegDays_5_anom = annWetDegDays_5percentile_3yrAnom ,  #34
    frostFreeDays_5_anom = durationFrostFreeDays_5percentile_3yrAnom, #35 
      frostFreeDays_anom = durationFrostFreeDays_meanAnnAvg_3yrAnom #36
  ) 
```

 Get the scaling factors for the data used to fit the models (scaling is done to entire dataset, so only need to get once for all models), and apply those same scaling factors to the data we'll predict with 
```{r fig.width= 12, fig.height = 12}
# get the scaling factors 
scaleParams <- modDat_1_s %>% 
  dplyr::select(tmin_s:AWHC_s) %>% 
  reframe(across(all_of(names(.)), attributes)) 

## For first climate model
# apply the scaling factors to the contemporary climate data 
namesToScale_1 <- forecastClimSoilsDat_1 %>% 
  dplyr::select(tmin:frostFreeDays, tmean_anom:frostFreeDays_anom, soilDepth:AWHC) %>% 
  names()

forecastClimSoilsDat_scaled_1 <- map(namesToScale_1, .f = function(x) {
  x_new <- (forecastClimSoilsDat_1[,x] - scaleParams[,paste0(x, "_s")]$`scaled:center`)/scaleParams[,paste0(x, "_s")]$`scaled:scale`
  return(data.frame(x_new))
}) %>% 
  purrr::list_cbind()
names(forecastClimSoilsDat_scaled_1) <- paste0(namesToScale_1, "_s")

forecastClimSoilsDatPred_1 <- forecastClimSoilsDat_1 %>% 
  dplyr::select(x:Year, newRegion) %>% 
  cbind(forecastClimSoilsDat_scaled_1)
names(forecastClimSoilsDatPred_1)[5:54] <- str_remove(names(forecastClimSoilsDatPred_1)[5:54], pattern = "_s$")

prednames_s <-  modDat_1_s %>%
  dplyr::select(tmin_s:AWHC_s) %>%
  names()
prednames <- str_replace(prednames_s, pattern = "_s$", replacement = "")


forecastClimSoilsDat_long_1 <- forecastClimSoilsDatPred_1 %>% 
  rename_with(.cols = any_of(c(prednames)), .fn = ~paste0(.x, "_s")) %>% 
  pivot_longer(cols = c(tmin_s:AWHC_s), names_to = "variableName", values_to = "values") %>% 
  mutate(source = "forecastClimSoilsDat") %>% 
  dplyr::select(x, y, variableName, values, source)
modDat_long <- modDat_1_s %>% 
  pivot_longer(cols = c(tmin_s:AWHC_s), names_to = "variableName", values_to = "values") %>% 
  mutate(source = "modDat") %>% 
  rename(x = x, y = y) %>% 
  dplyr::select(x, y, variableName, values, source)
allDat_long_1 <- forecastClimSoilsDat_long_1 %>% 
  rbind(modDat_long)

# ggplot(allDat_long_1)  +
#   facet_wrap(~variableName, scales = "free") +
#   geom_density(aes(values, col = source)) + 
#   ggtitle("A figure to double-check that the climate data used for contemporary predictions is consistent with the data used for fitting")

#////
## For first climate model
# apply the scaling factors to the contemporary climate data 
namesToScale_2 <- forecastClimSoilsDat_2 %>% 
  dplyr::select(tmin:frostFreeDays, tmean_anom:frostFreeDays_anom, soilDepth:AWHC) %>% 
  names()

forecastClimSoilsDat_scaled_2 <- map(namesToScale_2, .f = function(x) {
  x_new <- (forecastClimSoilsDat_2[,x] - scaleParams[,paste0(x, "_s")]$`scaled:center`)/scaleParams[,paste0(x, "_s")]$`scaled:scale`
  return(data.frame(x_new))
}) %>% 
  purrr::list_cbind()
names(forecastClimSoilsDat_scaled_2) <- paste0(namesToScale_2, "_s")

forecastClimSoilsDatPred_2 <- forecastClimSoilsDat_2 %>% 
  dplyr::select(x:Year, newRegion) %>% 
  cbind(forecastClimSoilsDat_scaled_2)
names(forecastClimSoilsDatPred_2)[5:54] <- str_remove(names(forecastClimSoilsDatPred_2)[5:54], pattern = "_s$")

forecastClimSoilsDat_long_2 <- forecastClimSoilsDatPred_2 %>% 
  rename_with(.cols = any_of(c(prednames)), .fn = ~paste0(.x, "_s")) %>% 
  pivot_longer(cols = c(tmin_s:AWHC_s), names_to = "variableName", values_to = "values") %>% 
  mutate(source = "forecastClimSoilsDat") %>% 
  dplyr::select(x, y, variableName, values, source)
modDat_long <- modDat_1_s %>% 
  pivot_longer(cols = c(tmin_s:AWHC_s), names_to = "variableName", values_to = "values") %>% 
  mutate(source = "modDat") %>% 
  rename(x = x, y = y) %>% 
  dplyr::select(x, y, variableName, values, source)
allDat_long_2 <- forecastClimSoilsDat_long_2 %>% 
  rbind(modDat_long)

# ggplot(allDat_long_2)  +
#   facet_wrap(~variableName, scales = "free") +
#   geom_density(aes(values, col = source)) + 
#   ggtitle("A figure to double-check that the climate data used for forecasted cliamte data predictions is consistent with the data used for fitting")


# # #///
# forecastClimSoilsDat_long_1$source = "Model_1"
# forecastClimSoilsDat_long_2$source = "Model_2"
# test_long <- forecastClimSoilsDat_long_1 %>%
#   rbind(forecastClimSoilsDat_long_2)
# 
# ggplot(test_long)  +
#   facet_wrap(~variableName, scales = "free") +
#   geom_density(aes(values, col = source)) +
#   ggtitle("A figure to double-check that the climate data used for contemporary predictions is consistent with the data used for fitting")

## visualize climate forecast variables

# [1] "ShrubCover~ exp( 2.809 +  0.080*prcp + -0.098*prcp_seasonality + -0.258*prcpTempCorr +  0.068*sand +  0.051*I(tmean^2) +  0.069*I(prcp_seasonality^2) +  0.002*I(annWatDef_anom^2) + -0.012*I(VPD_max_95_anom^2) + -0.048*I(sand^2) + -0.008*I(AWHC^2) +  0.023*annWetDegDays:annWatDef_anom +  0.032*annWetDegDays:isothermality_anom + -0.054*isothermality_anom:isothermality +  0.096*isothermality:tmean +  0.017*prcp:tmax_anom + -0.061*prcpTempCorr:tmin_anom) - 2"

# plot(forecastClimSoilsDat_1 %>% 
#          #drop_na(paste(response)) %>% 
#   #slice_sample(n = 5e4) %>%
#   terra::vect(geom = c("x", "y")) %>% 
#   terra::set.crs(crs(test_rast)) %>% 
#   terra::rasterize(y = test_rast, 
#                    field = "sand", 
#                    fun = mean, na.rm = TRUE) %>% 
#   terra::trim())

```


## Predict for 'level 1' of cover types

### Predict for grass/shrub total herbaceous cover: best lambda model

Read in the best lambda model object
```{r}
# read in model objects (is the trim anomaly version)
bestLambdaMod_GS_totHerb <- readRDS("/Users/astears/Documents/Dropbox_static/Work/NAU_USGS_postdoc/PED_vegClimModels/Analysis/VegComposition/ModelFitting/models/TotalHerbaceousCover_shrubGrass_noTLP_FALSE_trimAnom_bestLambdaGLM.rds")

ModelSpec_bestLambda <- getModelStatement(coefficientTable = grassShrub_totalHerb_trimAnoms,
                                                    modelName <- "coefficientValue_bestLambda", 
                                                    responseVar <- "TotalHerbaceousCover")
```

This is the **Best Lambda** model equation if the inputs *are* scaled: 
```{r}
(ModelSpec_bestLambda$scaledInputVars_ModelStatement)
```

This is the **Best Lambda** model equation if the inputs are *not* scaled: 
```{r}
(ModelSpec_bestLambda$unscaledInputVars_scaledModelStatement)
```

Now, predict with contemporary and future climate data 
```{r fig.width = 16, fig.height = 18, message = FALSE}
# predict w/ best SE lambda model
bestLambda_GS_totHerb_predict <- makePredictions(predictionDF = climDatPred, 
                                                           modelObject = bestLambdaMod_GS_totHerb)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_GS_totHerb_predictFuture_1 <- makePredictions(predictionDF = forecastClimSoilsDatPred_1, 
                                                           modelObject = bestLambdaMod_GS_totHerb)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_GS_totHerb_predictFuture_2 <- makePredictions(predictionDF = forecastClimSoilsDatPred_2, 
                                                           modelObject = bestLambdaMod_GS_totHerb)

# predict w/ best model
plotObs_GS_totHerb <- bestLambda_GS_totHerb_predict %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "modelPreds", 
                   fun = mean, na.rm = TRUE) #%>% 
   #terra::aggregate(fact = 2, fun = mean, na.rm = TRUE) %>% 
  #terra::crop(ext(-1950000, 1000000, -1800000, 1000000))

# get the extent of this particular raster, and crop it accordingly
tempExt <- crds(plotObs_GS_totHerb, na.rm = TRUE)

plotObs_GS_totHerb_2 <- plotObs_GS_totHerb %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

## map best SE lambda predictions for the future model #1
plotObs_GS_totHerb_bestLambdaFuture1 <- bestLambda_GS_totHerb_predictFuture_1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "modelPreds", 
                   fun = mean, na.rm = TRUE)

plotObs_GS_totHerb_bestLambdaFuture1_2 <- plotObs_GS_totHerb_bestLambdaFuture1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
## map best SE lambda predictions for the future model #2
plotObs_GS_totHerb_bestLambdaFuture2 <- bestLambda_GS_totHerb_predictFuture_2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "modelPreds", 
                   fun = mean, na.rm = TRUE)

plotObs_GS_totHerb_bestLambdaFuture2_2 <- plotObs_GS_totHerb_bestLambdaFuture2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

# get plot of observations
plotObservations_GS_totHerb <- modDat_1_s %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Long", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "TotalHerbaceousCover", 
                   fun = mean, na.rm = TRUE)

plotObservations_GS_totHerb_2 <- plotObservations_GS_totHerb %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
# make figures
map_bestLambda_GS_totHerb <- ggplot() +
geom_spatraster(data = plotObs_GS_totHerb_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_GS_totHerb_2)),fill=NA ) +
labs(title = paste0("Predictions of totalHerbaceousCover in the 
                    grass/shrub ecoregion 
                    using contemporary climate data"),
      subtitle = "bestLambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_GS_totHerb_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_GS_totHerb_2)[c(2,4)])

map_bestLambda_GS_totHerb_future1 <- ggplot() +
geom_spatraster(data = plotObs_GS_totHerb_bestLambdaFuture1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_GS_totHerb_2)),fill=NA ) +
labs(title = paste0("Predictions of totalHerbaceousCover in the 
                    grass/shrub ecoregion
                    using modeled climate data from BNU-ESM model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_GS_totHerb_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_GS_totHerb_2)[c(2,4)])

map_bestLambda_GS_totHerb_future2 <- ggplot() +
geom_spatraster(data = plotObs_GS_totHerb_bestLambdaFuture2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_GS_totHerb_2)),fill=NA ) +
labs(title = paste0("Predictions of totalHerbaceousCover in the 
                    grass/shrub ecoregion
                    using modeled climate data from IPSL-CM5A-MR model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_GS_totHerb_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_GS_totHerb_2)[c(2,4)])

map_obs_GS_totHerb <- ggplot() +
  geom_spatraster(data = plotObservations_GS_totHerb) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_GS_totHerb_2)),fill=NA ) +
labs(title = paste0("Observations of totalHerbaceousCover")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_GS_totHerb_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_GS_totHerb_2)[c(2,4)])

hist <- ggplot(bestLambda_GS_totHerb_predict) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = bestLambda_GS_totHerb_predict[bestLambda_GS_totHerb_predict$newRegion == "dryShrubGrass",],
               aes(x = modelPreds), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture1 <-  ggplot(bestLambda_GS_totHerb_predictFuture_1) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = bestLambda_GS_totHerb_predictFuture_1[bestLambda_GS_totHerb_predictFuture_1$newRegion == "dryShrubGrass",],
               aes(x = modelPreds), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture2 <-  ggplot(bestLambda_GS_totHerb_predictFuture_2) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = bestLambda_GS_totHerb_predictFuture_2[bestLambda_GS_totHerb_predictFuture_2$newRegion == "dryShrubGrass",],
               aes(x = modelPreds), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ylab("frequency")

hist_obs <- ggplot(modDat_1_s) + 
  geom_density(aes(TotalHerbaceousCover), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = modDat_1_s[modDat_1_s$newRegion == "dryShrubGrass",],
               aes(x = TotalHerbaceousCover), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ggtitle("Pink = predictions within 
          the focal ecoregion") +
  ylab("frequency")

## calculate residuals for contemporary prediction
# (observed - predicted)
resids <-  plotObservations_GS_totHerb_2 - plotObs_GS_totHerb_2 
map_resids_trimAnoms <- ggplot() +
geom_spatraster(data = resids) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(resids)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Resids. (obs. - pred.) from the 
                      grass-shrub model of TotalHerbaceousCover"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model with contemporary climate data") +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(resids)[c(1,3)]) + 
  ylim(st_bbox(resids)[c(2,4)])

hist_trimAnoms_resids <-  ggplot(resids) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") + 
  geom_vline(aes(xintercept = mean(terra::values(resids$mean), na.rm = TRUE)))

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model1 <-  plotObs_GS_totHerb_bestLambdaFuture1_2 - plotObs_GS_totHerb_2 

map_deltas_model1 <- ggplot() +
geom_spatraster(data = predDeltas_model1) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model1)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for \n grass-shrub model of TotalHerbaceousCover; \n (models with predictions with modeled climate data from model BNU-ESM model - \n models with predictions from contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model1)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model1)[c(2,4)])

hist_deltas_model1 <-  ggplot(predDeltas_model1) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model2 <-  plotObs_GS_totHerb_bestLambdaFuture2_2 - plotObs_GS_totHerb_2 

map_deltas_model2 <- ggplot() +
geom_spatraster(data = predDeltas_model2) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model2)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for \n grass-shrub model of TotalHerbaceousCover; \n (models with predictions with modeled climate data from model IPSL-CM5A-MR model - \n models with predictions from contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model2)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model2)[c(2,4)])

hist_deltas_model2 <-  ggplot(predDeltas_model2) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

## conglomerate figure

  ggarrange(map_obs_GS_totHerb, hist_obs, heights = c(3,1), ncol = 1, nrow  = 2)

  # plot model forecasts with model that does not exclude anomalies
       ggarrange(map_bestLambda_GS_totHerb, map_bestLambda_GS_totHerb_future1, map_bestLambda_GS_totHerb_future2,
              hist, hist_bestlambdaFuture1, hist_bestlambdaFuture2, 
            map_resids_trimAnoms, map_deltas_model1, map_deltas_model2,
            hist_trimAnoms_resids, hist_deltas_model1, hist_deltas_model2,
            heights = c(3,1), ncol = 3, nrow = 4) %>% 
  annotate_figure(fig.lab = "Model Predictions with Contemporary and Forecasted Climate Data", fig.lab.size = 20)
```

### Predict for grass/shrub Total Tree cover - halfSE lambda model
```{r}

# read in model objects (is the trim anomaly version)
  oneSELambdaMod_GS_totTree <- readRDS("/Users/astears/Documents/Dropbox_static/Work/NAU_USGS_postdoc/PED_vegClimModels/Analysis/VegComposition/ModelFitting/models/TotalTreeCover_shrubGrass_noTLP_FALSE_trimAnom_halfSELambdaGLM.rds")

ModelSpec_oneSElambda_GS_totTree <- getModelStatement(coefficientTable = grassShrub_totalTree_trimAnoms,
                                                    modelName <- "coefficientValue_halfseLambda", 
                                                    responseVar <- "TotalTreeCover")

```


This is the **1/2 SE Lambda** model equation if the inputs *are* scaled: 
```{r}
(ModelSpec_oneSElambda_GS_totTree$scaledInputVars_ModelStatement)
```

This is the **1/2 SE Lambda** model equation if the inputs are *not* scaled: 
```{r}
(ModelSpec_oneSElambda_GS_totTree$unscaledInputVars_scaledModelStatement)
```

Predict with model specification for grass/shrub total tree cover
```{r fig.width = 16, fig.height = 18, message = FALSE}
# predict w/ best SE lambda model
bestLambda_GS_totTree_predict <- makePredictions(predictionDF = climDatPred, 
                                                           modelObject = oneSELambdaMod_GS_totTree)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_GS_totTree_predictFuture_1 <- makePredictions(predictionDF = forecastClimSoilsDatPred_1, 
                                                           modelObject = oneSELambdaMod_GS_totTree)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_GS_totTree_predictFuture_2 <- makePredictions(predictionDF = forecastClimSoilsDatPred_2, 
                                                           modelObject = oneSELambdaMod_GS_totTree)

# predict w/ best model
plotObs <- bestLambda_GS_totTree_predict %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "modelPreds", 
                   fun = mean, na.rm = TRUE) #%>% 
   #terra::aggregate(fact = 2, fun = mean, na.rm = TRUE) %>% 
  #terra::crop(ext(-1950000, 1000000, -1800000, 1000000))

# get the extent of this particular raster, and crop it accordingly

plotObs_2 <- plotObs %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

## map best SE lambda predictions for the future model #1
plotObs_bestLambdaFuture1 <- bestLambda_GS_totTree_predictFuture_1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "modelPreds", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture1_2 <- plotObs_bestLambdaFuture1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
## map best SE lambda predictions for the future model #2
plotObs_bestLambdaFuture2 <- bestLambda_GS_totTree_predictFuture_2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "modelPreds", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture2_2 <- plotObs_bestLambdaFuture2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

# get plot of observations
plotObservations_GS_totTree <- modDat_1_s %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Long", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "TotalTreeCover", 
                   fun = mean, na.rm = TRUE)

plotObservations_GS_totTree_2 <- plotObservations_GS_totTree %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
# make figures
map <- ggplot() +
geom_spatraster(data = plotObs_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Predictions of TotalTreeCover in the 
                    grass/shrub ecoregion 
                    using contemporary climate data"),
      subtitle = "1/2 SE Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future1 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Predictions of TotalTreeCover in the 
                    grass/shrub ecoregion
                    using modeled climate data from BNU-ESM model"),
      subtitle = "1/2 SE Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future2 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Predictions of TotalTreeCover in the 
                    grass/shrub ecoregion
                    using modeled climate data from IPSL-CM5A-MR model"),
      subtitle = "1/2 SE Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_obs_GS_totTree <- ggplot() +
  geom_spatraster(data = plotObservations_GS_totTree_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Observations of TotalTreeCover")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

hist <- ggplot(bestLambda_GS_totTree_predict) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = bestLambda_GS_totTree_predict[bestLambda_GS_totTree_predict$newRegion == "dryShrubGrass",],
               aes(x = modelPreds), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture1 <-  ggplot(bestLambda_GS_totTree_predictFuture_1) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = bestLambda_GS_totTree_predictFuture_1[bestLambda_GS_totTree_predictFuture_1$newRegion == "dryShrubGrass",],
               aes(x = modelPreds), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture2 <-  ggplot(bestLambda_GS_totTree_predictFuture_2) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = bestLambda_GS_totTree_predictFuture_2[bestLambda_GS_totTree_predictFuture_2$newRegion == "dryShrubGrass",],
               aes(x = modelPreds), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ylab("frequency")

hist_obs <- ggplot(modDat_1_s) + 
  geom_density(aes(TotalTreeCover), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = modDat_1_s[modDat_1_s$newRegion == "dryShrubGrass",],
               aes(x = TotalTreeCover), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ggtitle("Pink = predictions within 
          the focal ecoregion") +
  ylab("frequency")

## calculate residuals for contemporary prediction
# (observed - predicted)
resids <-  plotObservations_GS_totTree_2 - plotObs_2 
map_resids_trimAnoms <- ggplot() +
geom_spatraster(data = resids) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(resids)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Resids. (obs. - pred.) from the 
                      grass-shrub model of TotalTreeCover"),
     subtitle = "using predictions from the
     1/2 SE Lambda model with contemporary climate data") +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(resids)[c(1,3)]) + 
  ylim(st_bbox(resids)[c(2,4)])

hist_trimAnoms_resids <-  ggplot(resids) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") + 
  geom_vline(aes(xintercept = mean(terra::values(resids$mean), na.rm = TRUE)))

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model1 <-  plotObs_bestLambdaFuture1_2 - plotObs_2 

map_deltas_model1 <- ggplot() +
geom_spatraster(data = predDeltas_model1) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model1)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for \n grass-shrub model of TotalTreeCover; \n (models with predictions with modeled climate data from model BNU-ESM model - \n models with predictions from contemporary climate data)"),
     subtitle = "using predictions from the
     1/2 SE Lambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model1)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model1)[c(2,4)])

hist_deltas_model1 <-  ggplot(predDeltas_model1) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model2 <-  plotObs_bestLambdaFuture2_2 - plotObs_2 

map_deltas_model2 <- ggplot() +
geom_spatraster(data = predDeltas_model2) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model2)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for \n grass-shrub model of TotalTreeCover; \n (models with predictions with modeled climate data from model IPSL-CM5A-MR model - \n models with predictions from contemporary climate data)"),
     subtitle = "using predictions from the 
    1/2 SE Lambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model2)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model2)[c(2,4)])

hist_deltas_model2 <-  ggplot(predDeltas_model2) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

## conglomerate figure

library(ggpubr)
  ggarrange(map_obs_GS_totTree, hist_obs, heights = c(3,1), ncol = 1, nrow  = 2)

  # plot model forecasts with model that does not exclude anomalies
       ggarrange(map, map_bestlambda_future1, map_bestlambda_future2,
              hist, hist_bestlambdaFuture1, hist_bestlambdaFuture2, 
            map_resids_trimAnoms, map_deltas_model1, map_deltas_model2,
            hist_trimAnoms_resids, hist_deltas_model1, hist_deltas_model2,
            heights = c(3,1), ncol = 3, nrow = 4) %>% 
  annotate_figure(fig.lab = "Model Predictions of TotalTreeCover with Contemporary and Forecasted Climate Data", fig.lab.size = 20)
```

### Predict for forest total herbaceous - best lambda model
Read in the objects
```{r}
# read in model objects (is the trim anomaly version)
 bestLambdaMod_F_totHerb <- readRDS("/Users/astears/Documents/Dropbox_static/Work/NAU_USGS_postdoc/PED_vegClimModels/Analysis/VegComposition/ModelFitting/models/TotalHerbaceousCover_forest_noTLP_FALSE_trimAnom_bestLambdaGLM.rds")

ModelSpec_bestLambda_F_totHerb <- getModelStatement(coefficientTable = forest_totalHerb_trimAnoms,
                                                    modelName <- "coefficientValue_bestLambda", 
                                                    responseVar <- "TotalHerbaceousCover")
```

This is the **best Lambda** model equation if the inputs *are* scaled: 
```{r}
(ModelSpec_bestLambda_F_totHerb$scaledInputVars_ModelStatement)
```

This is the **best Lambda** model equation if the inputs are *not* scaled: 
```{r}
(ModelSpec_bestLambda_F_totHerb$unscaledInputVars_scaledModelStatement)
```


Predict
```{r fig.width = 16, fig.height = 18, message = FALSE}
# predict w/ best SE lambda model
bestLambda_F_totHerb_predict <- makePredictions(predictionDF = climDatPred, 
                                                           modelObject = bestLambdaMod_F_totHerb)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_F_totHerb_predictFuture_1 <- makePredictions(predictionDF = forecastClimSoilsDatPred_1, 
                                                           modelObject = bestLambdaMod_F_totHerb)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_F_totHerb_predictFuture_2 <- makePredictions(predictionDF = forecastClimSoilsDatPred_2, 
                                                           modelObject = bestLambdaMod_F_totHerb)

# predict w/ best model
plotObs <- bestLambda_F_totHerb_predict %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "modelPreds", 
                   fun = mean, na.rm = TRUE) #%>% 
   #terra::aggregate(fact = 2, fun = mean, na.rm = TRUE) %>% 
  #terra::crop(ext(-1950000, 1000000, -1800000, 1000000))


plotObs_2 <- plotObs %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

## map best SE lambda predictions for the future model #1
plotObs_bestLambdaFuture1 <- bestLambda_F_totHerb_predictFuture_1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "modelPreds", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture1_2 <- plotObs_bestLambdaFuture1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
## map best SE lambda predictions for the future model #2
plotObs_bestLambdaFuture2 <- bestLambda_F_totHerb_predictFuture_2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "modelPreds", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture2_2 <- plotObs_bestLambdaFuture2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

# get plot of observations
plotObservations_F_totHerb <- modDat_1_s %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Long", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "TotalHerbaceousCover", 
                   fun = mean, na.rm = TRUE)

plotObservations_F_totHerb_2 <- plotObservations_F_totHerb %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
# make figures
map <- ggplot() +
geom_spatraster(data = plotObs_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Predictions of TotalHerbaceousCover in the 
                    forest ecoregion 
                    using contemporary climate data"),
      subtitle = "bestLambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future1 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Predictions of TotalHerbaceousCover in the 
                    forest ecoregion
                    using modeled climate data from BNU-ESM model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future2 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Predictions of TotalHerbaceousCover in the 
                    forest ecoregion
                    using modeled climate data from IPSL-CM5A-MR model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_obs_F_totHerb <- ggplot() +
  geom_spatraster(data = plotObservations_F_totHerb_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Observations of TotalHerbaceousCover")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

hist <- ggplot(bestLambda_F_totHerb_predict) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = bestLambda_F_totHerb_predict[bestLambda_F_totHerb_predict$newRegion %in% c("westForest", "eastForest"),],
               aes(x = modelPreds), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture1 <-  ggplot(bestLambda_F_totHerb_predictFuture_1) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = bestLambda_F_totHerb_predictFuture_1[bestLambda_F_totHerb_predictFuture_1$newRegion == "Forest",],
               aes(x = modelPreds), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture2 <-  ggplot(bestLambda_F_totHerb_predictFuture_2) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = bestLambda_F_totHerb_predictFuture_2[bestLambda_F_totHerb_predictFuture_2$newRegion == "Forest",],
               aes(x = modelPreds), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ylab("frequency")

hist_obs <- ggplot(modDat_1_s) + 
  geom_density(aes(TotalHerbaceousCover), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = modDat_1_s[modDat_1_s$newRegion == "Forest",],
               aes(x = TotalHerbaceousCover), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ggtitle("Pink = predictions within 
          the focal ecoregion") +
  ylab("frequency")

## calculate residuals for contemporary prediction
# (observed - predicted)
resids <-  plotObservations_F_totHerb_2 - plotObs_2 
map_resids_trimAnoms <- ggplot() +
geom_spatraster(data = resids) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(resids)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Resids. (obs. - pred.) from the 
                      Forest model of TotalHerbaceousCover"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model with contemporary climate data") +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(resids)[c(1,3)]) + 
  ylim(st_bbox(resids)[c(2,4)])

hist_trimAnoms_resids <-  ggplot(resids) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") + 
  geom_vline(aes(xintercept = mean(terra::values(resids$mean), na.rm = TRUE)))

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model1 <-  plotObs_bestLambdaFuture1_2 - plotObs_2 

map_deltas_model1 <- ggplot() +
geom_spatraster(data = predDeltas_model1) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model1)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for \n forest model of TotalHerbaceousCover; \n (models with predictions with modeled climate data from model BNU-ESM model - \n models with predictions from contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model1)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model1)[c(2,4)])

hist_deltas_model1 <-  ggplot(predDeltas_model1) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model2 <-  plotObs_bestLambdaFuture2_2 - plotObs_2 

map_deltas_model2 <- ggplot() +
geom_spatraster(data = predDeltas_model2) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model2)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for \n forest model of TotalHerbaceousCover; \n (models with predictions with modeled climate data from model IPSL-CM5A-MR model - \n models with predictions from contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model2)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model2)[c(2,4)])

hist_deltas_model2 <-  ggplot(predDeltas_model2) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

## conglomerate figure

  ggarrange(map_obs_F_totHerb, hist_obs, heights = c(3,1), ncol = 1, nrow  = 2)

  # plot model forecasts with model that does not exclude anomalies
       ggarrange(map, map_bestlambda_future1, map_bestlambda_future2,
              hist, hist_bestlambdaFuture1, hist_bestlambdaFuture2, 
            map_resids_trimAnoms, map_deltas_model1, map_deltas_model2,
            hist_trimAnoms_resids, hist_deltas_model1, hist_deltas_model2,
            heights = c(3,1), ncol = 3, nrow = 4) %>% 
  annotate_figure(fig.lab = "Model Predictions of TotalHerbaceousCover with Contemporary and Forecasted Climate Data", fig.lab.size = 20)
```

### Predict for forest total tree cover - best lambda model
Read in the objects
```{r}
# read in model objects (is the trim anomaly version)
 bestLambdaMod_F_totTree <- readRDS("/Users/astears/Documents/Dropbox_static/Work/NAU_USGS_postdoc/PED_vegClimModels/Analysis/VegComposition/ModelFitting/models/TotalTreeCover_forest_noTLP_FALSE_trimAnom_bestLambdaGLM.rds")

ModelSpec_bestLambda_F_totTree <- getModelStatement(coefficientTable = forest_totalTree_trimAnoms,
                                                    modelName <- "coefficientValue_bestLambda", 
                                                    responseVar <- "TotalTreeCover")

```

This is the **best Lambda** model equation if the inputs *are* scaled: 
```{r}
(ModelSpec_bestLambda_F_totTree$scaledInputVars_ModelStatement)
```

This is the **best Lambda** model equation if the inputs are *not* scaled: 
```{r}
(ModelSpec_bestLambda_F_totTree$unscaledInputVars_scaledModelStatement)
```


Predict
```{r fig.width = 16, fig.height = 18, message = FALSE}
# predict w/ best SE lambda model
bestLambda_F_totTree_predict <- makePredictions(predictionDF = climDatPred, 
                                                           modelObject = bestLambdaMod_F_totTree)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_F_totTree_predictFuture_1 <- makePredictions(predictionDF = forecastClimSoilsDatPred_1, 
                                                           modelObject = bestLambdaMod_F_totTree)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_F_totTree_predictFuture_2 <- makePredictions(predictionDF = forecastClimSoilsDatPred_2, 
                                                           modelObject = bestLambdaMod_F_totTree)

# predict w/ best model
plotObs <- bestLambda_F_totTree_predict %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "modelPreds", 
                   fun = mean, na.rm = TRUE) #%>% 
   #terra::aggregate(fact = 2, fun = mean, na.rm = TRUE) %>% 
  #terra::crop(ext(-1950000, 1000000, -1800000, 1000000))

# get the extent of this particular raster, and crop it accordingly

plotObs_2 <- plotObs %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

## map best SE lambda predictions for the future model #1
plotObs_bestLambdaFuture1 <- bestLambda_F_totTree_predictFuture_1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "modelPreds", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture1_2 <- plotObs_bestLambdaFuture1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
## map best SE lambda predictions for the future model #2
plotObs_bestLambdaFuture2 <- bestLambda_F_totTree_predictFuture_2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "modelPreds", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture2_2 <- plotObs_bestLambdaFuture2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

# get plot of observations
plotObservations_F_totTree <- modDat_1_s %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Long", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "TotalTreeCover", 
                   fun = mean, na.rm = TRUE)

plotObservations_F_totTree_2 <- plotObservations_F_totTree %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
# make figures
map <- ggplot() +
geom_spatraster(data = plotObs_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Predictions of TotalTreeCover in the 
                    forest ecoregion 
                    using contemporary climate data"),
      subtitle = "bestLambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future1 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Predictions of TotalTreeCover in the 
                    forest ecoregion
                    using modeled climate data from BNU-ESM model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future2 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Predictions of TotalTreeCover in the 
                    forest ecoregion
                    using modeled climate data from IPSL-CM5A-MR model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_obs_F_totTree <- ggplot() +
  geom_spatraster(data = plotObservations_F_totTree_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Observations of TotalTreeCover")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

hist <- ggplot(bestLambda_F_totTree_predict) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = bestLambda_F_totTree_predict[bestLambda_F_totTree_predict$newRegion %in% c("westForest", "eastForest"),],
               aes(x = modelPreds), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture1 <-  ggplot(bestLambda_F_totTree_predictFuture_1) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = bestLambda_F_totTree_predictFuture_1[bestLambda_F_totTree_predictFuture_1$newRegion == "Forest",],
               aes(x = modelPreds), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture2 <-  ggplot(bestLambda_F_totTree_predictFuture_2) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = bestLambda_F_totTree_predictFuture_2[bestLambda_F_totTree_predictFuture_2$newRegion == "Forest",],
               aes(x = modelPreds), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ylab("frequency")

hist_obs <- ggplot(modDat_1_s) + 
  geom_density(aes(TotalTreeCover), fill = "lightgrey", col = "darkgrey") + 
  geom_density(data = modDat_1_s[modDat_1_s$newRegion == "Forest",],
               aes(x = TotalTreeCover), fill = "orchid", col = "orchid", alpha = .3) +
  xlab("Predicted Value") + 
  ggtitle("Pink = predictions within 
          the focal ecoregion") +
  ylab("frequency")

## calculate residuals for contemporary prediction
# (observed - predicted)
resids <-  plotObservations_F_totTree_2 - plotObs_2 
map_resids_trimAnoms <- ggplot() +
geom_spatraster(data = resids) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(resids)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Resids. (obs. - pred.) from the 
                      Forest model of TotalTreeCover"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model with contemporary climate data") +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(resids)[c(1,3)]) + 
  ylim(st_bbox(resids)[c(2,4)])

hist_trimAnoms_resids <-  ggplot(resids) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") + 
  geom_vline(aes(xintercept = mean(terra::values(resids$mean), na.rm = TRUE)))

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model1 <-  plotObs_bestLambdaFuture1_2 - plotObs_2 

map_deltas_model1 <- ggplot() +
geom_spatraster(data = predDeltas_model1) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model1)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for \n forest model of TotalTreeCover; \n (models with predictions with modeled climate data from model BNU-ESM model - \n models with predictions from contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model1)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model1)[c(2,4)])

hist_deltas_model1 <-  ggplot(predDeltas_model1) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model2 <-  plotObs_bestLambdaFuture2_2 - plotObs_2 

map_deltas_model2 <- ggplot() +
geom_spatraster(data = predDeltas_model2) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model2)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for \n forest model of TotalTreeCover; \n (models with predictions with modeled climate data from model IPSL-CM5A-MR model - \n models with predictions from contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model2)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model2)[c(2,4)])

hist_deltas_model2 <-  ggplot(predDeltas_model2) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

## conglomerate figure

  ggarrange(map_obs_F_totTree, hist_obs, heights = c(3,1), ncol = 1, nrow  = 2)

  # plot model forecasts with model that does not exclude anomalies
       ggarrange(map, map_bestlambda_future1, map_bestlambda_future2,
              hist, hist_bestlambdaFuture1, hist_bestlambdaFuture2, 
            map_resids_trimAnoms, map_deltas_model1, map_deltas_model2,
            hist_trimAnoms_resids, hist_deltas_model1, hist_deltas_model2,
            heights = c(3,1), ncol = 3, nrow = 4) %>% 
  annotate_figure(fig.lab = "Model Predictions of TotalTreeCover with Contemporary and Forecasted Climate Data", fig.lab.size = 20)
```

### Shrub cover, CONUS-wide - best lambda model
Read in the objects
```{r}
# read in model objects (is the trim anomaly version)
 bestLambdaMod_CONUS_shrub <- readRDS("/Users/astears/Documents/Dropbox_static/Work/NAU_USGS_postdoc/PED_vegClimModels/Analysis/VegComposition/ModelFitting/models/ShrubCover_CONUS_noTLP_FALSE_trimAnom_bestLambdaGLM.rds")

ModelSpec_bestLambda_CONUS_shrub <- getModelStatement(coefficientTable = CONUS_shrub_trimAnoms,
                                                    modelName <- "coefficientValue_bestLambda", 
                                                    responseVar <- "ShrubCover")
```

This is the **best Lambda** model equation if the inputs *are* scaled: 
```{r}
(ModelSpec_bestLambda_CONUS_shrub$scaledInputVars_ModelStatement)
```

This is the **best Lambda** model equation if the inputs are *not* scaled: 
```{r}
(ModelSpec_bestLambda_CONUS_shrub$unscaledInputVars_scaledModelStatement)
```

Predict
```{r fig.width = 16, fig.height = 18, message = FALSE}
# predict w/ best SE lambda model
bestLambda_CONUS_shrub_predict <- makePredictions(predictionDF = climDatPred, 
                                                           modelObject = bestLambdaMod_CONUS_shrub)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_CONUS_shrub_predictFuture_1 <- makePredictions(predictionDF = forecastClimSoilsDatPred_1, 
                                                           modelObject = bestLambdaMod_CONUS_shrub)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_CONUS_shrub_predictFuture_2 <- makePredictions(predictionDF = forecastClimSoilsDatPred_2, 
                                                           modelObject = bestLambdaMod_CONUS_shrub)

# predict w/ best model
plotObs <- bestLambda_CONUS_shrub_predict %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "modelPreds", 
                   fun = mean, na.rm = TRUE) #%>% 
   #terra::aggregate(fact = 2, fun = mean, na.rm = TRUE) %>% 
  #terra::crop(ext(-1950000, 1000000, -1800000, 1000000))

# get the extent of this particular raster, and crop it accordingly

plotObs_2 <- plotObs %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

## map best SE lambda predictions for the future model #1
plotObs_bestLambdaFuture1 <- bestLambda_CONUS_shrub_predictFuture_1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "modelPreds", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture1_2 <- plotObs_bestLambdaFuture1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
## map best SE lambda predictions for the future model #2
plotObs_bestLambdaFuture2 <- bestLambda_CONUS_shrub_predictFuture_2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "modelPreds", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture2_2 <- plotObs_bestLambdaFuture2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

# get plot of observations
plotObservations_CONUS_shrub <- modDat_1_s %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Long", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "ShrubCover", 
                   fun = mean, na.rm = TRUE)

plotObservations_CONUS_shrub_2 <- plotObservations_CONUS_shrub %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
# make figures
map <- ggplot() +
geom_spatraster(data = plotObs_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Predictions of ShrubCover in the 
                    CONUS ecoregion 
                    using contemporary climate data"),
      subtitle = "bestLambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future1 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Predictions of ShrubCover in the 
                    CONUS ecoregion
                    using modeled climate data from BNU-ESM model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future2 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Predictions of ShrubCover in the 
                    CONUS ecoregion
                    using modeled climate data from IPSL-CM5A-MR model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_obs_CONUS_shrub <- ggplot() +
  geom_spatraster(data = plotObservations_CONUS_shrub_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Observations of ShrubCover")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

hist <- ggplot(bestLambda_CONUS_shrub_predict) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture1 <-  ggplot(bestLambda_CONUS_shrub_predictFuture_1) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture2 <-  ggplot(bestLambda_CONUS_shrub_predictFuture_2) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_obs <- ggplot(modDat_1_s) + 
  geom_density(aes(ShrubCover), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ggtitle("Pink = predictions within 
          the focal ecoregion") +
  ylab("frequency")

## calculate residuals for contemporary prediction
# (observed - predicted)
resids <-  plotObservations_CONUS_shrub_2 - plotObs_2 
map_resids_trimAnoms <- ggplot() +
geom_spatraster(data = resids) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(resids)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Resids. (obs. - pred.) from the 
                      CONUS model of ShrubCover"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model with contemporary climate data") +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(resids)[c(1,3)]) + 
  ylim(st_bbox(resids)[c(2,4)])

hist_trimAnoms_resids <-  ggplot(resids) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") + 
  geom_vline(aes(xintercept = mean(terra::values(resids$mean), na.rm = TRUE)))

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model1 <-  plotObs_bestLambdaFuture1_2 - plotObs_2 

map_deltas_model1 <- ggplot() +
geom_spatraster(data = predDeltas_model1) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model1)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for \n CONUS-wide model of ShrubCover; \n (models with predictions with modeled climate data from model BNU-ESM model - \n models with predictions from contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model1)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model1)[c(2,4)])

hist_deltas_model1 <-  ggplot(predDeltas_model1) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model2 <-  plotObs_bestLambdaFuture2_2 - plotObs_2 

map_deltas_model2 <- ggplot() +
geom_spatraster(data = predDeltas_model2) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model2)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for \n CONUS-wide model of ShrubCover; \n (models with predictions with modeled climate data from model IPSL-CM5A-MR model - \n models with predictions from contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model2)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model2)[c(2,4)])

hist_deltas_model2 <-  ggplot(predDeltas_model2) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

## conglomerate figure

  ggarrange(map_obs_CONUS_shrub, hist_obs, heights = c(3,1), ncol = 1, nrow  = 2)

  # plot model forecasts with model that does not exclude anomalies
       ggarrange(map, map_bestlambda_future1, map_bestlambda_future2,
              hist, hist_bestlambdaFuture1, hist_bestlambdaFuture2, 
            map_resids_trimAnoms, map_deltas_model1, map_deltas_model2,
            hist_trimAnoms_resids, hist_deltas_model1, hist_deltas_model2,
            heights = c(3,1), ncol = 3, nrow = 4) %>% 
  annotate_figure(fig.lab = "Model Predictions of ShrubCover with Contemporary and Forecasted Climate Data", fig.lab.size = 20)
```


### Bare Ground Cover cover, CONUS-wide - 1SE lambda model
Read in the objects
```{r}
# read in model objects (is the trim anomaly version)
 oneSELambdaMod_CONUS_bareGround <- readRDS("/Users/astears/Documents/Dropbox_static/Work/NAU_USGS_postdoc/PED_vegClimModels/Analysis/VegComposition/ModelFitting/models/BareGroundCover_CONUS_noTLP_FALSE_trimAnom_oneSELambdaGLM.rds")

ModelSpec_oneSELambdaMod_CONUS_bareGround <- getModelStatement(coefficientTable = CONUS_bareGround_trimAnoms,
                                                    modelName <- "coefficientValue_1seLambda", 
                                                    responseVar <- "BareGroundCover")
```

This is the **best Lambda** model equation if the inputs *are* scaled: 
```{r}
(ModelSpec_oneSELambdaMod_CONUS_bareGround$scaledInputVars_ModelStatement)
```

This is the **best Lambda** model equation if the inputs are *not* scaled: 
```{r}
(ModelSpec_oneSELambdaMod_CONUS_bareGround$unscaledInputVars_scaledModelStatement)
```

Predict
```{r fig.width = 16, fig.height = 18, message = FALSE}
# predict w/ best SE lambda model
bestLambda_CONUS_bareGround_predict <- makePredictions(predictionDF = climDatPred, 
                                                           modelObject = oneSELambdaMod_CONUS_bareGround)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_CONUS_bareGround_predictFuture_1 <- makePredictions(predictionDF = forecastClimSoilsDatPred_1, 
                                                           modelObject = oneSELambdaMod_CONUS_bareGround)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_CONUS_bareGround_predictFuture_2 <- makePredictions(predictionDF = forecastClimSoilsDatPred_2, 
                                                           modelObject = oneSELambdaMod_CONUS_bareGround)

# predict w/ best model
plotObs <- bestLambda_CONUS_bareGround_predict %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "modelPreds", 
                   fun = mean, na.rm = TRUE) #%>% 
   #terra::aggregate(fact = 2, fun = mean, na.rm = TRUE) %>% 
  #terra::crop(ext(-1950000, 1000000, -1800000, 1000000))

# get the extent of this particular raster, and crop it accordingly

plotObs_2 <- plotObs %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

## map best SE lambda predictions for the future model #1
plotObs_bestLambdaFuture1 <- bestLambda_CONUS_bareGround_predictFuture_1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "modelPreds", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture1_2 <- plotObs_bestLambdaFuture1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
## map best SE lambda predictions for the future model #2
plotObs_bestLambdaFuture2 <- bestLambda_CONUS_bareGround_predictFuture_2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "modelPreds", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture2_2 <- plotObs_bestLambdaFuture2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

# get plot of observations
plotObservations_CONUS_bareGround <- modDat_1_s %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Long", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "BareGroundCover", 
                   fun = mean, na.rm = TRUE)

plotObservations_CONUS_bareGround_2 <- plotObservations_CONUS_bareGround %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
# make figures
map <- ggplot() +
geom_spatraster(data = plotObs_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Predictions of BareGroundCover in the 
                    CONUS ecoregion 
                    using contemporary climate data"),
      subtitle = "bestLambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future1 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Predictions of BareGroundCover in the 
                    CONUS ecoregion
                    using modeled climate data from BNU-ESM model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future2 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Predictions of BareGroundCover in the 
                    CONUS ecoregion
                    using modeled climate data from IPSL-CM5A-MR model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_obs_CONUS_bareGround <- ggplot() +
  geom_spatraster(data = plotObservations_CONUS_bareGround_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Observations of BareGroundCover")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

hist <- ggplot(bestLambda_CONUS_bareGround_predict) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture1 <-  ggplot(bestLambda_CONUS_bareGround_predictFuture_1) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture2 <-  ggplot(bestLambda_CONUS_bareGround_predictFuture_2) + 
  geom_density(aes(modelPreds), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_obs <- ggplot(modDat_1_s) + 
  geom_density(aes(BareGroundCover), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ggtitle("Pink = predictions within 
          the focal ecoregion") +
  ylab("frequency")

## calculate residuals for contemporary prediction
# (observed - predicted)
resids <-  plotObservations_CONUS_bareGround_2 - plotObs_2 
map_resids_trimAnoms <- ggplot() +
geom_spatraster(data = resids) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(resids)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Resids. (obs. - pred.) from the 
                      CONUS model of BareGroundCover"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model with contemporary climate data") +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(resids)[c(1,3)]) + 
  ylim(st_bbox(resids)[c(2,4)])

hist_trimAnoms_resids <-  ggplot(resids) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") + 
  geom_vline(aes(xintercept = mean(terra::values(resids$mean), na.rm = TRUE)))

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model1 <-  plotObs_bestLambdaFuture1_2 - plotObs_2 

map_deltas_model1 <- ggplot() +
geom_spatraster(data = predDeltas_model1) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model1)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for \n CONUS-wide model of BareGroundCover; \n (models with predictions with modeled climate data from model BNU-ESM model - \n models with predictions from contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model1)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model1)[c(2,4)])

hist_deltas_model1 <-  ggplot(predDeltas_model1) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model2 <-  plotObs_bestLambdaFuture2_2 - plotObs_2 

map_deltas_model2 <- ggplot() +
geom_spatraster(data = predDeltas_model2) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model2)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for \n CONUS-wide model of BareGroundCover; \n (models with predictions with modeled climate data from model IPSL-CM5A-MR model - \n models with predictions from contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model2)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model2)[c(2,4)])

hist_deltas_model2 <-  ggplot(predDeltas_model2) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

## conglomerate figure

  ggarrange(map_obs_CONUS_bareGround, hist_obs, heights = c(3,1), ncol = 1, nrow  = 2)

  # plot model forecasts with model that does not exclude anomalies
       ggarrange(map, map_bestlambda_future1, map_bestlambda_future2,
              hist, hist_bestlambdaFuture1, hist_bestlambdaFuture2, 
            map_resids_trimAnoms, map_deltas_model1, map_deltas_model2,
            hist_trimAnoms_resids, hist_deltas_model1, hist_deltas_model2,
            heights = c(3,1), ncol = 3, nrow = 4) %>% 
  annotate_figure(fig.lab = "Model Predictions of BareGroundCover with Contemporary and Forecasted Climate Data", fig.lab.size = 20)
```


## Predict for 'level 2' of cover types 
## C3 as proportion of total herbaceous, CONUS-wide - 1SE lambda model
Read in the objects
```{r}
# read in model objects (is the trim anomaly version)
 oneSELambdaMod_CONUS_C3 <- readRDS("/Users/astears/Documents/Dropbox_static/Work/NAU_USGS_postdoc/PED_vegClimModels/Analysis/VegComposition/ModelFitting/models/C3GramCover_prop_CONUS_noTLP_FALSE_trimAnom_oneSELambdaGLM.rds")

ModelSpec_oneSELambdaMod_CONUS_C3 <- getModelStatement(coefficientTable = CONUS_c3_trimAnoms,
                                                    modelName <- "coefficientValue_1seLambda", 
                                                    responseVar <- "c3 cover percentage")
```

This is the **best Lambda** model equation if the inputs *are* scaled: 
```{r}
(ModelSpec_oneSELambdaMod_CONUS_C3$scaledInputVars_ModelStatement)
```

This is the **best Lambda** model equation if the inputs are *not* scaled: 
```{r}
(ModelSpec_oneSELambdaMod_CONUS_C3$unscaledInputVars_scaledModelStatement)
```

Predict
```{r fig.width = 16, fig.height = 18, message = FALSE}
# predict w/ best SE lambda model
bestLambda_CONUS_C3_predict <- makePredictions(predictionDF = climDatPred, 
                                                           modelObject = oneSELambdaMod_CONUS_C3)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_CONUS_C3_predictFuture_1 <- makePredictions(predictionDF = forecastClimSoilsDatPred_1, 
                                                           modelObject = oneSELambdaMod_CONUS_C3)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_CONUS_C3_predictFuture_2 <- makePredictions(predictionDF = forecastClimSoilsDatPred_2, 
modelObject = oneSELambdaMod_CONUS_C3)
```

## C4 as proportion of total herbaceous, CONUS-wide - 1SE lambda model
Read in the objects
```{r}
# read in model objects (is the trim anomaly version)
 oneSELambdaMod_CONUS_C4 <- readRDS("/Users/astears/Documents/Dropbox_static/Work/NAU_USGS_postdoc/PED_vegClimModels/Analysis/VegComposition/ModelFitting/models/C4GramCover_prop_CONUS_noTLP_FALSE_trimAnom_oneSELambdaGLM.rds")

ModelSpec_oneSELambdaMod_CONUS_C4 <- getModelStatement(coefficientTable = CONUS_c4_trimAnoms,
                                                    modelName <- "coefficientValue_1seLambda", 
                                                    responseVar <- "c4 cover percentage")
```

This is the **best Lambda** model equation if the inputs *are* scaled: 
```{r}
(ModelSpec_oneSELambdaMod_CONUS_C4$scaledInputVars_ModelStatement)
```

This is the **best Lambda** model equation if the inputs are *not* scaled: 
```{r}
(ModelSpec_oneSELambdaMod_CONUS_C4$unscaledInputVars_scaledModelStatement)
```

Predict
```{r fig.width = 16, fig.height = 18, message = FALSE}
# predict w/ best SE lambda model
bestLambda_CONUS_C4_predict <- makePredictions(predictionDF = climDatPred, 
                                                           modelObject = oneSELambdaMod_CONUS_C4)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_CONUS_C4_predictFuture_1 <- makePredictions(predictionDF = forecastClimSoilsDatPred_1, 
                                                           modelObject = oneSELambdaMod_CONUS_C4)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_CONUS_C4_predictFuture_2 <- makePredictions(predictionDF = forecastClimSoilsDatPred_2, 
modelObject = oneSELambdaMod_CONUS_C4)
```

## forb as proportion of total herbaceous, CONUS-wide - 1SE lambda model
Read in the objects
```{r}
# read in model objects (is the trim anomaly version)
 oneSELambdaMod_CONUS_forb <- readRDS("/Users/astears/Documents/Dropbox_static/Work/NAU_USGS_postdoc/PED_vegClimModels/Analysis/VegComposition/ModelFitting/models/ForbCover_prop_CONUS_noTLP_FALSE_trimAnom_oneSELambdaGLM.rds")

ModelSpec_oneSELambdaMod_CONUS_forb <- getModelStatement(coefficientTable = CONUS_forb_trimAnoms,
                                                    modelName <- "coefficientValue_1seLambda", 
                                                    responseVar <- "forb cover percentage")
```

This is the **best Lambda** model equation if the inputs *are* scaled: 
```{r}
(ModelSpec_oneSELambdaMod_CONUS_forb$scaledInputVars_ModelStatement)
```

This is the **best Lambda** model equation if the inputs are *not* scaled: 
```{r}
(ModelSpec_oneSELambdaMod_CONUS_forb$unscaledInputVars_scaledModelStatement)
```

Predict
```{r fig.width = 16, fig.height = 18, message = FALSE}
# predict w/ best SE lambda model
bestLambda_CONUS_forb_predict <- makePredictions(predictionDF = climDatPred, 
                                                           modelObject = oneSELambdaMod_CONUS_forb)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_CONUS_forb_predictFuture_1 <- makePredictions(predictionDF = forecastClimSoilsDatPred_1, 
                                                           modelObject = oneSELambdaMod_CONUS_forb)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_CONUS_forb_predictFuture_2 <- makePredictions(predictionDF = forecastClimSoilsDatPred_2, 
modelObject = oneSELambdaMod_CONUS_forb)
```

## needle-leaved tree as proportion of total tree, forest - best lambda model
Read in the objects
```{r}
# read in model objects (is the trim anomaly version)
 bestLambdaMod_forest_needleLeavedTree <- readRDS("/Users/astears/Documents/Dropbox_static/Work/NAU_USGS_postdoc/PED_vegClimModels/Analysis/VegComposition/ModelFitting/models/ConifTreeCover_prop_forest_noTLP_FALSE_bestLambdaGLM.rds")

ModelSpec_bestLambdaMod_forest_needleLeavedTree <- getModelStatement(coefficientTable = forest_needleLeavedTree_trimAnoms,
                                                    modelName <- "coefficientValue_bestLambda", 
                                                    responseVar <- "needleLeavedTree cover percentage")
```

This is the **best Lambda** model equation if the inputs *are* scaled: 
```{r}
(ModelSpec_bestLambdaMod_forest_needleLeavedTree$scaledInputVars_ModelStatement)
```

This is the **best Lambda** model equation if the inputs are *not* scaled: 
```{r}
(ModelSpec_bestLambdaMod_forest_needleLeavedTree$unscaledInputVars_scaledModelStatement)
```

Predict
```{r fig.width = 16, fig.height = 18, message = FALSE}
# predict w/ best SE lambda model
bestLambda_forest_needleLeavedTree_predict <- makePredictions(predictionDF = climDatPred, 
                                                           modelObject = bestLambdaMod_forest_needleLeavedTree)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_forest_needleLeavedTree_predictFuture_1 <- makePredictions(predictionDF = forecastClimSoilsDatPred_1, 
                                                           modelObject = bestLambdaMod_forest_needleLeavedTree)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_forest_needleLeavedTree_predictFuture_2 <- makePredictions(predictionDF = forecastClimSoilsDatPred_2, 
modelObject = bestLambdaMod_forest_needleLeavedTree)
```


## needle-leaved tree as proportion of total tree, grass/shrub - best lambda model
Read in the objects
```{r}
# read in model objects (is the trim anomaly version)
 bestLambdaMod_grassShrub_needleLeavedTree <- readRDS("/Users/astears/Documents/Dropbox_static/Work/NAU_USGS_postdoc/PED_vegClimModels/Analysis/VegComposition/ModelFitting/models/ConifTreeCover_prop_shrubGrass_noTLP_FALSE_bestLambdaGLM.rds")

ModelSpec_bestLambdaMod_grassShrub_needleLeavedTree <- getModelStatement(coefficientTable = grassShrub_needleLeavedTree_trimAnoms,
                                                    modelName <- "coefficientValue_bestLambda", 
                                                    responseVar <- "needleLeavedTree cover percentage")
```

This is the **best Lambda** model equation if the inputs *are* scaled: 
```{r}
(ModelSpec_bestLambdaMod_grassShrub_needleLeavedTree$scaledInputVars_ModelStatement)
```

This is the **best Lambda** model equation if the inputs are *not* scaled: 
```{r}
(ModelSpec_bestLambdaMod_grassShrub_needleLeavedTree$unscaledInputVars_scaledModelStatement)
```

Predict
```{r fig.width = 16, fig.height = 18, message = FALSE}
# predict w/ best SE lambda model
bestLambda_grassShrub_needleLeavedTree_predict <- makePredictions(predictionDF = climDatPred, 
                                                           modelObject = bestLambdaMod_grassShrub_needleLeavedTree)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_grassShrub_needleLeavedTree_predictFuture_1 <- makePredictions(predictionDF = forecastClimSoilsDatPred_1, 
                                                           modelObject = bestLambdaMod_grassShrub_needleLeavedTree)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_grassShrub_needleLeavedTree_predictFuture_2 <- makePredictions(predictionDF = forecastClimSoilsDatPred_2, 
modelObject = bestLambdaMod_grassShrub_needleLeavedTree)
```

## broad-leaved tree as proportion of total tree, forest - best lambda model
Read in the objects
```{r}
# read in model objects (is the trim anomaly version)
 bestLambdaMod_forest_broadLeavedTree <- readRDS("/Users/astears/Documents/Dropbox_static/Work/NAU_USGS_postdoc/PED_vegClimModels/Analysis/VegComposition/ModelFitting/models/AngioTreeCover_prop_forest_noTLP_FALSE_trimAnom_bestLambdaGLM.rds")

ModelSpec_bestLambdaMod_forest_broadLeavedTree <- getModelStatement(coefficientTable = forest_broadLeavedTree_trimAnoms,
                                                    modelName <- "coefficientValue_bestLambda", 
                                                    responseVar <- "broadLeavedTree cover percentage")
```

This is the **best Lambda** model equation if the inputs *are* scaled: 
```{r}
(ModelSpec_bestLambdaMod_forest_broadLeavedTree$scaledInputVars_ModelStatement)
```

This is the **best Lambda** model equation if the inputs are *not* scaled: 
```{r}
(ModelSpec_bestLambdaMod_forest_broadLeavedTree$unscaledInputVars_scaledModelStatement)
```

Predict
```{r fig.width = 16, fig.height = 18, message = FALSE}
# predict w/ best SE lambda model
bestLambda_forest_broadLeavedTree_predict <- makePredictions(predictionDF = climDatPred, 
                                                           modelObject = bestLambdaMod_forest_broadLeavedTree)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_forest_broadLeavedTree_predictFuture_1 <- makePredictions(predictionDF = forecastClimSoilsDatPred_1, 
                                                           modelObject = bestLambdaMod_forest_broadLeavedTree)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_forest_broadLeavedTree_predictFuture_2 <- makePredictions(predictionDF = forecastClimSoilsDatPred_2, 
modelObject = bestLambdaMod_forest_broadLeavedTree)
```

## broad-leaved tree as proportion of total tree, grassShrub - best lambda model
Read in the objects
```{r}
# read in model objects (is the trim anomaly version)
 bestLambdaMod_grassShrub_broadLeavedTree <- readRDS("/Users/astears/Documents/Dropbox_static/Work/NAU_USGS_postdoc/PED_vegClimModels/Analysis/VegComposition/ModelFitting/models/AngioTreeCover_prop_shrubGrass_noTLP_FALSE_trimAnom_bestLambdaGLM.rds")

ModelSpec_bestLambdaMod_grassShrub_broadLeavedTree <- getModelStatement(coefficientTable = grassShrub_broadLeavedTree_trimAnoms,
                                                    modelName <- "coefficientValue_bestLambda", 
                                                    responseVar <- "broadLeavedTree cover percentage")
```

This is the **best Lambda** model equation if the inputs *are* scaled: 
```{r}
(ModelSpec_bestLambdaMod_grassShrub_broadLeavedTree$scaledInputVars_ModelStatement)
```

This is the **best Lambda** model equation if the inputs are *not* scaled: 
```{r}
(ModelSpec_bestLambdaMod_grassShrub_broadLeavedTree$unscaledInputVars_scaledModelStatement)
```

Predict
```{r fig.width = 16, fig.height = 18, message = FALSE}
# predict w/ best SE lambda model
bestLambda_grassShrub_broadLeavedTree_predict <- makePredictions(predictionDF = climDatPred, 
                                                           modelObject = bestLambdaMod_grassShrub_broadLeavedTree)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_grassShrub_broadLeavedTree_predictFuture_1 <- makePredictions(predictionDF = forecastClimSoilsDatPred_1, 
                                                           modelObject = bestLambdaMod_grassShrub_broadLeavedTree)
# predict with best SE lambda model w/ forecasted climate data
bestLambda_grassShrub_broadLeavedTree_predictFuture_2 <- makePredictions(predictionDF = forecastClimSoilsDatPred_2, 
modelObject = bestLambdaMod_grassShrub_broadLeavedTree)
```

## Combine the level 2 cover variables (combine and scale to sum to 100 - for both total herbaceous and total tree cover)
```{r}
# for contemporary data
names(bestLambda_CONUS_C3_predict)[57] <- "C3_percentage_pred"
names(bestLambda_CONUS_C4_predict)[57] <- "C4_percentage_pred"
names(bestLambda_CONUS_forb_predict)[57] <- "forb_percentage_pred"
names(bestLambda_grassShrub_broadLeavedTree_predict)[57] <- "broadLeavedTree_grassShrub_percentage_pred"
names(bestLambda_forest_broadLeavedTree_predict)[57] <- "broadLeavedTree_forest_percentage_pred"
names(bestLambda_grassShrub_needleLeavedTree_predict)[57] <- "needleLeavedTree_grassShrub_percentage_pred"
names(bestLambda_forest_needleLeavedTree_predict)[57] <- "needleLeavedTree_forest_percentage_pred"

level2_cover_preds_contemp <- bestLambda_CONUS_C3_predict %>% 
  left_join(bestLambda_CONUS_C4_predict) %>% 
  left_join(bestLambda_CONUS_forb_predict) %>% 
  left_join(bestLambda_grassShrub_broadLeavedTree_predict) %>% 
  left_join(bestLambda_forest_broadLeavedTree_predict) %>% 
  left_join(bestLambda_grassShrub_needleLeavedTree_predict) %>% 
  left_join(bestLambda_forest_needleLeavedTree_predict) 

level2_cover_preds_contemp <- level2_cover_preds_contemp %>% 
  mutate("sumFromModels_totalHerbaceousCover" = C3_percentage_pred +  C4_percentage_pred + forb_percentage_pred, 
         "sumFromModels_forest_totalTreeCover" = broadLeavedTree_forest_percentage_pred + needleLeavedTree_forest_percentage_pred,  
         "sumFromModels_grassShrub_totalTreeCover" = broadLeavedTree_grassShrub_percentage_pred + needleLeavedTree_grassShrub_percentage_pred) %>% 
  mutate(C3_percentage_scaled = (C3_percentage_pred/sumFromModels_totalHerbaceousCover)*100,
         C4_percentage_scaled = (C4_percentage_pred/sumFromModels_totalHerbaceousCover)*100,
         forb_percentage_scaled = (forb_percentage_pred/sumFromModels_totalHerbaceousCover)*100,
         broadLeavedTree_forest_percentage_scaled = (broadLeavedTree_forest_percentage_pred/sumFromModels_forest_totalTreeCover)*100,
         needleLeavedTree_forest_percentage_scaled = (needleLeavedTree_forest_percentage_pred/sumFromModels_forest_totalTreeCover)*100,
         broadLeavedTree_grassShrub_percentage_scaled = (broadLeavedTree_grassShrub_percentage_pred/sumFromModels_grassShrub_totalTreeCover)*100,
         needleLeavedTree_grassShrub_percentage_scaled = (needleLeavedTree_grassShrub_percentage_pred/sumFromModels_grassShrub_totalTreeCover)*100)
  
# for future model 1
names(bestLambda_CONUS_C3_predictFuture_1)[55] <- "C3_percentage_pred"
names(bestLambda_CONUS_C4_predictFuture_1)[55] <- "C4_percentage_pred"
names(bestLambda_CONUS_forb_predictFuture_1)[55] <- "forb_percentage_pred"
names(bestLambda_grassShrub_broadLeavedTree_predictFuture_1)[55] <- "broadLeavedTree_grassShrub_percentage_pred"
names(bestLambda_forest_broadLeavedTree_predictFuture_1)[55] <- "broadLeavedTree_forest_percentage_pred"
names(bestLambda_grassShrub_needleLeavedTree_predictFuture_1)[55] <- "needleLeavedTree_grassShrub_percentage_pred"
names(bestLambda_forest_needleLeavedTree_predictFuture_1)[55] <- "needleLeavedTree_forest_percentage_pred"

level2_cover_preds_future1 <- bestLambda_CONUS_C3_predictFuture_1 %>% 
  left_join(bestLambda_CONUS_C4_predictFuture_1) %>% 
  left_join(bestLambda_CONUS_forb_predictFuture_1) %>% 
  left_join(bestLambda_grassShrub_broadLeavedTree_predictFuture_1) %>% 
  left_join(bestLambda_forest_broadLeavedTree_predictFuture_1) %>% 
  left_join(bestLambda_grassShrub_needleLeavedTree_predictFuture_1) %>% 
  left_join(bestLambda_forest_needleLeavedTree_predictFuture_1) 

level2_cover_preds_future1 <- level2_cover_preds_future1 %>% 
  mutate("sumFromModels_totalHerbaceousCover" = C3_percentage_pred +  C4_percentage_pred + forb_percentage_pred, 
         "sumFromModels_forest_totalTreeCover" = broadLeavedTree_forest_percentage_pred + needleLeavedTree_forest_percentage_pred,  
         "sumFromModels_grassShrub_totalTreeCover" = broadLeavedTree_grassShrub_percentage_pred + needleLeavedTree_grassShrub_percentage_pred) %>% 
  mutate(C3_percentage_scaled = (C3_percentage_pred/sumFromModels_totalHerbaceousCover)*100,
         C4_percentage_scaled = (C4_percentage_pred/sumFromModels_totalHerbaceousCover)*100,
         forb_percentage_scaled = (forb_percentage_pred/sumFromModels_totalHerbaceousCover)*100,
         broadLeavedTree_forest_percentage_scaled = (broadLeavedTree_forest_percentage_pred/sumFromModels_forest_totalTreeCover)*100,
         needleLeavedTree_forest_percentage_scaled = (needleLeavedTree_forest_percentage_pred/sumFromModels_forest_totalTreeCover)*100,
         broadLeavedTree_grassShrub_percentage_scaled = (broadLeavedTree_grassShrub_percentage_pred/sumFromModels_grassShrub_totalTreeCover)*100,
         needleLeavedTree_grassShrub_percentage_scaled = (needleLeavedTree_grassShrub_percentage_pred/sumFromModels_grassShrub_totalTreeCover)*100)
  
# for model 2
names(bestLambda_CONUS_C3_predictFuture_2)[55] <- "C3_percentage_pred"
names(bestLambda_CONUS_C4_predictFuture_2)[55] <- "C4_percentage_pred"
names(bestLambda_CONUS_forb_predictFuture_2)[55] <- "forb_percentage_pred"
names(bestLambda_grassShrub_broadLeavedTree_predictFuture_2)[55] <- "broadLeavedTree_grassShrub_percentage_pred"
names(bestLambda_forest_broadLeavedTree_predictFuture_2)[55] <- "broadLeavedTree_forest_percentage_pred"
names(bestLambda_grassShrub_needleLeavedTree_predictFuture_2)[55] <- "needleLeavedTree_grassShrub_percentage_pred"
names(bestLambda_forest_needleLeavedTree_predictFuture_2)[55] <- "needleLeavedTree_forest_percentage_pred"

level2_cover_preds_future2 <- bestLambda_CONUS_C3_predictFuture_2 %>% 
  left_join(bestLambda_CONUS_C4_predictFuture_2) %>% 
  left_join(bestLambda_CONUS_forb_predictFuture_2) %>% 
  left_join(bestLambda_grassShrub_broadLeavedTree_predictFuture_2) %>% 
  left_join(bestLambda_forest_broadLeavedTree_predictFuture_2) %>% 
  left_join(bestLambda_grassShrub_needleLeavedTree_predictFuture_2) %>% 
  left_join(bestLambda_forest_needleLeavedTree_predictFuture_2) 

level2_cover_preds_future2 <- level2_cover_preds_future2 %>% 
  mutate("sumFromModels_totalHerbaceousCover" = C3_percentage_pred +  C4_percentage_pred + forb_percentage_pred, 
         "sumFromModels_forest_totalTreeCover" = broadLeavedTree_forest_percentage_pred + needleLeavedTree_forest_percentage_pred,  
         "sumFromModels_grassShrub_totalTreeCover" = broadLeavedTree_grassShrub_percentage_pred + needleLeavedTree_grassShrub_percentage_pred) %>% 
  mutate(C3_percentage_scaled = (C3_percentage_pred/sumFromModels_totalHerbaceousCover)*100,
         C4_percentage_scaled = (C4_percentage_pred/sumFromModels_totalHerbaceousCover)*100,
         forb_percentage_scaled = (forb_percentage_pred/sumFromModels_totalHerbaceousCover)*100,
         broadLeavedTree_forest_percentage_scaled = (broadLeavedTree_forest_percentage_pred/sumFromModels_forest_totalTreeCover)*100,
         needleLeavedTree_forest_percentage_scaled = (needleLeavedTree_forest_percentage_pred/sumFromModels_forest_totalTreeCover)*100,
         broadLeavedTree_grassShrub_percentage_scaled = (broadLeavedTree_grassShrub_percentage_pred/sumFromModels_grassShrub_totalTreeCover)*100,
         needleLeavedTree_grassShrub_percentage_scaled = (needleLeavedTree_grassShrub_percentage_pred/sumFromModels_grassShrub_totalTreeCover)*100)
```

## visualize the *scaled* level 2 predictions

### C3 cover
```{r fig.width = 16, fig.height = 12}
# predict w/ best model
plotObs <- level2_cover_preds_contemp %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "C3_percentage_scaled", 
                   fun = mean, na.rm = TRUE)
# get the extent of this particular raster, and crop it accordingly

plotObs_2 <- plotObs %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

## map best SE lambda predictions for the future model #1
plotObs_bestLambdaFuture1 <- level2_cover_preds_future1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "C3_percentage_scaled", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture1_2 <- plotObs_bestLambdaFuture1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
## map best SE lambda predictions for the future model #2
plotObs_bestLambdaFuture2 <- level2_cover_preds_future2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "C3_percentage_scaled", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture2_2 <- plotObs_bestLambdaFuture2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

# get plot of observations
plotObservations_C3_proportion <- modDat_1_s %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Long", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "C3GramCover_prop", 
                   fun = mean, na.rm = TRUE)

plotObservations_C3_proportion_2 <- plotObservations_C3_proportion %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
# make figures
map <- ggplot() +
geom_spatraster(data = plotObs_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of C3GramCover_prop in the 
                    CONUS ecoregion 
                    using contemporary climate data"),
      subtitle = "bestLambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future1 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of C3GramCover_prop in the 
                    CONUS ecoregion
                    using modeled climate data from BNU-ESM model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future2 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of C3GramCover_prop in the 
                    CONUS ecoregion
                    using modeled climate data from IPSL-CM5A-MR model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_obs_CONUS_C3 <- ggplot() +
  geom_spatraster(data = plotObservations_C3_proportion_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Observations of the proportion of total herbaceous that is C3GramCover")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

hist <- ggplot(level2_cover_preds_contemp) + 
  geom_density(aes(C3_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture1 <-  ggplot(level2_cover_preds_future1) + 
  geom_density(aes(C3_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture2 <-  ggplot(level2_cover_preds_future1) + 
  geom_density(aes(C3_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_obs <- ggplot(modDat_1_s) + 
  geom_density(aes(C3GramCover_prop), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ggtitle("Pink = predictions within 
          the focal ecoregion") +
  ylab("frequency")

## calculate residuals for contemporary prediction
# (observed - predicted)
resids <-  plotObservations_C3_proportion_2 - plotObs_2 
map_resids_trimAnoms <- ggplot() +
geom_spatraster(data = resids) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(resids)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Resids. (obs. - pred.) from the 
                      CONUS-wide model of C3GramCover_prop"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model with contemporary climate data") +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(resids)[c(1,3)]) + 
  ylim(st_bbox(resids)[c(2,4)])

hist_trimAnoms_resids <-  ggplot(resids) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") + 
  geom_vline(aes(xintercept = mean(terra::values(resids$mean), na.rm = TRUE)))

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model1 <-  plotObs_bestLambdaFuture1_2 - plotObs_2 

map_deltas_model1 <- ggplot() +
geom_spatraster(data = predDeltas_model1) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model1)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for 
                      CONUS-wide model of C3GramCover_prop; (models with 
                      predictions with modeled climate data from model BNU-ESM 
                      model - models with predictions from 
                      contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model1)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model1)[c(2,4)])

hist_deltas_model1 <-  ggplot(predDeltas_model1) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model2 <-  plotObs_bestLambdaFuture2_2 - plotObs_2 

map_deltas_model2 <- ggplot() +
geom_spatraster(data = predDeltas_model2) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model2)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for
  CONUS-wide model of C3GramCover_prop; 
  (models with predictions with modeled 
  climate data from model IPSL-CM5A-MR 
  model- models with predictions from 
  contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model2)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model2)[c(2,4)])

hist_deltas_model2 <-  ggplot(predDeltas_model2) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

## conglomerate figure

  ggarrange(map_obs_CONUS_C3, hist_obs, heights = c(3,1), ncol = 1, nrow  = 2)

  # plot model forecasts with model that does not exclude anomalies
       ggarrange(map, map_bestlambda_future1, map_bestlambda_future2,
              hist, hist_bestlambdaFuture1, hist_bestlambdaFuture2, 
            map_resids_trimAnoms, map_deltas_model1, map_deltas_model2,
            hist_trimAnoms_resids, hist_deltas_model1, hist_deltas_model2,
            heights = c(3,1), ncol = 3, nrow = 4) %>% 
  annotate_figure(fig.lab = "Model Predictions of C3GramCover_prop with Contemporary and Forecasted Climate Data", fig.lab.size = 20)
```

### C4 cover
```{r fig.width = 16, fig.height = 12}
# predict w/ best model
plotObs <- level2_cover_preds_contemp %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "C4_percentage_scaled", 
                   fun = mean, na.rm = TRUE)
# get the extent of this particular raster, and crop it accordingly

plotObs_2 <- plotObs %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

## map best SE lambda predictions for the future model #1
plotObs_bestLambdaFuture1 <- level2_cover_preds_future1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "C4_percentage_scaled", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture1_2 <- plotObs_bestLambdaFuture1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
## map best SE lambda predictions for the future model #2
plotObs_bestLambdaFuture2 <- level2_cover_preds_future2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "C4_percentage_scaled", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture2_2 <- plotObs_bestLambdaFuture2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

# get plot of observations
plotObservations_C4_proportion <- modDat_1_s %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Long", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "C4GramCover_prop", 
                   fun = mean, na.rm = TRUE)

plotObservations_C4_proportion_2 <- plotObservations_C4_proportion %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
# make figures
map <- ggplot() +
geom_spatraster(data = plotObs_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of C4GramCover_prop in the 
                    CONUS ecoregion 
                    using contemporary climate data"),
      subtitle = "bestLambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future1 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of C4GramCover_prop in the 
                    CONUS ecoregion
                    using modeled climate data from BNU-ESM model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future2 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of C4GramCover_prop in the 
                    CONUS ecoregion
                    using modeled climate data from IPSL-CM5A-MR model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_obs_CONUS_C4 <- ggplot() +
  geom_spatraster(data = plotObservations_C4_proportion_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Observations of the proportion of total herbaceous that is C4GramCover")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

hist <- ggplot(level2_cover_preds_contemp) + 
  geom_density(aes(C4_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture1 <-  ggplot(level2_cover_preds_future1) + 
  geom_density(aes(C4_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture2 <-  ggplot(level2_cover_preds_future1) + 
  geom_density(aes(C4_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_obs <- ggplot(modDat_1_s) + 
  geom_density(aes(C4GramCover_prop), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ggtitle("Pink = predictions within 
          the focal ecoregion") +
  ylab("frequency")

## calculate residuals for contemporary prediction
# (observed - predicted)
resids <-  plotObservations_C4_proportion_2 - plotObs_2 
map_resids_trimAnoms <- ggplot() +
geom_spatraster(data = resids) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(resids)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Resids. (obs. - pred.) from the 
                      CONUS-wide model of C4GramCover_prop"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model with contemporary climate data") +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(resids)[c(1,3)]) + 
  ylim(st_bbox(resids)[c(2,4)])

hist_trimAnoms_resids <-  ggplot(resids) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") + 
  geom_vline(aes(xintercept = mean(terra::values(resids$mean), na.rm = TRUE)))

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model1 <-  plotObs_bestLambdaFuture1_2 - plotObs_2 

map_deltas_model1 <- ggplot() +
geom_spatraster(data = predDeltas_model1) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model1)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for 
                      CONUS-wide model of C4GramCover_prop; (models with 
                      predictions with modeled climate data from model BNU-ESM 
                      model - models with predictions from 
                      contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model1)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model1)[c(2,4)])

hist_deltas_model1 <-  ggplot(predDeltas_model1) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model2 <-  plotObs_bestLambdaFuture2_2 - plotObs_2 

map_deltas_model2 <- ggplot() +
geom_spatraster(data = predDeltas_model2) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model2)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for
  CONUS-wide model of C4GramCover_prop; 
  (models with predictions with modeled 
  climate data from model IPSL-CM5A-MR 
  model- models with predictions from 
  contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model2)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model2)[c(2,4)])

hist_deltas_model2 <-  ggplot(predDeltas_model2) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

## conglomerate figure

  ggarrange(map_obs_CONUS_C4, hist_obs, heights = c(3,1), ncol = 1, nrow  = 2)

  # plot model forecasts with model that does not exclude anomalies
       ggarrange(map, map_bestlambda_future1, map_bestlambda_future2,
              hist, hist_bestlambdaFuture1, hist_bestlambdaFuture2, 
            map_resids_trimAnoms, map_deltas_model1, map_deltas_model2,
            hist_trimAnoms_resids, hist_deltas_model1, hist_deltas_model2,
            heights = c(3,1), ncol = 3, nrow = 4) %>% 
  annotate_figure(fig.lab = "Model Predictions of C4GramCover_prop with Contemporary and Forecasted Climate Data", fig.lab.size = 20)
```

### forb cover
```{r fig.width = 16, fig.height = 12}
# predict w/ best model
plotObs <- level2_cover_preds_contemp %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "forb_percentage_scaled", 
                   fun = mean, na.rm = TRUE)
# get the extent of this particular raster, and crop it accordingly

plotObs_2 <- plotObs %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

## map best SE lambda predictions for the future model #1
plotObs_bestLambdaFuture1 <- level2_cover_preds_future1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "forb_percentage_scaled", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture1_2 <- plotObs_bestLambdaFuture1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
## map best SE lambda predictions for the future model #2
plotObs_bestLambdaFuture2 <- level2_cover_preds_future2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "forb_percentage_scaled", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture2_2 <- plotObs_bestLambdaFuture2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

# get plot of observations
plotObservations_forb_proportion <- modDat_1_s %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Long", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "ForbCover_prop", 
                   fun = mean, na.rm = TRUE)

plotObservations_forb_proportion_2 <- plotObservations_forb_proportion %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
# make figures
map <- ggplot() +
geom_spatraster(data = plotObs_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of ForbCover_prop in the 
                    CONUS ecoregion 
                    using contemporary climate data"),
      subtitle = "bestLambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future1 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of ForbCover_prop in the 
                    CONUS ecoregion
                    using modeled climate data from BNU-ESM model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future2 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of ForbCover_prop in the 
                    CONUS ecoregion
                    using modeled climate data from IPSL-CM5A-MR model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_obs_CONUS_forb <- ggplot() +
  geom_spatraster(data = plotObservations_forb_proportion_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Observations of the proportion of total herbaceous that is Forbs")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

hist <- ggplot(level2_cover_preds_contemp) + 
  geom_density(aes(forb_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture1 <-  ggplot(level2_cover_preds_future1) + 
  geom_density(aes(forb_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture2 <-  ggplot(level2_cover_preds_future1) + 
  geom_density(aes(forb_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_obs <- ggplot(modDat_1_s) + 
  geom_density(aes(ForbCover_prop), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ggtitle("Pink = predictions within 
          the focal ecoregion") +
  ylab("frequency")

## calculate residuals for contemporary prediction
# (observed - predicted)
resids <-  plotObservations_forb_proportion_2 - plotObs_2 
map_resids_trimAnoms <- ggplot() +
geom_spatraster(data = resids) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(resids)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Resids. (obs. - pred.) from the 
                      CONUS-wide model of forb cover"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model with contemporary climate data") +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(resids)[c(1,3)]) + 
  ylim(st_bbox(resids)[c(2,4)])

hist_trimAnoms_resids <-  ggplot(resids) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") + 
  geom_vline(aes(xintercept = mean(terra::values(resids$mean), na.rm = TRUE)))

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model1 <-  plotObs_bestLambdaFuture1_2 - plotObs_2 

map_deltas_model1 <- ggplot() +
geom_spatraster(data = predDeltas_model1) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model1)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for 
                      CONUS-wide model of forb cover; (models with 
                      predictions with modeled climate data from model BNU-ESM 
                      model - models with predictions from 
                      contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model1)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model1)[c(2,4)])

hist_deltas_model1 <-  ggplot(predDeltas_model1) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model2 <-  plotObs_bestLambdaFuture2_2 - plotObs_2 

map_deltas_model2 <- ggplot() +
geom_spatraster(data = predDeltas_model2) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model2)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for
  CONUS-wide model of forb cover; 
  (models with predictions with modeled 
  climate data from model IPSL-CM5A-MR 
  model- models with predictions from 
  contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model2)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model2)[c(2,4)])

hist_deltas_model2 <-  ggplot(predDeltas_model2) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

## conglomerate figure

  ggarrange(map_obs_CONUS_forb, hist_obs, heights = c(3,1), ncol = 1, nrow  = 2)

  # plot model forecasts with model that does not exclude anomalies
       ggarrange(map, map_bestlambda_future1, map_bestlambda_future2,
              hist, hist_bestlambdaFuture1, hist_bestlambdaFuture2, 
            map_resids_trimAnoms, map_deltas_model1, map_deltas_model2,
            hist_trimAnoms_resids, hist_deltas_model1, hist_deltas_model2,
            heights = c(3,1), ncol = 3, nrow = 4) %>% 
  annotate_figure(fig.lab = "Model Predictions of forb cover with Contemporary and Forecasted Climate Data", fig.lab.size = 20)
```

### broad-leaved tree cover -- forest
```{r fig.width = 16, fig.height = 12}
# predict w/ best model
plotObs <- level2_cover_preds_contemp %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "broadLeavedTree_forest_percentage_scaled", 
                   fun = mean, na.rm = TRUE)
# get the extent of this particular raster, and crop it accordingly

plotObs_2 <- plotObs %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

## map best SE lambda predictions for the future model #1
plotObs_bestLambdaFuture1 <- level2_cover_preds_future1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "broadLeavedTree_forest_percentage_scaled", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture1_2 <- plotObs_bestLambdaFuture1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
## map best SE lambda predictions for the future model #2
plotObs_bestLambdaFuture2 <- level2_cover_preds_future2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "broadLeavedTree_forest_percentage_scaled", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture2_2 <- plotObs_bestLambdaFuture2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

# get plot of observations
plotObservations_broadLeaved_forest_proportion <- modDat_1_s %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Long", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "AngioTreeCover_prop", 
                   fun = mean, na.rm = TRUE)

plotObservations_broadLeaved_forest_proportion_2 <- plotObservations_broadLeaved_forest_proportion %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
# make figures
map <- ggplot() +
geom_spatraster(data = plotObs_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of Broad-leaved tree cover in the 
                    forest ecoregion 
                    using contemporary climate data"),
      subtitle = "bestLambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future1 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of Broad-leaved tree cover in the 
                    forest ecoregion
                    using modeled climate data from BNU-ESM model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future2 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of Broad-leaved tree cover in the 
                    forest ecoregion
                    using modeled climate data from IPSL-CM5A-MR model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_obs_forest_broadLeavedTree <- ggplot() +
  geom_spatraster(data = plotObservations_broadLeaved_forest_proportion_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Observations of the proportion of total tree cover that is Broad-leaved tree")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

hist <- ggplot(level2_cover_preds_contemp) + 
  geom_density(aes(broadLeavedTree_forest_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture1 <-  ggplot(level2_cover_preds_future1) + 
  geom_density(aes(broadLeavedTree_forest_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture2 <-  ggplot(level2_cover_preds_future1) + 
  geom_density(aes(broadLeavedTree_forest_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_obs <- ggplot(modDat_1_s) + 
  geom_density(aes(AngioTreeCover_prop), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ggtitle("Pink = predictions within 
          the focal ecoregion") +
  ylab("frequency")

## calculate residuals for contemporary prediction
# (observed - predicted)
resids <-  plotObservations_broadLeaved_forest_proportion_2 - plotObs_2 
map_resids_trimAnoms <- ggplot() +
geom_spatraster(data = resids) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(resids)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Resids. (obs. - pred.) from the 
                     forest model of broad-leaved tree cover"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model with contemporary climate data") +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(resids)[c(1,3)]) + 
  ylim(st_bbox(resids)[c(2,4)])

hist_trimAnoms_resids <-  ggplot(resids) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") + 
  geom_vline(aes(xintercept = mean(terra::values(resids$mean), na.rm = TRUE)))

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model1 <-  plotObs_bestLambdaFuture1_2 - plotObs_2 

map_deltas_model1 <- ggplot() +
geom_spatraster(data = predDeltas_model1) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model1)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for 
                      forest model of broad-leaved tree covver; (models with 
                      predictions with modeled climate data from model BNU-ESM 
                      model - models with predictions from 
                      contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model1)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model1)[c(2,4)])

hist_deltas_model1 <-  ggplot(predDeltas_model1) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model2 <-  plotObs_bestLambdaFuture2_2 - plotObs_2 

map_deltas_model2 <- ggplot() +
geom_spatraster(data = predDeltas_model2) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model2)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for
  forest model of broad-leaved tree covver; 
  (models with predictions with modeled 
  climate data from model IPSL-CM5A-MR 
  model- models with predictions from 
  contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model2)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model2)[c(2,4)])

hist_deltas_model2 <-  ggplot(predDeltas_model2) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

## conglomerate figure

  ggarrange(map_obs_forest_broadLeavedTree, hist_obs, heights = c(3,1), ncol = 1, nrow  = 2)

  # plot model forecasts with model that does not exclude anomalies
       ggarrange(map, map_bestlambda_future1, map_bestlambda_future2,
              hist, hist_bestlambdaFuture1, hist_bestlambdaFuture2, 
            map_resids_trimAnoms, map_deltas_model1, map_deltas_model2,
            hist_trimAnoms_resids, hist_deltas_model1, hist_deltas_model2,
            heights = c(3,1), ncol = 3, nrow = 4) %>% 
  annotate_figure(fig.lab = "Model Predictions of broadLeavedTree in forests with Contemporary and Forecasted Climate Data", fig.lab.size = 20)
```

### needle-leaved tree cover -- forest
```{r fig.width = 16, fig.height = 12}
# predict w/ best model
plotObs <- level2_cover_preds_contemp %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "needleLeavedTree_forest_percentage_scaled", 
                   fun = mean, na.rm = TRUE)
# get the extent of this particular raster, and crop it accordingly

plotObs_2 <- plotObs %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

## map best SE lambda predictions for the future model #1
plotObs_bestLambdaFuture1 <- level2_cover_preds_future1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "needleLeavedTree_forest_percentage_scaled", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture1_2 <- plotObs_bestLambdaFuture1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
## map best SE lambda predictions for the future model #2
plotObs_bestLambdaFuture2 <- level2_cover_preds_future2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "needleLeavedTree_forest_percentage_scaled", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture2_2 <- plotObs_bestLambdaFuture2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

# get plot of observations
plotObservations_needleLeaved_proportion <- modDat_1_s %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Long", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "ConifTreeCover_prop", 
                   fun = mean, na.rm = TRUE)

plotObservations_needleLeaved_proportion_2 <- plotObservations_needleLeaved_proportion %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
# make figures
map <- ggplot() +
geom_spatraster(data = plotObs_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of needle-leaved tree cover in the 
                    forest ecoregion 
                    using contemporary climate data"),
      subtitle = "bestLambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future1 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of needle-leaved tree cover in the 
                    forest ecoregion
                    using modeled climate data from BNU-ESM model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future2 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of needle-leaved tree cover in the 
                    forest ecoregion
                    using modeled climate data from IPSL-CM5A-MR model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_obs_CONUS_needleLeavedTree <- ggplot() +
  geom_spatraster(data = plotObservations_needleLeaved_proportion) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Observations of the proportion of total tree cover that is needle-leaved")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

hist <- ggplot(level2_cover_preds_contemp) + 
  geom_density(aes(needleLeavedTree_forest_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture1 <-  ggplot(level2_cover_preds_future1) + 
  geom_density(aes(needleLeavedTree_forest_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture2 <-  ggplot(level2_cover_preds_future1) + 
  geom_density(aes(needleLeavedTree_forest_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_obs <- ggplot(modDat_1_s) + 
  geom_density(aes(ConifTreeCover_prop), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ggtitle("Pink = predictions within 
          the focal ecoregion") +
  ylab("frequency")

## calculate residuals for contemporary prediction
# (observed - predicted)
resids <-  plotObservations_needleLeaved_proportion_2 - plotObs_2 
map_resids_trimAnoms <- ggplot() +
geom_spatraster(data = resids) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(resids)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Resids. (obs. - pred.) from the 
                      forest model of needle-leaved tree cover"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model with contemporary climate data") +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(resids)[c(1,3)]) + 
  ylim(st_bbox(resids)[c(2,4)])

hist_trimAnoms_resids <-  ggplot(resids) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") + 
  geom_vline(aes(xintercept = mean(terra::values(resids$mean), na.rm = TRUE)))

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model1 <-  plotObs_bestLambdaFuture1_2 - plotObs_2 

map_deltas_model1 <- ggplot() +
geom_spatraster(data = predDeltas_model1) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model1)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for 
                      forest model of needle-leaved tree covver; (models with 
                      predictions with modeled climate data from model BNU-ESM 
                      model - models with predictions from 
                      contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model1)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model1)[c(2,4)])

hist_deltas_model1 <-  ggplot(predDeltas_model1) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model2 <-  plotObs_bestLambdaFuture2_2 - plotObs_2 

map_deltas_model2 <- ggplot() +
geom_spatraster(data = predDeltas_model2) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model2)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for
  forest model of needle-leaved tree cover; 
  (models with predictions with modeled 
  climate data from model IPSL-CM5A-MR 
  model- models with predictions from 
  contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model2)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model2)[c(2,4)])

hist_deltas_model2 <-  ggplot(predDeltas_model2) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

## conglomerate figure

  ggarrange(map_obs_CONUS_needleLeavedTree, hist_obs, heights = c(3,1), ncol = 1, nrow  = 2)

  # plot model forecasts with model that does not exclude anomalies
       ggarrange(map, map_bestlambda_future1, map_bestlambda_future2,
              hist, hist_bestlambdaFuture1, hist_bestlambdaFuture2, 
            map_resids_trimAnoms, map_deltas_model1, map_deltas_model2,
            hist_trimAnoms_resids, hist_deltas_model1, hist_deltas_model2,
            heights = c(3,1), ncol = 3, nrow = 4) %>% 
  annotate_figure(fig.lab = "Model Predictions of needleLeavedTree with Forest Model using Contemporary and Forecasted Climate Data", fig.lab.size = 20)
```

### broad-leaved tree cover -- grass/shrub
```{r fig.width = 16, fig.height = 12}
# predict w/ best model
plotObs <- level2_cover_preds_contemp %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "broadLeavedTree_grassShrub_percentage_scaled", 
                   fun = mean, na.rm = TRUE)
# get the extent of this particular raster, and crop it accordingly

plotObs_2 <- plotObs %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

## map best SE lambda predictions for the future model #1
plotObs_bestLambdaFuture1 <- level2_cover_preds_future1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "broadLeavedTree_grassShrub_percentage_scaled", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture1_2 <- plotObs_bestLambdaFuture1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
## map best SE lambda predictions for the future model #2
plotObs_bestLambdaFuture2 <- level2_cover_preds_future2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "broadLeavedTree_grassShrub_percentage_scaled", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture2_2 <- plotObs_bestLambdaFuture2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

# get plot of observations
plotObservations_broadLeaved_grassShrub_proportion <- modDat_1_s %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Long", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "AngioTreeCover_prop", 
                   fun = mean, na.rm = TRUE)

plotObservations_broadLeaved_grassShrub_proportion_2 <- plotObservations_broadLeaved_grassShrub_proportion %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
# make figures
map <- ggplot() +
geom_spatraster(data = plotObs_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of Broad-leaved tree cover in the 
                    grass/shrub ecoregion 
                    using contemporary climate data"),
      subtitle = "bestLambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future1 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of Broad-leaved tree cover in the 
                    grass/shrub ecoregion
                    using modeled climate data from BNU-ESM model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future2 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of Broad-leaved tree cover in the 
                    grass/shrub ecoregion
                    using modeled climate data from IPSL-CM5A-MR model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_obs_grassShrub_broadLeavedTree <- ggplot() +
  geom_spatraster(data = plotObservations_broadLeaved_grassShrub_proportion_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Observations of the proportion of total tree cover that is Broad-leaved tree")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

hist <- ggplot(level2_cover_preds_contemp) + 
  geom_density(aes(broadLeavedTree_grassShrub_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture1 <-  ggplot(level2_cover_preds_future1) + 
  geom_density(aes(broadLeavedTree_grassShrub_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture2 <-  ggplot(level2_cover_preds_future1) + 
  geom_density(aes(broadLeavedTree_grassShrub_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_obs <- ggplot(modDat_1_s) + 
  geom_density(aes(AngioTreeCover_prop), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ggtitle("Pink = predictions within 
          the focal ecoregion") +
  ylab("frequency")

## calculate residuals for contemporary prediction
# (observed - predicted)
resids <-  plotObservations_broadLeaved_grassShrub_proportion_2 - plotObs_2 
map_resids_trimAnoms <- ggplot() +
geom_spatraster(data = resids) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(resids)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Resids. (obs. - pred.) from the 
                     grass/shrub model of broad-leaved tree cover"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model with contemporary climate data") +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(resids)[c(1,3)]) + 
  ylim(st_bbox(resids)[c(2,4)])

hist_trimAnoms_resids <-  ggplot(resids) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") + 
  geom_vline(aes(xintercept = mean(terra::values(resids$mean), na.rm = TRUE)))

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model1 <-  plotObs_bestLambdaFuture1_2 - plotObs_2 

map_deltas_model1 <- ggplot() +
geom_spatraster(data = predDeltas_model1) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model1)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for 
                      grass/shrub model of broad-leaved tree covver; (models with 
                      predictions with modeled climate data from model BNU-ESM 
                      model - models with predictions from 
                      contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model1)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model1)[c(2,4)])

hist_deltas_model1 <-  ggplot(predDeltas_model1) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model2 <-  plotObs_bestLambdaFuture2_2 - plotObs_2 

map_deltas_model2 <- ggplot() +
geom_spatraster(data = predDeltas_model2) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model2)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for
  grass/shrub model of broad-leaved tree covver; 
  (models with predictions with modeled 
  climate data from model IPSL-CM5A-MR 
  model- models with predictions from 
  contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model2)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model2)[c(2,4)])

hist_deltas_model2 <-  ggplot(predDeltas_model2) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

## conglomerate figure

  ggarrange(map_obs_grassShrub_broadLeavedTree, hist_obs, heights = c(3,1), ncol = 1, nrow  = 2)

  # plot model forecasts with model that does not exclude anomalies
       ggarrange(map, map_bestlambda_future1, map_bestlambda_future2,
              hist, hist_bestlambdaFuture1, hist_bestlambdaFuture2, 
            map_resids_trimAnoms, map_deltas_model1, map_deltas_model2,
            hist_trimAnoms_resids, hist_deltas_model1, hist_deltas_model2,
            heights = c(3,1), ncol = 3, nrow = 4) %>% 
  annotate_figure(fig.lab = "Model Predictions of broadLeavedTree in grass/shrub with Contemporary and Forecasted Climate Data", fig.lab.size = 20)
```

### needle-leaved tree cover -- grass/shrub
```{r fig.width = 16, fig.height = 12}
# predict w/ best model
plotObs <- level2_cover_preds_contemp %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "needleLeavedTree_grassShrub_percentage_scaled", 
                   fun = mean, na.rm = TRUE)
# get the extent of this particular raster, and crop it accordingly

plotObs_2 <- plotObs %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

## map best SE lambda predictions for the future model #1
plotObs_bestLambdaFuture1 <- level2_cover_preds_future1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "needleLeavedTree_grassShrub_percentage_scaled", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture1_2 <- plotObs_bestLambdaFuture1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
## map best SE lambda predictions for the future model #2
plotObs_bestLambdaFuture2 <- level2_cover_preds_future2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "needleLeavedTree_grassShrub_percentage_scaled", 
                   fun = mean, na.rm = TRUE)

plotObs_bestLambdaFuture2_2 <- plotObs_bestLambdaFuture2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

# get plot of observations
plotObservations_needleLeaved_proportion <- modDat_1_s %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("Long", "Lat")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                     field = "ConifTreeCover_prop", 
                   fun = mean, na.rm = TRUE)

plotObservations_needleLeaved_proportion_2 <- plotObservations_needleLeaved_proportion %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )
# make figures
map <- ggplot() +
geom_spatraster(data = plotObs_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of needle-leaved tree cover in the 
                    grass/shrub ecoregion 
                    using contemporary climate data"),
      subtitle = "bestLambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future1 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of needle-leaved tree cover in the 
                    grass/shrub ecoregion
                    using modeled climate data from BNU-ESM model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_bestlambda_future2 <- ggplot() +
geom_spatraster(data = plotObs_bestLambdaFuture2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Scaled Predictions of needle-leaved tree cover in the 
                    grass/shrub ecoregion
                    using modeled climate data from IPSL-CM5A-MR model"),
      subtitle = "best Lambda model") +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

map_obs_CONUS_needleLeavedTree <- ggplot() +
  geom_spatraster(data = plotObservations_needleLeaved_proportion) + 
  geom_sf(data = mapRegions, fill = NA, col = "rosybrown4", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Observations of the proportion of total tree cover that is needle-leaved")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

hist <- ggplot(level2_cover_preds_contemp) + 
  geom_density(aes(needleLeavedTree_grassShrub_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture1 <-  ggplot(level2_cover_preds_future1) + 
  geom_density(aes(needleLeavedTree_grassShrub_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_bestlambdaFuture2 <-  ggplot(level2_cover_preds_future1) + 
  geom_density(aes(needleLeavedTree_grassShrub_percentage_scaled), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ylab("frequency")

hist_obs <- ggplot(modDat_1_s) + 
  geom_density(aes(ConifTreeCover_prop), fill = "lightgrey", col = "darkgrey") + 
   xlab("Predicted Value") + 
  ggtitle("Pink = predictions within 
          the focal ecoregion") +
  ylab("frequency")

## calculate residuals for contemporary prediction
# (observed - predicted)
resids <-  plotObservations_needleLeaved_proportion_2 - plotObs_2 
map_resids_trimAnoms <- ggplot() +
geom_spatraster(data = resids) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(resids)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Resids. (obs. - pred.) from the 
                      grass/shrub model of needle-leaved tree cover"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model with contemporary climate data") +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(resids)[c(1,3)]) + 
  ylim(st_bbox(resids)[c(2,4)])

hist_trimAnoms_resids <-  ggplot(resids) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") + 
  geom_vline(aes(xintercept = mean(terra::values(resids$mean), na.rm = TRUE)))

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model1 <-  plotObs_bestLambdaFuture1_2 - plotObs_2 

map_deltas_model1 <- ggplot() +
geom_spatraster(data = predDeltas_model1) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model1)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for 
                      grass/shrub model of needle-leaved tree covver; (models with 
                      predictions with modeled climate data from model BNU-ESM 
                      model - models with predictions from 
                      contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model1)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model1)[c(2,4)])

hist_deltas_model1 <-  ggplot(predDeltas_model1) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

# calculate deltas from model 1(future model predictions - contemporary model predictions)
predDeltas_model2 <-  plotObs_bestLambdaFuture2_2 - plotObs_2 

map_deltas_model2 <- ggplot() +
geom_spatraster(data = predDeltas_model2) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(predDeltas_model2)),fill=NA )  + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  labs(title = paste0("Future Climate Model Deltas for
  grass/shrub model of needle-leaved tree cover; 
  (models with predictions with modeled 
  climate data from model IPSL-CM5A-MR 
  model- models with predictions from 
  contemporary climate data)"),
     subtitle = "using predictions from the Trim Anomalies 
     bestLambda model") +
  scale_fill_gradient2(low = "orange",
                       mid = "white" ,
                       high = "purple" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       ) + 
  xlim(st_bbox(predDeltas_model2)[c(1,3)]) + 
  ylim(st_bbox(predDeltas_model2)[c(2,4)])

hist_deltas_model2 <-  ggplot(predDeltas_model2) + 
  geom_density(aes(mean), fill = "lightgrey", col = "darkgrey") + 
  xlab("Predicted Value") + 
  ylab("frequency") 

## conglomerate figure

  ggarrange(map_obs_CONUS_needleLeavedTree, hist_obs, heights = c(3,1), ncol = 1, nrow  = 2)

  # plot model forecasts with model that does not exclude anomalies
       ggarrange(map, map_bestlambda_future1, map_bestlambda_future2,
              hist, hist_bestlambdaFuture1, hist_bestlambdaFuture2, 
            map_resids_trimAnoms, map_deltas_model1, map_deltas_model2,
            hist_trimAnoms_resids, hist_deltas_model1, hist_deltas_model2,
            heights = c(3,1), ncol = 3, nrow = 4) %>% 
  annotate_figure(fig.lab = "Model Predictions of needleLeavedTree with grass/shrub Model using Contemporary and Forecasted Climate Data", fig.lab.size = 20)
```


## Now, predict using the entire hierarchy of models, starting with ecoregion  ecoregion model 
### These are predictions of ecoregion classification using contemporary and modeled future climate data 
```{r}
ecoMod <- readRDS("../../ecoregionClassification/ModelFitting/ModelObjects/EcoregionClassificationModel.rds")

## print out model statement
coefficientTable <- data.frame(coefficients(ecoMod))
responseVar <- "P(forest)"
coefficientTable$coefficientName <- rownames(coefficientTable)
coefficientTable$coefficients.ecoMod. <- round(coefficientTable$coefficients.ecoMod., 4)
  
  # print out coefficients w/ coefficient names
tempNames <- paste0(
  apply(coefficientTable, MARGIN = 1, FUN = function(x) {
    if (x["coefficientName"] == "(Intercept)") {
      paste0(x["coefficients.ecoMod."])
    } else {  
      paste0(x["coefficients.ecoMod."], "*", x["coefficientName"])
    }
    }
  ),
  collapse = " + "
)

# print the unscaled model statement
  unscaledModelName <- paste0(responseVar, "~ 1/ (1 + exp(-(", tempNames,")))")
 print(unscaledModelName)
```
 
 Here are maps of the ecoregion model predictions with both contemporary and modeled future climate data 
```{r fig.width = 16, fig.height = 10, message = FALSE}
## get model data used for ecoregion fitting
modDat_ecoregionFit <- readRDS("../../../Data_processed/EcoRegion_climSoilData.rds")

modDat_ecoregionFit <- modDat_ecoregionFit %>% 
  rename("Long" = x, "Lat" = y) %>% 
  dplyr::select(c(newRegion, #swe_meanAnnAvg_CLIM:
                  tmin_meanAnnAvg_CLIM:durationFrostFreeDays_meanAnnAvg_CLIM,
                                         soilDepth                  , surfaceClay_perc          ,                
                                         avgSandPerc_acrossDepth    ,  avgCoarsePerc_acrossDepth,                 
                                         avgOrganicCarbonPerc_0_3cm ,  totalAvailableWaterHoldingCapacity,
                                         Long, Lat)) %>% 
  mutate(newRegion = as.factor(newRegion)) %>% 
  drop_na()

# get climate data from dayMet (d.f. is "climDatPred_unscaled")
climDatPred_unscaled <- climDat
names(climDatPred_unscaled)[c(5, 6, 7, 13, 10, 12, 52, 54, 55, 56)] <- c("T_warmestMonth_meanAnnAvg_CLIM", "T_coldestMonth_meanAnnAvg_CLIM", "precip_wettestMonth_meanAnnAvg_CLIM", "annWaterDeficit_meanAnnAvg_CLIM", "PrecipTempCorr_meanAnnAvg_CLIM", "isothermality_meanAnnAvg_CLIM", "soilDepth", "avgSandPerc_acrossDepth", "avgCoarsePerc_acrossDepth", "avgOrganicCarbonPerc_0_3cm")

# predict with contemporary climate data 
preds_byHand <- climDatPred_unscaled %>% 
  mutate(pred = 1/(1 + exp(-( 9.8726 + -0.2999*T_warmestMonth_meanAnnAvg_CLIM +  0.2456*T_coldestMonth_meanAnnAvg_CLIM +  0.0106*precip_wettestMonth_meanAnnAvg_CLIM + -0.0621*annWaterDeficit_meanAnnAvg_CLIM + -2.7863*PrecipTempCorr_meanAnnAvg_CLIM +  0.0540*isothermality_meanAnnAvg_CLIM + -0.0076*soilDepth +  0.0335*avgSandPerc_acrossDepth +  0.0310*avgCoarsePerc_acrossDepth +  0.2726*avgOrganicCarbonPerc_0_3cm))))
#predictionsModel <- predict(object = ecoMod, type = "response", newdata = climDatPred_unscaled)

# predict with modeled future climate data v1
names(forecastClimSoilsDat_1)[c(8, 9, 10, 16, 13, 15, 48, 50, 51, 52)] <- c("T_warmestMonth_meanAnnAvg_CLIM", "T_coldestMonth_meanAnnAvg_CLIM", "precip_wettestMonth_meanAnnAvg_CLIM", "annWaterDeficit_meanAnnAvg_CLIM", "PrecipTempCorr_meanAnnAvg_CLIM", "isothermality_meanAnnAvg_CLIM", "soilDepth", "avgSandPerc_acrossDepth", "avgCoarsePerc_acrossDepth", "avgOrganicCarbonPerc_0_3cm")
preds_future1_byHand <- forecastClimSoilsDat_1 %>% 
  mutate(pred = 1/(1 + exp(-( 9.8726 + -0.2999*T_warmestMonth_meanAnnAvg_CLIM +  0.2456*T_coldestMonth_meanAnnAvg_CLIM +  0.0106*precip_wettestMonth_meanAnnAvg_CLIM + -0.0621*annWaterDeficit_meanAnnAvg_CLIM + -2.7863*PrecipTempCorr_meanAnnAvg_CLIM +  0.0540*isothermality_meanAnnAvg_CLIM + -0.0076*soilDepth +  0.0335*avgSandPerc_acrossDepth +  0.0310*avgCoarsePerc_acrossDepth +  0.2726*avgOrganicCarbonPerc_0_3cm))))

# predict with modeled future climate data v2
names(forecastClimSoilsDat_2)[c(8, 9, 10, 16, 13, 15, 48, 50, 51, 52)] <- c("T_warmestMonth_meanAnnAvg_CLIM", "T_coldestMonth_meanAnnAvg_CLIM", "precip_wettestMonth_meanAnnAvg_CLIM", "annWaterDeficit_meanAnnAvg_CLIM", "PrecipTempCorr_meanAnnAvg_CLIM", "isothermality_meanAnnAvg_CLIM", "soilDepth", "avgSandPerc_acrossDepth", "avgCoarsePerc_acrossDepth", "avgOrganicCarbonPerc_0_3cm")
preds_future2_byHand <- forecastClimSoilsDat_2 %>% 
  mutate(pred = 1/(1 + exp(-( 9.8726 + -0.2999*T_warmestMonth_meanAnnAvg_CLIM +  0.2456*T_coldestMonth_meanAnnAvg_CLIM +  0.0106*precip_wettestMonth_meanAnnAvg_CLIM + -0.0621*annWaterDeficit_meanAnnAvg_CLIM + -2.7863*PrecipTempCorr_meanAnnAvg_CLIM +  0.0540*isothermality_meanAnnAvg_CLIM + -0.0076*soilDepth +  0.0335*avgSandPerc_acrossDepth +  0.0310*avgCoarsePerc_acrossDepth +  0.2726*avgOrganicCarbonPerc_0_3cm))))


## Plot predictions with contemporary data
# make into a raster
plotObs <- preds_byHand %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "pred", 
                   fun = mean, na.rm = TRUE) #%>% 
   #terra::aggregate(fact = 2, fun = mean, na.rm = TRUE) %>% 
  #terra::crop(ext(-1950000, 1000000, -1800000, 1000000))

# get the extent of this particular raster, and crop it accordingly

plotObs_2 <- plotObs %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

map_ecoRegion_current <- ggplot() +
  geom_spatraster(data = plotObs_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("Ecoregion classification predictions using 
                    contemporary dayMet data")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,1),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

# for future v1
plotObs_future1 <- preds_future1_byHand %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "pred", 
                   fun = mean, na.rm = TRUE) #%>% 
   #terra::aggregate(fact = 2, fun = mean, na.rm = TRUE) %>% 
  #terra::crop(ext(-1950000, 1000000, -1800000, 1000000))

# get the extent of this particular raster, and crop it accordingly

plotObs_future1_2 <- plotObs_future1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

map_ecoRegion_future1 <- ggplot() +
  geom_spatraster(data = plotObs_future1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_future1_2)),fill=NA ) +
labs(title = paste0("Ecoregion classification predictions using future 
climate data from the BNU-ESM model")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,1),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_future1_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_future1_2)[c(2,4)])

# for future v2
plotObs_future2 <- preds_future2_byHand %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "pred", 
                   fun = mean, na.rm = TRUE) #%>% 
   #terra::aggregate(fact = 2, fun = mean, na.rm = TRUE) %>% 
  #terra::crop(ext(-1950000, 1000000, -1800000, 1000000))

# get the extent of this particular raster, and crop it accordingly

plotObs_future2_2 <- plotObs_future2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

map_ecoRegion_future2 <- ggplot() +
  geom_spatraster(data = plotObs_future2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_future2_2)),fill=NA ) +
labs(title = paste0("Ecoregion classification predictions using future 
climate data from the IPSL-CM5A-MR model")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,1),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_future2_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_future2_2)[c(2,4)])

## Plot the maps together
  ggarrange(map_ecoRegion_current, map_ecoRegion_future1, map_ecoRegion_future2, nrow = 1) %>% 
  annotate_figure(fig.lab = "Model Predictions of Ecoregion Classification with Contemporary and Forecasted Climate Data", fig.lab.size = 20)
```
 
 
### Show "synthetic" predictions for first tier of cover models -- using *scaled* climate predictors
```{r fig.width = 10, fig.height=10}
# rename climate data.frame to work with model specifications
## grass/shrub total herbaceous - best lambda model (bestLambdaMod_GS_totHerb)
# predict with contemporary data
#bestLambda_GS_totHerb_predict
names(bestLambda_GS_totHerb_predict)[57] <- "predContemp_GS_totHerb"
# predict with modeled future climate data v1
#bestLambda_GS_totHerb_predictFuture_1
names(bestLambda_GS_totHerb_predictFuture_1)[55] <- "predFuture1_GS_totHerb"
# predict with modeled future climate data v2
#bestLambda_GS_totHerb_predictFuture_2
names(bestLambda_GS_totHerb_predictFuture_2)[55] <- "predFuture2_GS_totHerb"


# grass/shrub total tree - 1/2 SE lambda model (oneSELambdaMod_GS_totTree)
# predict with contemporary data
#bestLambda_GS_totTree_predict
names(bestLambda_GS_totTree_predict)[57] <- "predContemp_GS_totTree"
# predict with modeled future climate data v1
#bestLambda_GS_totTree_predictFuture_1
names(bestLambda_GS_totTree_predictFuture_1)[55] <- "predFuture1_GS_totTree"
# predict with modeled future climate data v2
#bestLambda_GS_totTree_predictFuture_2
names(bestLambda_GS_totTree_predictFuture_2)[55] <- "predFuture2_GS_totTree"


# forest total herbaceous - best lambda model (bestLambdaMod_F_totHerb)
# predict with contemporary data
#bestLambda_F_totHerb_predict
names(bestLambda_F_totHerb_predict)[57] <- "predContemp_F_totHerb"
# predict with modeled future climate data v1
#bestLambda_F_totHerb_predictFuture_1
names(bestLambda_F_totHerb_predictFuture_1)[55] <- "predFuture1_F_totHerb"
# predict with modeled future climate data v2
#bestLambda_F_totHerb_predictFuture_2
names(bestLambda_F_totHerb_predictFuture_2)[55] <- "predFuture2_F_totHerb"


# forest total tree - best lambda model (bestLambdaMod_F_totTree)
# predict with contemporary data
#bestLambda_F_totTree_predict
names(bestLambda_F_totTree_predict)[57] <- "predContemp_F_totTree"
# predict with modeled future climate data v1
#bestLambda_F_totTree_predictFuture_1
names(bestLambda_F_totTree_predictFuture_1)[55] <- "predFuture1_F_totTree"
# predict with modeled future climate data v2
#bestLambda_F_totTree_predictFuture_2
names(bestLambda_F_totTree_predictFuture_2)[55] <- "predFuture2_F_totTree"


# CONUS shrub - best lambda model (bestLambdaMod_CONUS_shrub)
# predict with contemporary data
#bestLambda_CONUS_shrub_predict
names(bestLambda_CONUS_shrub_predict)[57] <- "predContemp_CONUS_shrub"
# predict with modeled future climate data v1
#bestLambda_CONUS_shrub_predictFuture_1
names(bestLambda_CONUS_shrub_predictFuture_1)[55] <- "predFuture1_CONUS_shrub"
# predict with modeled future climate data v2
#bestLambda_CONUS_shrub_predictFuture_2
names(bestLambda_CONUS_shrub_predictFuture_2)[55] <- "predFuture2_CONUS_shrub"

# CONUS bare ground - 1 SE lambda model (oneSELambdaMod_CONUS_bareGround)
# predict with contemporary data
#bestLambda_CONUS_bareGround_predict
names(bestLambda_CONUS_bareGround_predict)[57] <- "predContemp_CONUS_bareGround"
# predict with modeled future climate data v1
#bestLambda_CONUS_bareGround_predictFuture_1
names(bestLambda_CONUS_bareGround_predictFuture_1)[55] <- "predFuture1_CONUS_bareGround"
# predict with modeled future climate data v2
#bestLambda_CONUS_bareGround_predictFuture_2
names(bestLambda_CONUS_bareGround_predictFuture_2)[55] <- "predFuture2_CONUS_bareGround"

### add all of the predictions for each time interval together
preds_contemp_cover1 <- bestLambda_GS_totHerb_predict %>% 
  left_join(bestLambda_GS_totTree_predict) %>% 
  left_join(bestLambda_F_totHerb_predict) %>% 
  left_join(bestLambda_F_totTree_predict)  %>% 
  left_join(bestLambda_CONUS_shrub_predict) %>% 
  left_join(bestLambda_CONUS_bareGround_predict) %>% 
  left_join(level2_cover_preds_contemp)

preds_future_1_cover1 <-  bestLambda_GS_totHerb_predictFuture_1 %>% 
  left_join(bestLambda_GS_totTree_predictFuture_1) %>% 
  left_join(bestLambda_F_totHerb_predictFuture_1) %>% 
  left_join(bestLambda_F_totTree_predictFuture_1)  %>% 
  left_join(bestLambda_CONUS_shrub_predictFuture_1) %>% 
  left_join(bestLambda_CONUS_bareGround_predictFuture_1) %>% 
  left_join(level2_cover_preds_future1)

preds_future_2_cover1 <- bestLambda_GS_totHerb_predictFuture_2 %>% 
  left_join(bestLambda_GS_totTree_predictFuture_2) %>% 
  left_join(bestLambda_F_totHerb_predictFuture_2) %>% 
  left_join(bestLambda_F_totTree_predictFuture_2)  %>% 
  left_join(bestLambda_CONUS_shrub_predictFuture_2) %>% 
  left_join(bestLambda_CONUS_bareGround_predictFuture_2) %>% 
  left_join(level2_cover_preds_future2)

### add ecoregion-level predictions to these data frames
names(preds_byHand)[58] <- "prob_forest"
preds_byHand$prob_GrassShrub <- 1 - preds_byHand$prob_forest

names(preds_future1_byHand)[55] <- "prob_forest"
preds_future1_byHand$prob_GrassShrub <- 1 - preds_future1_byHand$prob_forest

names(preds_future2_byHand)[55] <- "prob_forest"
preds_future2_byHand$prob_GrassShrub <- 1 - preds_future2_byHand$prob_forest

preds_contemp <- preds_contemp_cover1 %>% 
 cbind(preds_byHand %>% select( prob_forest, prob_GrassShrub))

preds_future_1 <- preds_future_1_cover1 %>% 
 cbind(preds_future1_byHand %>% select(prob_forest, prob_GrassShrub))

preds_future_2 <- preds_future_2_cover1 %>% 
 cbind(preds_future2_byHand %>% select( prob_forest, prob_GrassShrub))

## make the predictions scale according to ecoregion
preds_contemp <- preds_contemp %>% 
  mutate(totHerb_synth = ((prob_GrassShrub * predContemp_GS_totHerb) + (prob_forest * predContemp_F_totHerb)),
         totTree_synth = ((prob_GrassShrub * predContemp_GS_totTree) + (prob_forest * predContemp_F_totTree)))
preds_future_1 <- preds_future_1 %>% 
  mutate(totHerb_synth = ((prob_GrassShrub * predFuture1_GS_totHerb) + (prob_forest * predFuture1_F_totHerb)),
         totTree_synth = ((prob_GrassShrub * predFuture1_GS_totTree) + (prob_forest * predFuture1_F_totTree)))
preds_future_2 <- preds_future_2 %>% 
  mutate(totHerb_synth = ((prob_GrassShrub * predFuture2_GS_totHerb) + (prob_forest * predFuture2_F_totHerb)),
         totTree_synth = ((prob_GrassShrub * predFuture2_GS_totTree) + (prob_forest * predFuture2_F_totTree)))
## make the level 2 tree proportion scale according to ecoregion
# add ecoregion predictions to level 2 cover predictions

level2_cover_preds_contemp <- level2_cover_preds_contemp %>% 
 cbind(preds_byHand %>% select(
   prob_forest, prob_GrassShrub)) %>% 
  mutate(needleLeavedTree_perc_scaled_synth = ((prob_GrassShrub * needleLeavedTree_grassShrub_percentage_scaled) + (prob_forest * needleLeavedTree_forest_percentage_scaled)), 
         broadLeavedTree_perc_scaled_synth = ((prob_GrassShrub * broadLeavedTree_grassShrub_percentage_scaled) + (prob_forest * broadLeavedTree_forest_percentage_scaled))) 
## but maybe need to scale to sum to 100 *after* multiplying by ecoregion probability?? this first pass is scaling **before** the multiplication -- it turns out that the multiplication works out either way...  this version, the synthetic values still sum to 100
# for future model 1
level2_cover_preds_future1 <- level2_cover_preds_future1 %>% 
 cbind(preds_future1_byHand %>% select(
   prob_forest, prob_GrassShrub)) %>% 
  mutate(needleLeavedTree_perc_scaled_synth = ((prob_GrassShrub * needleLeavedTree_grassShrub_percentage_scaled) + (prob_forest * needleLeavedTree_forest_percentage_scaled)), 
         broadLeavedTree_perc_scaled_synth = ((prob_GrassShrub * broadLeavedTree_grassShrub_percentage_scaled) + (prob_forest * broadLeavedTree_forest_percentage_scaled))) 
# for future model 2
level2_cover_preds_future2 <- level2_cover_preds_future2 %>% 
 cbind(preds_future2_byHand %>% select(
   prob_forest, prob_GrassShrub)) %>% 
  mutate(needleLeavedTree_perc_scaled_synth = ((prob_GrassShrub * needleLeavedTree_grassShrub_percentage_scaled) + (prob_forest * needleLeavedTree_forest_percentage_scaled)), 
         broadLeavedTree_perc_scaled_synth = ((prob_GrassShrub * broadLeavedTree_grassShrub_percentage_scaled) + (prob_forest * broadLeavedTree_forest_percentage_scaled))) 
```

```{r fig.width = 10, fig.height=10}
### make maps
## Plot predictions with contemporary data
# total Herbaceous
  # make into a raster
plotPreds_totHerbaceous <- preds_contemp %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "totHerb_synth", 
                   fun = mean, na.rm = TRUE) #%>% 
   #terra::aggregate(fact = 2, fun = mean, na.rm = TRUE) %>% 
  #terra::crop(ext(-1950000, 1000000, -1800000, 1000000))

# get the extent of this particular raster, and crop it accordingly

plotPreds_totHerbaceous_2 <- plotPreds_totHerbaceous %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

map_preds_totHerbaceous <- ggplot() +
  geom_spatraster(data = plotPreds_totHerbaceous_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("'Synthetic' prediction of total herbaceous cover with 
                    contemporary climate data")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

# total Tree
  # make into a raster
plotPreds_totTree <- preds_contemp %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "totTree_synth", 
                   fun = mean, na.rm = TRUE) #%>% 
   #terra::aggregate(fact = 2, fun = mean, na.rm = TRUE) %>% 
  #terra::crop(ext(-1950000, 1000000, -1800000, 1000000))

# get the extent of this particular raster, and crop it accordingly

plotPreds_totTree_2 <- plotPreds_totTree %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

map_preds_totTree <- ggplot() +
  geom_spatraster(data = plotPreds_totTree_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("'Synthetic' prediction of total Tree cover with 
                    contemporary climate data")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

## Plot predictions with future 1 data
# total Herbaceous
  # make into a raster
plotPreds_totHerbaceous_future1 <- preds_future_1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "totHerb_synth", 
                   fun = mean, na.rm = TRUE) #%>% 
   #terra::aggregate(fact = 2, fun = mean, na.rm = TRUE) %>% 
  #terra::crop(ext(-1950000, 1000000, -1800000, 1000000))

# get the extent of this particular raster, and crop it accordingly

plotPreds_totHerbaceous_future1_2 <- plotPreds_totHerbaceous_future1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

map_preds_totHerbaceous_future1 <- ggplot() +
  geom_spatraster(data = plotPreds_totHerbaceous_future1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("'Synthetic' prediction of total herbaceous cover with 
                    future climate data - first model")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

# total Tree
  # make into a raster
plotPreds_totTree_future1 <- preds_future_1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "totTree_synth", 
                   fun = mean, na.rm = TRUE) #%>% 
   #terra::aggregate(fact = 2, fun = mean, na.rm = TRUE) %>% 
  #terra::crop(ext(-1950000, 1000000, -1800000, 1000000))

# get the extent of this particular raster, and crop it accordingly

plotPreds_totTree_future1_2 <- plotPreds_totTree_future1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

map_preds_totTree_future1 <- ggplot() +
  geom_spatraster(data = plotPreds_totTree_future1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("'Synthetic' prediction of total Tree cover with 
                    future climate data - first model")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

## Plot predictions with future 1 data
# total Herbaceous
  # make into a raster
plotPreds_totHerbaceous_future2 <- preds_future_2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "totHerb_synth", 
                   fun = mean, na.rm = TRUE) #%>% 
   #terra::aggregate(fact = 2, fun = mean, na.rm = TRUE) %>% 
  #terra::crop(ext(-1950000, 1000000, -1800000, 1000000))

# get the extent of this particular raster, and crop it accordingly

plotPreds_totHerbaceous_future2_2 <- plotPreds_totHerbaceous_future2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

map_preds_totHerbaceous_future2 <- ggplot() +
  geom_spatraster(data = plotPreds_totHerbaceous_future2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("'Synthetic' prediction of total herbaceous cover with 
                    future climate data - second model")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

# total Tree
  # make into a raster
plotPreds_totTree_future2 <- preds_future_2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "totTree_synth", 
                   fun = mean, na.rm = TRUE) #%>% 
   #terra::aggregate(fact = 2, fun = mean, na.rm = TRUE) %>% 
  #terra::crop(ext(-1950000, 1000000, -1800000, 1000000))

# get the extent of this particular raster, and crop it accordingly

plotPreds_totTree_future2_2 <- plotPreds_totTree_future2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

map_preds_totTree_future2 <- ggplot() +
  geom_spatraster(data = plotPreds_totTree_future2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("'Synthetic' prediction of total Tree cover with 
                    future climate data - second model")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

ggarrange(map_preds_totHerbaceous, map_preds_totTree, 
          map_preds_totHerbaceous_future1, map_preds_totTree_future1, 
          map_preds_totHerbaceous_future2, map_preds_totTree_future2, ncol = 2, nrow = 3)
```

### Show "synthetic" predictions for the second tier of cover models (only for needle leaved/broad leaved trees, since other models are CONUS-wide)

```{r fig.width = 10, fig.height=10}
# broad leaved tree contemp
  # make into a raster
plotPreds_broadLeavedSynth_contemp <- level2_cover_preds_contemp %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "broadLeavedTree_perc_scaled_synth", 
                   fun = mean, na.rm = TRUE)

plotPreds_broadLeavedSynth_contemp_2 <- plotPreds_broadLeavedSynth_contemp %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

map_preds_broadLeavedSynth_contemp <- ggplot() +
  geom_spatraster(data = plotPreds_broadLeavedSynth_contemp_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("'Synthetic' prediction of proportion of tree cover that is 
broad leaved with 
contemporary climate data")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

# broad leaved tree future 1
  # make into a raster
plotPreds_broadLeavedSynth_future1 <- level2_cover_preds_future1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "broadLeavedTree_perc_scaled_synth", 
                   fun = mean, na.rm = TRUE)

plotPreds_broadLeavedSynth_future1_2 <- plotPreds_broadLeavedSynth_future1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

map_preds_broadLeavedSynth_future1 <- ggplot() +
  geom_spatraster(data = plotPreds_broadLeavedSynth_future1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("'Synthetic' prediction of proportion of tree cover that is 
broad leaved with 
future climate data - first model")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

# broad leaved tree future 2
  # make into a raster
plotPreds_broadLeavedSynth_future2 <- level2_cover_preds_future2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "broadLeavedTree_perc_scaled_synth", 
                   fun = mean, na.rm = TRUE)

plotPreds_broadLeavedSynth_future2_2 <- plotPreds_broadLeavedSynth_future2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

map_preds_broadLeavedSynth_future2 <- ggplot() +
  geom_spatraster(data = plotPreds_broadLeavedSynth_future2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("'Synthetic' prediction of proportion of tree cover that is 
broad leaved with 
future climate data - second model")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

# needle leaved tree contemp
  # make into a raster
plotPreds_needleLeavedSynth_contemp <- level2_cover_preds_contemp %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "needleLeavedTree_perc_scaled_synth", 
                   fun = mean, na.rm = TRUE)

plotPreds_needleLeavedSynth_contemp_2 <- plotPreds_needleLeavedSynth_contemp %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

map_preds_needleLeavedSynth_contemp <- ggplot() +
  geom_spatraster(data = plotPreds_needleLeavedSynth_contemp_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("'Synthetic' prediction of proportion of tree cover that is 
needle leaved with 
contemporary climate data")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

# needle leaved tree future 1
  # make into a raster
plotPreds_needleLeavedSynth_future1 <- level2_cover_preds_future1 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "needleLeavedTree_perc_scaled_synth", 
                   fun = mean, na.rm = TRUE)

plotPreds_needleLeavedSynth_future1_2 <- plotPreds_needleLeavedSynth_future1 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

map_preds_needleLeavedSynth_future1 <- ggplot() +
  geom_spatraster(data = plotPreds_needleLeavedSynth_future1_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("'Synthetic' prediction of proportion of tree cover that is 
needle leaved with 
future climate data - first model")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

# needle leaved tree future 2
  # make into a raster
plotPreds_needleLeavedSynth_future2 <- level2_cover_preds_future2 %>% 
         #drop_na(paste(response)) %>% 
  #slice_sample(n = 5e4) %>%
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "needleLeavedTree_perc_scaled_synth", 
                   fun = mean, na.rm = TRUE)

plotPreds_needleLeavedSynth_future2_2 <- plotPreds_needleLeavedSynth_future2 %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])) 
       )

map_preds_needleLeavedSynth_future2 <- ggplot() +
  geom_spatraster(data = plotPreds_needleLeavedSynth_future2_2) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObs_2)),fill=NA ) +
labs(title = paste0("'Synthetic' prediction of proportion of tree cover that is 
needle leaved with 
future climate data - second model")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObs_2)[c(1,3)]) + 
  ylim(st_bbox(plotObs_2)[c(2,4)])

ggarrange(map_preds_broadLeavedSynth_contemp, map_preds_needleLeavedSynth_contemp, 
          map_preds_broadLeavedSynth_future1, map_preds_needleLeavedSynth_future1, 
          map_preds_broadLeavedSynth_future2, map_preds_needleLeavedSynth_future2, ncol = 2, nrow = 3)
```

### Now, scale all of the first tier of cover models to sum to 100% 
```{r fig.width = 15, fig.height=12}
## contemporary climate data
preds_contemp <- preds_contemp %>% 
  mutate(totalCover =  predContemp_CONUS_shrub + predContemp_CONUS_bareGround + totHerb_synth + totTree_synth)  %>% # calculate total cover "%" in a location
  # scale so that the cover classes sum to 100 
  mutate(shrub_cover_finalScaled = predContemp_CONUS_shrub/totalCover * 100,
         bareGround_cover_finalScaled = predContemp_CONUS_bareGround/totalCover * 100, 
         totalHerb_cover_finalScaled = totHerb_synth/totalCover * 100, 
         totalTree_cover_finalScaled = totTree_synth/totalCover * 100)

## future climate data model 1
preds_future_1 <- preds_future_1 %>% 
  mutate(totalCover =  predFuture1_CONUS_shrub + predFuture1_CONUS_bareGround + totHerb_synth + totTree_synth)  %>% # calculate total cover "%" in a location
  # scale so that the cover classes sum to 100 
  mutate(shrub_cover_finalScaled = predFuture1_CONUS_shrub/totalCover * 100,
         bareGround_cover_finalScaled = predFuture1_CONUS_bareGround/totalCover * 100, 
         totalHerb_cover_finalScaled = totHerb_synth/totalCover * 100, 
         totalTree_cover_finalScaled = totTree_synth/totalCover * 100)

## future climate data model 2
preds_future_2 <- preds_future_2 %>% 
  mutate(totalCover = predFuture2_CONUS_shrub + predFuture2_CONUS_bareGround + totHerb_synth + totTree_synth)  %>% # calculate total cover "%" in a location
  # scale so that the cover classes sum to 100 
  mutate(shrub_cover_finalScaled = predFuture2_CONUS_shrub/totalCover * 100,
         bareGround_cover_finalScaled = predFuture2_CONUS_bareGround/totalCover * 100, 
         totalHerb_cover_finalScaled = totHerb_synth/totalCover * 100, 
         totalTree_cover_finalScaled = totTree_synth/totalCover * 100)

### make figures
# for contemporary climate 
contempScaledPreds_maps <- map(c("shrub_cover_finalScaled",
         "bareGround_cover_finalScaled",  "totalHerb_cover_finalScaled", 
         "totalTree_cover_finalScaled"), .f = function(x) {
           # make the raster
           rast_1 <- preds_contemp %>% 
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = x, 
                   fun = mean, na.rm = TRUE) %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])))
           
           # make map 
           map_1  <- ggplot() +
  geom_spatraster(data = rast_1) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("'Scaled' prediction of ", x, " with 
                    contemporary climate data")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(rast_1)[c(1,3)]) + 
  ylim(st_bbox(rast_1)[c(2,4)])
           
           return(list("rast" = rast_1, "map" = map_1))
         }
         )
names(contempScaledPreds_maps) <- c("shrub_cover_finalScaled",
         "bareGround_cover_finalScaled",  "totalHerb_cover_finalScaled", 
         "totalTree_cover_finalScaled")

# for future climate model 1
future1ScaledPreds_maps <- map(c("shrub_cover_finalScaled",
         "bareGround_cover_finalScaled",  "totalHerb_cover_finalScaled", 
         "totalTree_cover_finalScaled"), .f = function(x) {
           # make the raster
           rast_1 <- preds_future_1 %>% 
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = x, 
                   fun = mean, na.rm = TRUE) %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])))
           
           # make map 
           map_1  <- ggplot() +
  geom_spatraster(data = rast_1) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("'Scaled' prediction of ", x, " with 
                    contemporary climate data")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(rast_1)[c(1,3)]) + 
  ylim(st_bbox(rast_1)[c(2,4)])
           
           return(list("rast" = rast_1, "map" = map_1))
         }
         )

names(future1ScaledPreds_maps) <- c("shrub_cover_finalScaled",
         "bareGround_cover_finalScaled",  "totalHerb_cover_finalScaled", 
         "totalTree_cover_finalScaled")

# for future climate model 2
future2ScaledPreds_maps <- map(c("shrub_cover_finalScaled",
         "bareGround_cover_finalScaled",  "totalHerb_cover_finalScaled", 
         "totalTree_cover_finalScaled"), .f = function(x) {
           # make the raster
           rast_1 <- preds_future_2 %>% 
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = x, 
                   fun = mean, na.rm = TRUE) %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])))
           
           # make map 
           map_1  <- ggplot() +
  geom_spatraster(data = rast_1) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("'Scaled' prediction of ", x, " with 
                    contemporary climate data")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(rast_1)[c(1,3)]) + 
  ylim(st_bbox(rast_1)[c(2,4)])
           
           return(list("rast" = rast_1, "map" = map_1))
         }
         )
names(future2ScaledPreds_maps) <- c("shrub_cover_finalScaled",
         "bareGround_cover_finalScaled",  "totalHerb_cover_finalScaled", 
         "totalTree_cover_finalScaled")


# ggarrange(contempScaledPreds_maps[[3]], contempScaledPreds_maps[[4]], contempScaledPreds_maps[[1]], contempScaledPreds_maps[[2]], common.legend = TRUE, ncol = 2, nrow = 2, legend = "bottom")  %>% 
#   annotate_figure(fig.lab = "Scaled model predictions of 'level 1' cover variables with contemporary data ", fig.lab.size = 20)
# 
# 
# ggarrange(future1ScaledPreds_maps[[3]], future1ScaledPreds_maps[[4]], future1ScaledPreds_maps[[1]], future1ScaledPreds_maps[[2]], common.legend = TRUE, ncol = 2, nrow = 2, legend = "bottom")  %>% 
#   annotate_figure(fig.lab = "Scaled model predictions of 'level 1' cover variables with future climate data - model 1", fig.lab.size = 20)
# 
# 
# ggarrange(future2ScaledPreds_maps[[3]], future2ScaledPreds_maps[[4]], future2ScaledPreds_maps[[1]], future2ScaledPreds_maps[[2]], common.legend = TRUE, ncol = 2, nrow = 2, legend = "bottom")  %>% 
#   annotate_figure(fig.lab = "Scaled model predictions of 'level 1' cover variables with future climate data - model 2", fig.lab.size = 20)
  
```

### Add in second tier of cover models to break up total herbaceous cover into C3/C4/Forb and total tree cover into broad-leaved tree/needle-leaved tree

```{r fig.width = 15, fig.height=12}
## for contemporary data, multiply the synthetic and scaled level-1 cover predictions by the scaled level-2 percentages
preds_contemp  <- preds_contemp  %>% 
  left_join(level2_cover_preds_contemp) %>% 
 mutate(C3_cover_finalScaled = totalHerb_cover_finalScaled *(C3_percentage_scaled/100),
        C4_cover_finalScaled = totalHerb_cover_finalScaled *(C4_percentage_scaled/100),
        forb_cover_finalScaled = totalHerb_cover_finalScaled *(forb_percentage_scaled/100),
        broadLeaved_cover_finalScaled = totalTree_cover_finalScaled *(broadLeavedTree_perc_scaled_synth/100),
        needleLeaved_cover_finalScaled = totalTree_cover_finalScaled *(needleLeavedTree_perc_scaled_synth/100)) 

## for future 1 data, multiply the synthetic and scaled level-1 cover predictions by the scaled level-2 percentages
preds_future_1 <- preds_future_1 %>% 
  left_join(level2_cover_preds_future1) %>% 
 mutate(C3_cover_finalScaled = totalHerb_cover_finalScaled *(C3_percentage_scaled/100),
        C4_cover_finalScaled = totalHerb_cover_finalScaled *(C4_percentage_scaled/100),
        forb_cover_finalScaled = totalHerb_cover_finalScaled *(forb_percentage_scaled/100),
        broadLeaved_cover_finalScaled = totalTree_cover_finalScaled *(broadLeavedTree_perc_scaled_synth/100),
        needleLeaved_cover_finalScaled = totalTree_cover_finalScaled *(needleLeavedTree_perc_scaled_synth/100)) 

## for future 2 data, multiply the synthetic and scaled level-1 cover predictions by the scaled level-2 percentages
preds_future_2 <- preds_future_2 %>% 
  left_join(level2_cover_preds_future2) %>% 
 mutate(C3_cover_finalScaled = totalHerb_cover_finalScaled *(C3_percentage_scaled/100),
        C4_cover_finalScaled = totalHerb_cover_finalScaled *(C4_percentage_scaled/100),
        forb_cover_finalScaled = totalHerb_cover_finalScaled *(forb_percentage_scaled/100),
        broadLeaved_cover_finalScaled = totalTree_cover_finalScaled *(broadLeavedTree_perc_scaled_synth/100),
        needleLeaved_cover_finalScaled = totalTree_cover_finalScaled *(needleLeavedTree_perc_scaled_synth/100)) 


# make maps for level 2 cover w/ contemporary climate data
contemp_cover2_ScaledPreds_maps <- map(c("C3_cover_finalScaled",
         "C4_cover_finalScaled",  "forb_cover_finalScaled", 
         "broadLeaved_cover_finalScaled", "needleLeaved_cover_finalScaled"), .f = function(x) {
           # make the raster
           rast_1 <- preds_contemp %>% 
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = x, 
                   fun = mean, na.rm = TRUE) %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])))
           
           # make map 
           map_1  <- ggplot() +
  geom_spatraster(data = rast_1) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("'Scaled' prediction of ", x, " with 
                    contemporary climate data")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(rast_1)[c(1,3)]) + 
  ylim(st_bbox(rast_1)[c(2,4)])
           
           return(list("rast" = rast_1, "map" = map_1))
         }
         )
names(contemp_cover2_ScaledPreds_maps) <- c("C3_cover_finalScaled",
         "C4_cover_finalScaled",  "forb_cover_finalScaled", 
         "broadLeaved_cover_finalScaled", "needleLeaved_cover_finalScaled")

# make maps for level 2 cover w/ future 1 climate data
future1_cover2_ScaledPreds_maps <- map(c("C3_cover_finalScaled",
         "C4_cover_finalScaled",  "forb_cover_finalScaled", 
         "broadLeaved_cover_finalScaled", "needleLeaved_cover_finalScaled"), .f = function(x) {
           # make the raster
           rast_1 <- preds_future_1 %>% 
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = x, 
                   fun = mean, na.rm = TRUE) %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])))
           
           # make map 
           map_1  <- ggplot() +
  geom_spatraster(data = rast_1) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("'Scaled' prediction of ", x, " with 
                    future climate data from model 1")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(rast_1)[c(1,3)]) + 
  ylim(st_bbox(rast_1)[c(2,4)])
           
           return(list("rast" = rast_1, "map" = map_1))
         }
         )
names(future1_cover2_ScaledPreds_maps) <- c("C3_cover_finalScaled",
         "C4_cover_finalScaled",  "forb_cover_finalScaled", 
         "broadLeaved_cover_finalScaled", "needleLeaved_cover_finalScaled")

# make maps for level 2 cover w/ future 2 climate data
future2_cover2_ScaledPreds_maps <- map(c("C3_cover_finalScaled",
         "C4_cover_finalScaled",  "forb_cover_finalScaled", 
         "broadLeaved_cover_finalScaled", "needleLeaved_cover_finalScaled"), .f = function(x) {
           # make the raster
           rast_1 <- preds_future_2 %>% 
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = x, 
                   fun = mean, na.rm = TRUE) %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])))
           
           # make map 
           map_1  <- ggplot() +
  geom_spatraster(data = rast_1) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("'Scaled' prediction of ", x, " with 
                    future climate data from model 2")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(rast_1)[c(1,3)]) + 
  ylim(st_bbox(rast_1)[c(2,4)])
           
           return(list("rast" = rast_1, "map" = map_1))
         }
         )


names(future2_cover2_ScaledPreds_maps) <- c("C3_cover_finalScaled",
         "C4_cover_finalScaled",  "forb_cover_finalScaled", 
         "broadLeaved_cover_finalScaled", "needleLeaved_cover_finalScaled")

```


### Figures of final, scaled, 'level 1' cover classes with contemporary climate data 

```{r fig.width=18, fig.height=18}

# make maps of residuals between scaled predictions and observations
shrubCover_resids_final <- contempScaledPreds_maps[[1]]$rast - plotObservations_CONUS_shrub_2 
bareGround_resids_final <- contempScaledPreds_maps[[2]]$rast - plotObservations_CONUS_bareGround_2 
totalHerb_resids_final <- contempScaledPreds_maps[[3]]$rast - plotObservations_F_totHerb_2
totalTree_resids_final <- contempScaledPreds_maps[[4]]$rast - plotObservations_F_totTree_2

mapResids_final_shrubCover <- ggplot() +
  geom_spatraster(data = shrubCover_resids_final) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(shrubCover_resids_final)),fill=NA ) +
labs(title = paste0("Residuals (scaled final model prediction - observations) for 
                    predicted shrub cover (scaled and relativized)")) +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       )  + 
  xlim(st_bbox(shrubCover_resids_final)[c(1,3)]) + 
  ylim(st_bbox(shrubCover_resids_final)[c(2,4)])

mapResids_final_bareGround <- ggplot() +
  geom_spatraster(data = bareGround_resids_final) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(bareGround_resids_final)),fill=NA ) +
labs(title = paste0("Residuals (scaled final model prediction - observations) for 
                    predicted bare ground cover (scaled and relativized)")) +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       )  + 
  xlim(st_bbox(bareGround_resids_final)[c(1,3)]) + 
  ylim(st_bbox(bareGround_resids_final)[c(2,4)])

mapResids_final_totalHerb <- ggplot() +
  geom_spatraster(data = totalHerb_resids_final) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(totalHerb_resids_final)),fill=NA ) +
labs(title = paste0("Residuals (scaled final model prediction - observations) for 
                    predicted total herbaceous cover (scaled and relativized)")) +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       )  + 
  xlim(st_bbox(totalHerb_resids_final)[c(1,3)]) + 
  ylim(st_bbox(totalHerb_resids_final)[c(2,4)])

mapResids_final_totalTree <- ggplot() +
  geom_spatraster(data = totalTree_resids_final) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(totalTree_resids_final)),fill=NA ) +
labs(title = paste0("Residuals (scaled final model prediction - observations) for 
                    predicted total tree cover (scaled and relativized)")) +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       )  + 
  xlim(st_bbox(totalTree_resids_final)[c(1,3)]) + 
  ylim(st_bbox(totalTree_resids_final)[c(2,4)])


## level 1 cover variables
ggarrange( contempScaledPreds_maps[[3]]$map, map_obs_F_totHerb, mapResids_final_totalHerb,
           contempScaledPreds_maps[[4]]$map,  map_obs_F_totTree, mapResids_final_totalTree,
           contempScaledPreds_maps[[1]]$map, map_obs_CONUS_shrub, mapResids_final_shrubCover,
           contempScaledPreds_maps[[2]]$map, map_obs_CONUS_bareGround, mapResids_final_bareGround,
  ncol = 3, nrow = 4
  ) %>% 
  annotate_figure(fig.lab = "Final scaled and Relativized predictions, observations, and residuals for 'level 1' cover classes with contemporary climate data", fig.lab.size = 20)

```


### Figures of final, scaled, 'level 2' cover classes with contemporary climate data 

```{r fig.width=18, fig.height=22}
## level 2 cover variables

# calculate the actual observed cover (rather than proportion) for level 2 cover
plotObservations_C3_actualCover <-  plotObservations_F_totHerb_2 * (plotObservations_C3_proportion_2/100)
plotObservations_C4_actualCover <-  plotObservations_F_totHerb_2 * (plotObservations_C4_proportion_2/100)
plotObservations_forb_actualCover <-  plotObservations_F_totHerb_2 * (plotObservations_forb_proportion_2/100)
plotObservations_broadLeaved_actualCover <-  plotObservations_F_totTree_2 * (plotObservations_broadLeaved_forest_proportion_2/100)
plotObservations_needleLeaved_actualCover <-  plotObservations_F_totTree_2 * (plotObservations_needleLeaved_proportion_2/100)

# make maps of observations (not proportion, but actual values)
map_obs_C3_actualCover <-  ggplot() +
  geom_spatraster(data = plotObservations_C3_actualCover) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObservations_C3_actualCover)),fill=NA ) +
labs(title = paste0("Observations of actual cover - C3 graminoids")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObservations_C3_actualCover)[c(1,3)]) + 
  ylim(st_bbox(plotObservations_C3_actualCover)[c(2,4)])

map_obs_C4_actualCover <-  ggplot() +
  geom_spatraster(data = plotObservations_C4_actualCover) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObservations_C4_actualCover)),fill=NA ) +
labs(title = paste0("Observations of actual cover - C4 graminoids")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObservations_C4_actualCover)[c(1,3)]) + 
  ylim(st_bbox(plotObservations_C4_actualCover)[c(2,4)])

map_obs_forb_actualCover <-  ggplot() +
  geom_spatraster(data = plotObservations_forb_actualCover) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObservations_forb_actualCover)),fill=NA ) +
labs(title = paste0("Observations of actual cover - forbs")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObservations_forb_actualCover)[c(1,3)]) + 
  ylim(st_bbox(plotObservations_forb_actualCover)[c(2,4)])

map_obs_broadLeaved_actualCover <-  ggplot() +
  geom_spatraster(data = plotObservations_broadLeaved_actualCover) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObservations_broadLeaved_actualCover)),fill=NA ) +
labs(title = paste0("Observations of actual cover - broadLeaved trees")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObservations_broadLeaved_actualCover)[c(1,3)]) + 
  ylim(st_bbox(plotObservations_broadLeaved_actualCover)[c(2,4)])

map_obs_needleLeaved_actualCover <-  ggplot() +
  geom_spatraster(data = plotObservations_needleLeaved_actualCover) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(plotObservations_needleLeaved_actualCover)),fill=NA ) +
labs(title = paste0("Observations of actual cover - needleLeaved trees")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(st_bbox(plotObservations_needleLeaved_actualCover)[c(1,3)]) + 
  ylim(st_bbox(plotObservations_needleLeaved_actualCover)[c(2,4)])


# make maps of residuals between scaled predictions and observations
C3Cover_resids_final <- contemp_cover2_ScaledPreds_maps[[1]]$rast - plotObservations_C3_actualCover 
C4Cover_resids_final <- contemp_cover2_ScaledPreds_maps[[2]]$rast - plotObservations_C4_actualCover 
forb_resids_final <- contemp_cover2_ScaledPreds_maps[[3]]$rast - plotObservations_forb_actualCover
broadLeaved_resids_final <- contemp_cover2_ScaledPreds_maps[[4]]$rast - plotObservations_broadLeaved_actualCover
needleLeaved_resids_final <- contemp_cover2_ScaledPreds_maps[[4]]$rast - plotObservations_needleLeaved_actualCover

mapResids_final_C3 <- ggplot() +
  geom_spatraster(data = C3Cover_resids_final) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(C3Cover_resids_final)),fill=NA ) +
labs(title = paste0("Residuals (scaled final model prediction - observations) for 
                    predicted C3 graminoid cover (scaled and relativized)")) +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       )  + 
  xlim(st_bbox(C3Cover_resids_final)[c(1,3)]) + 
  ylim(st_bbox(C3Cover_resids_final)[c(2,4)])

mapResids_final_C4 <- ggplot() +
  geom_spatraster(data = C4Cover_resids_final) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(C4Cover_resids_final)),fill=NA ) +
labs(title = paste0("Residuals (scaled final model prediction - observations) for 
                    predicted C4 graminoid cover (scaled and relativized)")) +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       )  + 
  xlim(st_bbox(C4Cover_resids_final)[c(1,3)]) + 
  ylim(st_bbox(C4Cover_resids_final)[c(2,4)])

mapResids_final_forb <- ggplot() +
  geom_spatraster(data = forb_resids_final) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(forb_resids_final)),fill=NA ) +
labs(title = paste0("Residuals (scaled final model prediction - observations) for 
                    predicted forb cover (scaled and relativized)")) +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       )  + 
  xlim(st_bbox(forb_resids_final)[c(1,3)]) + 
  ylim(st_bbox(forb_resids_final)[c(2,4)])

mapResids_final_broadLeaved <- ggplot() +
  geom_spatraster(data = broadLeaved_resids_final) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(broadLeaved_resids_final)),fill=NA ) +
labs(title = paste0("Residuals (scaled final model prediction - observations) for 
                    predicted broad leaved tree cover (scaled and relativized)")) +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       )  + 
  xlim(st_bbox(broadLeaved_resids_final)[c(1,3)]) + 
  ylim(st_bbox(broadLeaved_resids_final)[c(2,4)])

mapResids_final_needleLeaved <- ggplot() +
  geom_spatraster(data = needleLeaved_resids_final) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(needleLeaved_resids_final)),fill=NA ) +
labs(title = paste0("Residuals (scaled final model prediction - observations) for 
                    predicted needle leaved tree cover (scaled and relativized)")) +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0,   na.value = "grey20",
                       limits = c(-100,100)
                       )  + 
  xlim(st_bbox(needleLeaved_resids_final)[c(1,3)]) + 
  ylim(st_bbox(needleLeaved_resids_final)[c(2,4)])

## level 1 cover variables
ggarrange(contemp_cover2_ScaledPreds_maps[[1]]$map, map_obs_C3_actualCover, mapResids_final_C3,
          contemp_cover2_ScaledPreds_maps[[2]]$map, map_obs_C4_actualCover, mapResids_final_C4,
          contemp_cover2_ScaledPreds_maps[[3]]$map, map_obs_forb_actualCover, mapResids_final_forb,
          contemp_cover2_ScaledPreds_maps[[4]]$map, map_obs_broadLeaved_actualCover, mapResids_final_broadLeaved,
          contemp_cover2_ScaledPreds_maps[[5]]$map, map_obs_needleLeaved_actualCover, mapResids_final_needleLeaved,
  ncol = 3, nrow = 5)%>% 
  annotate_figure(fig.lab = "Final scaled and Relativized predictions, observations, and residuals for 'level 2' cover classes with contemporary climate data", fig.lab.size = 20)

```

## Finally, make a map of total cover (the summed predicted cover of total trees, total herbaceous, shrubs, and bare ground, prior to scaling)
```{r}
rast_1 <- preds_contemp %>% 
  terra::vect(geom = c("x", "y")) %>% 
  terra::set.crs(crs(test_rast)) %>% 
  terra::rasterize(y = test_rast, 
                   field = "totalCover", 
                   fun = mean, na.rm = TRUE) %>% 
  crop(ext(min(tempExt[,1]), max(tempExt[,1]),
           min(tempExt[,2]), max(tempExt[,2])))
           
           # make map 
           (map_totalCover  <- ggplot() +
  geom_spatraster(data = rast_1) + 
  geom_sf(data = mapRegions, fill = NA, col = "orchid", lwd = .5) +
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("Total, unscaled cover with 
                    contemporary climate data")) +
  scale_fill_gradient2(low = "white",
                       high = "purple" , 
                       #midpoint = 0, 
                       limits = c(0,250),  
                       na.value = "lightgrey") + 
  xlim(st_bbox(rast_1)[c(1,3)]) + 
  ylim(st_bbox(rast_1)[c(2,4)]))
           
```

## compare prediction of level 1, relativized cover to cover from former SOILWAT version, but only within the sagebrush biome 
```{r fig.width=18, fig.height=22}
## read in data from Daniel w/ former SOILWAT output 
bareGroundCover_ds <- terra::rast("../../../Data_raw/vegCoverOutputFromDaniel_sagebrushBiome/veg_SageGrouseClimate-MACAv2.nc", 
                                      drivers = "NETCDF", 
                                      subds = "fcover_bg"
                                      ) %>% 
  terra::project(test_rast) %>% 
  resample(test_rast) %>% 
  crop(contempScaledPreds_maps[[3]]$rast)

forbCover_ds <- terra::rast("../../../Data_raw/vegCoverOutputFromDaniel_sagebrushBiome/veg_SageGrouseClimate-MACAv2.nc", 
                                      drivers = "NETCDF", 
                                      subds = "fcover_forbs"
                                      )%>% 
  terra::project(test_rast)%>% 
  resample(test_rast) %>% 
  crop(contempScaledPreds_maps[[3]]$rast)

grassCover_ds <- terra::rast("../../../Data_raw/vegCoverOutputFromDaniel_sagebrushBiome/veg_SageGrouseClimate-MACAv2.nc", 
                                      drivers = "NETCDF", 
                                      subds = "fcover_grasses"
                                      )%>% 
  terra::project(test_rast)%>% 
  resample(test_rast) %>% 
  crop(contempScaledPreds_maps[[3]]$rast)

shrubsCover_ds <- terra::rast("../../../Data_raw/vegCoverOutputFromDaniel_sagebrushBiome/veg_SageGrouseClimate-MACAv2.nc", 
                                      drivers = "NETCDF", 
                                      subds = "fcover_shrubs"
                                      )%>% 
  terra::project(test_rast) %>% 
  resample(test_rast) %>% 
  crop(contempScaledPreds_maps[[3]]$rast)

treeCover_ds <- terra::rast("../../../Data_raw/vegCoverOutputFromDaniel_sagebrushBiome/veg_SageGrouseClimate-MACAv2.nc", 
                                      drivers = "NETCDF", 
                                      subds = "fcover_trees"
                                      )%>% 
  terra::project(test_rast) %>% 
  resample(test_rast) %>% 
  crop(contempScaledPreds_maps[[3]]$rast)


## now, compare the projected values from this dataset to the values we predicted. 
# contemporary predictions from my models 
# total herb
#contempScaledPreds_maps[[3]]$rast
# total tree
#contempScaledPreds_maps[[4]]$rast
# shrub
#contempScaledPreds_maps[[1]]$rast
# bare ground
#contempScaledPreds_maps[[2]]$rast
## use the data from Daniel as a mask to trim my model outputs to the sagebrush biome
totHerb_as <- 
contempScaledPreds_maps[[3]]$rast %>% 
  crop(y = treeCover_ds, mask = TRUE)

totTree_as <- 
contempScaledPreds_maps[[4]]$rast %>% 
  crop(y = treeCover_ds, mask = TRUE)

shrub_as <- 
contempScaledPreds_maps[[1]]$rast %>% 
  crop(y = treeCover_ds, mask = TRUE)

bareGround_as <- 
contempScaledPreds_maps[[2]]$rast %>% 
  crop(y = treeCover_ds, mask = TRUE)

# plot shrub preds from my model vs old SOILWAT output
shrubMap_as <- ggplot() +
  geom_spatraster(data = shrub_as) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("Final shrub fractional cover from our current model")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(c(-1956750, 3250)) + 
  ylim(c(-883500, 952500))
shrubMap_ds <- ggplot() +
  geom_spatraster(data = shrubsCover_ds*100) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("Final shrub fractional cover from previous SOILWAT run")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(c(-1956750, 3250)) + 
  ylim(c(-883500, 952500))
shrubCompareMap <- ggplot() +
  geom_spatraster(data = shrub_as - shrubsCover_ds*100) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("diffs: current model Shrub preds - previous SOILWAT preds")) +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0, limits = c(-100,100),  na.value = "lightgrey") + 
  xlim(c(-1956750, 3250)) + 
  ylim(c(-883500, 952500))

# plot tree preds from my model vs old SOILWAT output
treeMap_as <- ggplot() +
  geom_spatraster(data = totTree_as) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("Final tree fractional cover from our current model")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(c(-1956750, 3250)) + 
  ylim(c(-883500, 952500))
treeMap_ds <- ggplot() +
    geom_spatraster(data = treeCover_ds*100) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("Final tree fractional cover from previous SOILWAT run")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(c(-1956750, 3250)) + 
  ylim(c(-883500, 952500))
treeCompareMap <- ggplot() +
  geom_spatraster(data = totTree_as - treeCover_ds*100) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("diffs: current model tree preds - previous SOILWAT preds")) +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0, limits = c(-100,100),  na.value = "lightgrey") + 
  xlim(c(-1956750, 3250)) + 
  ylim(c(-883500, 952500))

# plot herbaceous preds from my model vs old SOILWAT output
herbMap_as <- ggplot() +
  geom_spatraster(data = totHerb_as) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("Final total herbaceous fractional cover from our current model")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(c(-1956750, 3250)) + 
  ylim(c(-883500, 952500))
herbMap_ds <- ggplot() +
    geom_spatraster(data = (grassCover_ds + forbCover_ds)*100) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("Final herbaceous fractional cover from previous SOILWAT run")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(c(-1956750, 3250)) + 
  ylim(c(-883500, 952500))
herbCompareMap <- ggplot() +
  geom_spatraster(data = totHerb_as - (grassCover_ds + forbCover_ds)*100) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("diffs: current model herbaceous preds - previous SOILWAT preds")) +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0, limits = c(-100,100),  na.value = "lightgrey") + 
  xlim(c(-1956750, 3250)) + 
  ylim(c(-883500, 952500))

# plot bare ground preds from my model vs old SOILWAT output
bareGroundMap_as <- ggplot() +
  geom_spatraster(data = bareGround_as) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("Final total bare ground fractional cover from our current model")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(c(-1956750, 3250)) + 
  ylim(c(-883500, 952500))
bareGroundMap_ds <- ggplot() +
    geom_spatraster(data = (bareGroundCover_ds)*100) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("Final herbaceous fractional cover from previous SOILWAT run")) +
  scale_fill_gradient2(low = "brown",
                       mid = "wheat" ,
                       high = "darkgreen" , 
                       midpoint = 0, limits = c(0,100),  na.value = "lightgrey") + 
  xlim(c(-1956750, 3250)) + 
  ylim(c(-883500, 952500))
bareGroundCompareMap <- ggplot() +
  geom_spatraster(data = bareGround_as - (bareGroundCover_ds)*100) + 
  geom_sf(data=cropped_states %>% st_transform(crs = st_crs(test_rast)) %>% st_crop(st_bbox(rast_1)),fill=NA ) +
labs(title = paste0("diffs: current model bare ground preds - previous SOILWAT preds")) +
  scale_fill_gradient2(low = "red",
                       mid = "white" ,
                       high = "blue" , 
                       midpoint = 0, limits = c(-100,100),  na.value = "lightgrey") + 
  xlim(c(-1956750, 3250)) + 
  ylim(c(-883500, 952500))

## show all predictions together
ggarrange(herbMap_as, herbMap_ds, herbCompareMap, 
          treeMap_as, treeMap_ds, treeCompareMap, 
          shrubMap_as, shrubMap_ds, shrubCompareMap, 
          bareGroundMap_as, bareGroundMap_ds, bareGroundCompareMap, 
          ncol = 3, nrow = 4) %>% 
  annotate_figure(fig.lab = "Comparing relativized predictions from current models to previous SOILWAT data", fig.lab.size = 20)
```

